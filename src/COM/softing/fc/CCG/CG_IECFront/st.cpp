/*!!!!! this file has been generated using yyreplace.pl !!!!!*/
/* input files for yyreplace.pl: st.y, st.cpp~, st.h~*/

/*START yyreplace.pl: include files and #yy_movetop lines from st.y */
#include "st_ParseContext.h"
#include "il_ParseContext.h"
#include "configuration.h"
#include "CG_Messages.h"
#include "IECKeywords.h"
#include "utilif.h"
#include "utilsts.h"
#include "LDFBD.h"
 struct ST_TagVal //helper for sys comment tag="val" pairs 
 {
     ST_Identifier_C* pTag;
     ST_Identifier_C* pVal;
 };
/*END yyreplace.pl: include files from st.y */


/*START yyreplace.pl: file st.h~ */
typedef union {
    CG_Edipos              edp;
    ST_Literal_C*          lit;
    ST_Identifier_C*       ident;
    ST_DirectVar_C*        direct;
    ST_Expression_C*       expr;
    ST_ExpressionList_C*   list;
    ST_CParamList*         paramlist; /*##AC*/
    CG_EXPRTYP             exprtyp;
    CG_DTYPES              btype;
    const CG_DType*        dtype;
    CG_BITSET              bitset; 
    WORD                   declmod;//Bit field of CG_DMOD_RETAIN,..
    ST_TagVal              tagval;
    ST_CAttrList*          attrlist;
    ST_CDeclList*          decllist; //list of ident and opt. attributes
    ST_StructInit_C*       structInit;
    ST_ArrayInit_C*        arrayInit;
    CG_POUTYP              poutyp;
    ST_CTaskInits*         taskinit;
    ST_CTaskList*          tasklist;
    CG_STStmt*             stmt;
    struct{
       CG_STStmt*          plistbegn;
       CG_STStmt*          plistlast;
    } stmtlist;
    struct{
       CG_STCaseList*      pcasebegn;
       CG_STStmt*          plistlast;
    } caselist;
    ST_CCaseExpr*          caserange;
    ST_CTypeOrList*        typeor;
    /* IL stuff */
    struct{
       IL_Instr*           pinstrbegn;
       IL_Instr*           pinstrlast;
    } instrlist;
    IL_Instr*              instr;
	struct {
	    ST_DirectVar_C*    optdirect;
	    ST_Identifier_C*   optsysvar;
	} optaddr;
} YYSTYPE;
const MOD = 257;
const POW = 258;
const AND = 259;
const OR = 260;
const XOR = 261;
const NOT = 262;
const EQ = 263;
const NE = 264;
const LT = 265;
const LE = 266;
const GT = 267;
const GE = 268;
const BECOMES = 269;
const DOTDOT = 270;
const IF = 271;
const THEN = 272;
const ELSIF = 273;
const ELSE = 274;
const END_IF = 275;
const CASE = 276;
const OF = 277;
const END_CASE = 278;
const RETURN = 279;
const WHILE = 280;
const DO = 281;
const END_WHILE = 282;
const REPEAT = 283;
const UNTIL = 284;
const END_REPEAT = 285;
const FOR = 286;
const TO = 287;
const BY = 288;
const END_FOR = 289;
const EXIT = 290;
const ON = 291;
const TYPE = 292;
const END_TYPE = 293;
const STRUCT = 294;
const END_STRUCT = 295;
const PROGRAM = 296;
const END_PROGRAM = 297;
const FUNCTION = 298;
const END_FUNCTION = 299;
const FUNCTION_BLOCK = 300;
const END_FUNCTION_BLOCK = 301;
const AT = 302;
const RIGHT_ARROW = 303;
const CONFIGURATION = 304;
const END_CONFIGURATION = 305;
const RESOURCE = 306;
const END_RESOURCE = 307;
const TASK = 308;
const F_EDGE = 309;
const R_EDGE = 310;
const WITH = 311;
const VAR_ACCESS = 312;
const READ_ONLY = 313;
const READ_WRITE = 314;
const PERIOD = 315;
const ARRAY = 316;
const VAR = 317;
const VAR_INPUT = 318;
const VAR_OUTPUT = 319;
const VAR_IN_OUT = 320;
const VAR_EXTERNAL = 321;
const VAR_GLOBAL = 322;
const VAR_TEMP = 323;
const VAR_IN_EXT = 324;
const VAR_CONFIG = 325;
const END_VAR = 326;
const RETAIN = 327;
const NON_RETAIN = 328;
const CONSTANT = 329;
const STEP = 330;
const END_STEP = 331;
const INITIAL_STEP = 332;
const TRANSITION = 333;
const END_TRANSITION = 334;
const ACTION = 335;
const END_ACTION = 336;
const FROM = 337;
const SYS_COMMENT_BEGIN = 338;
const SYS_COMMENT_END = 339;
const GOTO = 340;
const SYNCHRONIZED = 341;
const END_SYNCHRONIZED = 342;
const DECL_CONST = 343;
const DECL_END_CONST = 344;
const END_NATIVE = 345;
const NATIVE = 346;
const VAR_NATIVE = 347;
const OVERLOAD = 348;
const KW_INLINE = 349;
const IMPORT_DIRECTIVE = 350;
const WSTRING_BEG = 351;
const STRING_BEG = 352;
const IDENTIFIER = 353;
const DIRECT_VARIABLE = 354;
const SIMPLE_LITERAL = 355;
const BASIC_TYP = 356;
const QVT_TYP = 357;
const GVLCST_START = 358;
const HDRFILE_START = 359;
const EXPR_START = 360;
const STACTION_START = 361;
const BODY_START = 362;
const IL_BODY_START = 363;
const IL_OP_LD = 364;
const IL_OP_LDN = 365;
const IL_OP_ST = 366;
const IL_OP_STN = 367;
const IL_OP_NOT = 368;
const IL_OP_RPAR = 369;
const IL_OP_S = 370;
const IL_OP_R = 371;
const IL_OP_S1 = 372;
const IL_OP_R1 = 373;
const IL_OP_CLK = 374;
const IL_OP_CU = 375;
const IL_OP_CD = 376;
const IL_OP_PV = 377;
const IL_OP_IN = 378;
const IL_OP_PT = 379;
const IL_OP_AND = 380;
const IL_OP_OR = 381;
const IL_OP_XOR = 382;
const IL_OP_ANDN = 383;
const IL_OP_ORN = 384;
const IL_OP_XORN = 385;
const IL_OP_ADD = 386;
const IL_OP_SUB = 387;
const IL_OP_MUL = 388;
const IL_OP_DIV = 389;
const IL_OP_MOD = 390;
const IL_OP_GT = 391;
const IL_OP_GE = 392;
const IL_OP_EQ = 393;
const IL_OP_LT = 394;
const IL_OP_LE = 395;
const IL_OP_NE = 396;
const IL_OP_CAL = 397;
const IL_OP_CALC = 398;
const IL_OP_CALCN = 399;
const IL_OP_RET = 400;
const IL_OP_RETC = 401;
const IL_OP_RETCN = 402;
const IL_OP_JMP = 403;
const IL_OP_JMPC = 404;
const IL_OP_JMPCN = 405;
const IL_IDENTIFIER = 406;


#ifdef YYTRACE
#define YYDEBUG 1
#else
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#endif
// C++ YACC parser header
// Copyright 1991 by Mortice Kern Systems Inc.  All rights reserved.
//
// st_parse => class defining a parsing object
//	st_parse needs a class yy_, which defines the ner.
// %prefix or option -p xx determines name of this class; if not used,
// defaults to 'yy_'
//
// constructor fills in the tables for this grammar; give it a size
//    to determine size of state and value stacks. Default is 150 entries.
// destructor discards those state and value stacks
//
// int st_parse::yyparse(yy_ *) invokes parse; if this returns,
//	it can be recalled to continue parsing at last point.
// void st_parse::yyreset() can be called to reset the parse;
//	call yyreset() before st_parse::yyparse(yy_ *)
#include <stdio.h>		// uses printf(), et cetera

const YYERRCODE = 256;		// YACC 'error' value

// You can use these macros in your action code
#define YYERROR		goto yyerrlabel
#define YYACCEPT	YYRETURN(0)
#define YYABORT		YYRETURN(1)
#define YYRETURN(val)	return(val)

/*
 * Simulate bitwise negation as if it was done ona two's complement machine.
 * This makes the generated code portable to machines with different 
 * representations of integers (ie. signed magnitude).
 */
#define yyneg(s)	(-((s)+1))

#if YYDEBUG
typedef struct yyNamedType_tag {	/* Tokens */
	char	* name;		/* printable name */
	short	token;		/* token # */
	short	type;		/* token type */
} yyNamedType;
typedef struct yyTypedRules_tag {	/* Typed rule table */
	char	* name;		/* compressed rule string */
	short	type;		/* rule result type */
} yyTypedRules;
#endif


class st_ParseContext;
class st_parse {
	st_ParseContext* pContext;
public:
	st_ParseContext* getParseContext(){return pContext;}
	void          setParseContext(st_ParseContext* pc){pContext=pc;}

protected:
	int	mustfree;	// set if tables should be deleted
	int	size;		// size of state and value stacks
	int	reset;		// if set, reset state
	short	yyi;		// table index
	short	yystate;	// current state

	short	* stateStack;	// states stack
	YYSTYPE	* valueStack;	// values stack
	short	* yyps;		// top of state stack
	YYSTYPE * yypv;		// top of value stack

	YYSTYPE yylval;		// saved yylval
	YYSTYPE	yyval;		// $
	YYSTYPE * yypvt;	// $n
	int	yychar;		// current token
	int	yyerrflag;	// error flag
	int	yynerrs;	// error count
#if YYDEBUG
	int	done;		// set from trace to stop parse
	int	rule, npop;	// reduction rule # and length
	short	* typeStack;	// type stack to mirror valueStack[]
	short	* yytp;		// top of type stack
	char	* yygetState(int);	// read 'states.out'
#endif
public:
#if YYDEBUG
	// C++ has trouble with initialized arrays inside classes
	static long * States;		// pointer to yyStates[]
	static yyTypedRules * Rules;	// pointer to yyRules[]
	static yyNamedType * TokenTypes; // pointer to yyTokenTypes[]
	static int	yyntoken;	// number of tokens
	static int	yynvar;		// number of variables (nonterminals)
	static int	yynstate;	// number of YACC-generated states
	static int	yynrule;	// number of rules in grammar

	char*	yyptok(int);		// printable token string
	int	yyExpandName(int, int, char *, int);
						// expand encoded string
	virtual int	yyGetType(int);		// return type of token
	virtual void	yyShowRead();		// see newly read token
	virtual void	yyShowState();		// see state, value stacks
	virtual void	yyShowReduce();		// see reduction
	virtual void	yyShowGoto();		// see goto
	virtual void	yyShowShift();		// see shift
	virtual void	yyShowErrRecovery();	// see error recovery
	virtual void	yyShowErrDiscard();	// see token discard in error
#endif
	int	yydebug;	// if set, tracing if compiled with YYDEBUG=1

    // constructor for this grammar
    //pError=0 == no error
    //pError=1 == out of memory
	st_parse(int* pError, int = 150); 

    // another constructor
    //pError=0 == no error
    //pError=1 == out of memory
    //pError=2 == bad state given
    st_parse(int* pError, int, short *, YYSTYPE *);	

	~st_parse();		// destructor

	int	yyparse();	
	int yynexttoken(YYSTYPE* val);
	void yyerrorSyntax();
	void yyerrorStackOverflow();

	void	yyreset() { reset = 1; } // restore state for next yyparse()

	void	setdebug(int y) { yydebug = y; }

// The following are useful in user actions:

	void	yyerrok() { yyerrflag = 0; }	// clear error
	void	yyclearin() { yychar = -1; }	// clear input
	int	YYRECOVERING() { return yyerrflag != 0; }
};
// end of .hpp header
/*END yyreplace.pl: file st.h~ */
/*START yyreplace.pl: file st.cpp~ */
/* yacc -lmv -LC -P C:\ATCMControl_SDK\GenWork\GenDir.tmp\4Control_R\gentools\yyparse.cpp -o st.cpp~ -D st.h~ st.y */



#include "st_ParseContext.h"
#include "il_ParseContext.h"
#include "configuration.h"
#include "CG_Messages.h"
#include "IECKeywords.h"
#include "utilif.h"
#include "utilsts.h"
#include "LDFBD.h"


/*yyreplace.pl: moved on top: #yy_movetop struct ST_TagVal //helper for sys comment tag="val" pairs  */
/*yyreplace.pl: moved on top: #yy_movetop { */
/*yyreplace.pl: moved on top: #yy_movetop     ST_Identifier_C* pTag; */
/*yyreplace.pl: moved on top: #yy_movetop     ST_Identifier_C* pVal; */
/*yyreplace.pl: moved on top: #yy_movetop }; */




/* to avoid 1000 Warning of the same kind */
#pragma  warning( disable : 4309 4305 4102 4244)

#if YYDEBUG
enum YY_Types { YY_t_NoneDefined, YY_t_edp, YY_t_ident, YY_t_direct, YY_t_lit, YY_t_btype, YY_t_instr, YY_t_expr, YY_t_paramlist, YY_t_arrayInit, YY_t_structInit, YY_t_list, YY_t_dtype, YY_t_typeor, YY_t_decllist, YY_t_tagval, YY_t_attrlist, YY_t_exprtyp, YY_t_declmod, YY_t_optaddr, YY_t_poutyp, YY_t_taskinit, YY_t_tasklist, YY_t_stmtlist, YY_t_stmt, YY_t_caselist, YY_t_caserange, YY_t_instrlist
};
#endif
#if YYDEBUG
yyTypedRules yyRules[] = {
	{ "&000: %090 &000",  0},
	{ "%090: %091",  0},
	{ "%090: %092",  0},
	{ "%090: %093",  0},
	{ "%090: %094",  0},
	{ "%090: &114 %095",  0},
	{ "%090: &115 %096",  0},
	{ "%090: &116 %001",  0},
	{ "%090: &117 %056",  0},
	{ "%090: &118 %097",  0},
	{ "%090: &119 %098",  0},
	{ "%090: %035",  0},
	{ "%035: %034 %099 &095",  16},
	{ "%035: &094 &095",  16},
	{ "%035:",  16},
	{ "%099: &163",  0},
	{ "%099:",  0},
	{ "%034: &094 %033",  16},
	{ "%034: %034 &163 %033",  16},
	{ "%033: %048 &019 &107",  15},
	{ "%033: %048 &019 &109",  15},
	{ "%033: %048 &019",  15},
	{ "%048: &109",  2},
	{ "%048: &109 &012 &109",  2},
	{ "%100:",  0},
	{ "%095: %035 %100 %101",  0},
	{ "%102:",  0},
	{ "%103:",  0},
	{ "%092: %035 %102 &048 %103 %104 &049",  0},
	{ "%104: %105 &164",  0},
	{ "%104: %104 %105 &164",  0},
	{ "%106:",  0},
	{ "%105: &109 &009 &050 %106 %107 &051",  0},
	{ "%105: &109 &009 &109",  0},
	{ "%105: &109 &009 &072",  0},
	{ "%105: &109 &009 &007",  0},
	{ "%105: &109 &009 %024 &007 %003 &026 %003 &008",  0},
	{ "%105: &001",  0},
	{ "%108:",  0},
	{ "%093: %035 &060 &109 %108 %109 %110 %111 %112 &061",  0},
	{ "%109: &078",  0},
	{ "%109:",  0},
	{ "%112: &081",  0},
	{ "%112:",  0},
	{ "%110: %113",  0},
	{ "%110:",  0},
	{ "%113: %094",  0},
	{ "%113: &106",  0},
	{ "%113: %113 %094",  0},
	{ "%113: %113 &106",  0},
	{ "%114:",  0},
	{ "%094: %035 &062 &109 %035 %039 %114 %101 %053 %115 &063",  0},
	{ "%039: &047 &109",  2},
	{ "%039: &047 &107",  2},
	{ "%039:",  2},
	{ "%053: %052",  22},
	{ "%053:",  22},
	{ "%052: &064 &109 %035 &007 %051 &008 &164",  22},
	{ "%052: %052 &064 &109 %035 &007 %051 &008 &164",  22},
	{ "%051: %050",  21},
	{ "%051:",  21},
	{ "%050: &109 &025 %001",  21},
	{ "%050: %050 &163 &109 &025 %001",  21},
	{ "%115: %116",  0},
	{ "%115:",  0},
	{ "%116: %117 &164",  0},
	{ "%116: %116 %117 &164",  0},
	{ "%117: &052 %044 &109 %035 %037 &009 &109 %118",  0},
	{ "%037: &067 &109",  2},
	{ "%037:",  2},
	{ "%118: &007 %119 &008",  0},
	{ "%118:",  0},
	{ "%119: %120",  0},
	{ "%119: %119 &163 %120",  0},
	{ "%120: &109 &067 &109",  0},
	{ "%120: &109 &025 %001",  0},
	{ "%120: &109 &059 %001",  0},
	{ "%111: &068",  0},
	{ "%111:",  0},
	{ "%091: %096 %121",  0},
	{ "%122:",  0},
	{ "%096: %035 %047 %046 %038 %026 %122 %101",  0},
	{ "%046: &052",  20},
	{ "%046: &056",  20},
	{ "%046: &054",  20},
	{ "%026: &009 %025",  12},
	{ "%026:",  12},
	{ "%038: %036",  2},
	{ "%038: &018",  2},
	{ "%036: &109",  2},
	{ "%036: &013",  2},
	{ "%036: &015",  2},
	{ "%036: &016",  2},
	{ "%036: &017",  2},
	{ "%097: %123 &057",  0},
	{ "%097: %123 &055",  0},
	{ "%097: %123 &053",  0},
	{ "%097:",  0},
	{ "%098: %124 &057",  0},
	{ "%098: %124 &055",  0},
	{ "%098: %124 &053",  0},
	{ "%098:",  0},
	{ "%123: %056",  0},
	{ "%123: %125",  0},
	{ "%124: %077",  0},
	{ "%121: %126 &057",  0},
	{ "%121: %126 &055",  0},
	{ "%121: %126 &053",  0},
	{ "%121:",  0},
	{ "%127:",  0},
	{ "%126: %127 %056",  0},
	{ "%128:",  0},
	{ "%126: %128 %125",  0},
	{ "%126: %129",  0},
	{ "%130:",  0},
	{ "%126: %130 %078",  0},
	{ "%131:",  0},
	{ "%129: %131 %132",  0},
	{ "%132: %133",  0},
	{ "%132: %132 %133",  0},
	{ "%134:",  0},
	{ "%133: &104 %027 &007 %030 &008 %040 %134",  0},
	{ "%133: &105 &010",  0},
	{ "%133: &105 %041",  0},
	{ "%040: &105 &010",  2},
	{ "%135:",  0},
	{ "%040: %135 %054",  2},
	{ "%030: %029",  13},
	{ "%030: %029 &163 &071",  13},
	{ "%030:",  13},
	{ "%029: %136 %028",  13},
	{ "%029: %029 &163 %136 %028",  13},
	{ "%027: %136",  12},
	{ "%027: %024 &043 %136",  12},
	{ "%027:",  12},
	{ "%028: &043 %024",  12},
	{ "%028:",  12},
	{ "%136: %025",  0},
	{ "%136: %136 &002 %025",  0},
	{ "%041: &025",  17},
	{ "%041: &016",  17},
	{ "%041: &017",  17},
	{ "%041: &015",  17},
	{ "%041: &019",  17},
	{ "%041: &020",  17},
	{ "%041: &021",  17},
	{ "%041: &022",  17},
	{ "%041: &023",  17},
	{ "%041: &024",  17},
	{ "%041: &003",  17},
	{ "%041: &004",  17},
	{ "%041: &005",  17},
	{ "%041: &006",  17},
	{ "%041: &013",  17},
	{ "%041: &014",  17},
	{ "%041: &018",  17},
	{ "%041: &007 &008",  17},
	{ "%101: %137",  0},
	{ "%101:",  0},
	{ "%137: %138",  0},
	{ "%137: %137 %138",  0},
	{ "%137: &001",  0},
	{ "%139:",  0},
	{ "%141:",  0},
	{ "%142:",  0},
	{ "%138: %139 %140 %141 %107 %142 &082",  0},
	{ "%138: &103",  0},
	{ "%138: &106",  0},
	{ "%143:",  0},
	{ "%138: &099 %143 %107 &100",  0},
	{ "%107: %144",  0},
	{ "%107:",  0},
	{ "%144: %145 &164",  0},
	{ "%144: %144 %145 &164",  0},
	{ "%145: %032 %045 &009 %025 %076 %011",  0},
	{ "%145: &001",  0},
	{ "%076: &085",  18},
	{ "%076:",  18},
	{ "%045: &058 &110",  19},
	{ "%045: &058 &109",  19},
	{ "%045:",  19},
	{ "%032: %031",  14},
	{ "%032:",  14},
	{ "%031: &109 %035",  14},
	{ "%031: %031 &163 &109 %035",  14},
	{ "%047: &102",  2},
	{ "%047:",  2},
	{ "%011: &025 %012",  7},
	{ "%011:",  7},
	{ "%012: %001",  7},
	{ "%012: &165 %018 &166",  7},
	{ "%012: &007 %019 &008",  7},
	{ "%019: &109 &025 %012",  10},
	{ "%019: %019 &163 &109 &025 %012",  10},
	{ "%018: %013",  9},
	{ "%018: %003 &007 %018 &008",  9},
	{ "%018: %003 &007 &008",  9},
	{ "%018: &007 %001 &008 &007 %018 &008",  9},
	{ "%018: &007 %001 &008 &007 &008",  9},
	{ "%018: %018 &163 %013",  9},
	{ "%018: %018 &163 %003 &007 %018 &008",  9},
	{ "%018: %018 &163 %003 &007 &008",  9},
	{ "%018: %018 &163 &007 %001 &008 &007 %018 &008",  9},
	{ "%018: %018 &163 &007 %001 &008 &007 &008",  9},
	{ "%013: %003",  7},
	{ "%013: &007 %001 &008",  7},
	{ "%013: &007 %019 &008",  7},
	{ "%003: %049",  7},
	{ "%003: &003 %049",  7},
	{ "%003: &004 %049",  7},
	{ "%003: &109",  7},
	{ "%003: &003 &109",  7},
	{ "%003: &004 &109",  7},
	{ "%025: %023 %010",  12},
	{ "%025: &109 %010",  12},
	{ "%025: &072 %020 &033 %023 %010",  12},
	{ "%025: &072 %020 &033 &109 %010",  12},
	{ "%020: &165 %021 &166",  11},
	{ "%020:",  11},
	{ "%021: %001 &026 %001",  11},
	{ "%021: %021 &163 %001 &026 %001",  11},
	{ "%010: &165 %001 &166",  7},
	{ "%010:",  7},
	{ "%023: %024",  5},
	{ "%023: %024 &066",  5},
	{ "%023: %024 &065",  5},
	{ "%024: &112",  5},
	{ "%024: &113",  5},
	{ "%140: &078 %044",  0},
	{ "%140: &073 %044",  0},
	{ "%140: &074 %044",  0},
	{ "%140: &075 %044",  0},
	{ "%140: &076 %044",  0},
	{ "%140: &077 %044",  0},
	{ "%140: &079 %044",  0},
	{ "%140: &080 %044",  0},
	{ "%044: %043",  18},
	{ "%044:",  18},
	{ "%043: %042",  18},
	{ "%043: %043 %042",  18},
	{ "%042: &083",  18},
	{ "%042: &084",  18},
	{ "%042: &085",  18},
	{ "%125: %146",  0},
	{ "%125: %125 %146",  0},
	{ "%146: %147",  0},
	{ "%146: %148",  0},
	{ "%146: %149",  0},
	{ "%146: %150",  0},
	{ "%151:",  0},
	{ "%148: &086 &109 &009 %151 %152 &087",  0},
	{ "%153:",  0},
	{ "%147: &088 &109 &009 %153 %152 &087",  0},
	{ "%154:",  0},
	{ "%155:",  0},
	{ "%157:",  0},
	{ "%149: &089 %154 &093 %155 %156 &043 %157 %156 &025 %001 &164 &090",  0},
	{ "%158:",  0},
	{ "%159:",  0},
	{ "%160:",  0},
	{ "%149: &089 &109 %158 &093 %159 %156 &043 %160 %156 &025 %001 &164 &090",  0},
	{ "%156: &109",  0},
	{ "%156: &007 &109 &163 %161 &008",  0},
	{ "%161: &109",  0},
	{ "%161: %161 &163 &109",  0},
	{ "%162:",  0},
	{ "%150: &091 &109 &009 %162 %056 &092",  0},
	{ "%152: %163",  0},
	{ "%152:",  0},
	{ "%163: %164 &164",  0},
	{ "%163: %163 %164 &164",  0},
	{ "%164: &109 &007 %165 &008",  0},
	{ "%165: &109",  0},
	{ "%165: &109 &163 %049",  0},
	{ "%056: %054",  24},
	{ "%056:",  24},
	{ "%054: %055 &164",  23},
	{ "%054: %054 %055 &164",  23},
	{ "%055: &109 &009 %057",  23},
	{ "%055: %057",  23},
	{ "%057: %058",  24},
	{ "%057: %059",  24},
	{ "%057: %064",  24},
	{ "%057: %065",  24},
	{ "%057: %066",  24},
	{ "%057: %067",  24},
	{ "%057: %069",  24},
	{ "%057: %070",  24},
	{ "%057: %071",  24},
	{ "%057: %072",  24},
	{ "%057: %073",  24},
	{ "%057: %074",  24},
	{ "%057: %075",  24},
	{ "%057: &001",  24},
	{ "%058:",  24},
	{ "%059: %004 &025 %001",  24},
	{ "%071: &046",  24},
	{ "%072: &035",  24},
	{ "%073: &102",  24},
	{ "%064: %036 &007 %015 &008",  24},
	{ "%166:",  0},
	{ "%065: &027 %166 %001 &028 %056 %060 &031",  24},
	{ "%060: &029 %001 &028 %056 %060",  24},
	{ "%060: &030 %056",  24},
	{ "%060:",  24},
	{ "%066: &032 %001 &033 %062 %061 &034",  24},
	{ "%062: %063 &009 %057 &164",  25},
	{ "%062: %062 %063 &009 %057 &164",  25},
	{ "%062: %062 %057 &164",  25},
	{ "%061: &030 %056",  24},
	{ "%061:",  24},
	{ "%063: %003",  26},
	{ "%063: %003 &026 %003",  26},
	{ "%063: %063 &163 %003",  26},
	{ "%063: %063 &163 %003 &026 %003",  26},
	{ "%067: %068 &037 %056 &045",  24},
	{ "%068: &042 &109 &025 %001 &043 %001 %014",  24},
	{ "%014: &044 %001",  7},
	{ "%014:",  7},
	{ "%167:",  0},
	{ "%069: &036 %167 %001 &037 %056 &038",  24},
	{ "%168:",  0},
	{ "%070: &039 %168 %056 &040 %001 &041",  24},
	{ "%169:",  0},
	{ "%074: &097 %169 %056 &098",  24},
	{ "%075: &096 &109",  24},
	{ "%001: %001 &016 %001",  7},
	{ "%001: %001 &017 %001",  7},
	{ "%001: %001 &015 %001",  7},
	{ "%001: %001 &019 %001",  7},
	{ "%001: %001 &020 %001",  7},
	{ "%001: %001 &021 %001",  7},
	{ "%001: %001 &022 %001",  7},
	{ "%001: %001 &023 %001",  7},
	{ "%001: %001 &024 %001",  7},
	{ "%001: %001 &003 %001",  7},
	{ "%001: %001 &004 %001",  7},
	{ "%001: %001 &005 %001",  7},
	{ "%001: %001 &006 %001",  7},
	{ "%001: %001 &013 %001",  7},
	{ "%001: %001 &014 %001",  7},
	{ "%001: &004 %001",  7},
	{ "%001: &003 %001",  7},
	{ "%001: &018 %001",  7},
	{ "%001: %002",  7},
	{ "%002: %049",  7},
	{ "%002: %004",  7},
	{ "%002: &007 %001 &008",  7},
	{ "%002: %017",  7},
	{ "%002: &109 &009",  7},
	{ "%049: &107",  4},
	{ "%049: &108",  4},
	{ "%049: &111",  4},
	{ "%022: %001",  11},
	{ "%022: %022 &163 %001",  11},
	{ "%017: %036 &007 %015 &008",  7},
	{ "%017: &113 &007 %015 &008",  7},
	{ "%015: %016",  8},
	{ "%015:",  8},
	{ "%016: &109 &025 %001",  8},
	{ "%016: &109 &059 %001",  8},
	{ "%016: %001",  8},
	{ "%016: %016 &163 &109 &025 %001",  8},
	{ "%016: %016 &163 &109 &059 %001",  8},
	{ "%016: %016 &163 %001",  8},
	{ "%004: &110",  7},
	{ "%004: %006",  7},
	{ "%006: %005",  7},
	{ "%006: %007",  7},
	{ "%005: &109",  7},
	{ "%007: %008",  7},
	{ "%007: %009",  7},
	{ "%008: %006 &165 %022 &166",  7},
	{ "%009: %006 &012 &109",  7},
	{ "%077: %078",  27},
	{ "%077:",  27},
	{ "%078: %079",  27},
	{ "%078: %078 %079",  27},
	{ "%079: %080",  6},
	{ "%079: %081",  6},
	{ "%079: %082",  6},
	{ "%079: %083",  6},
	{ "%079: %088",  6},
	{ "%079: &162 &009",  6},
	{ "%080: %084 %089",  6},
	{ "%080: &124",  6},
	{ "%080: &162 %015",  6},
	{ "%081: %085 &007 %077 &125",  6},
	{ "%081: %085 &007 %089 %077 &125",  6},
	{ "%082: %087 &109",  6},
	{ "%089: %049",  7},
	{ "%089: &003 %049",  7},
	{ "%089: &004 %049",  7},
	{ "%089: %004",  7},
	{ "%089: &003 %004",  7},
	{ "%089: &004 %004",  7},
	{ "%083: %086 &109",  6},
	{ "%170:",  0},
	{ "%083: %086 &109 &007 %170 %015 &008",  6},
	{ "%084: &120",  6},
	{ "%084: &121",  6},
	{ "%084: &122",  6},
	{ "%084: &123",  6},
	{ "%084: &126",  6},
	{ "%084: &127",  6},
	{ "%084: &128",  6},
	{ "%084: &129",  6},
	{ "%084: &130",  6},
	{ "%084: &131",  6},
	{ "%084: &132",  6},
	{ "%084: &133",  6},
	{ "%084: &134",  6},
	{ "%084: &135",  6},
	{ "%084: %085",  6},
	{ "%085: &136",  6},
	{ "%085: &137",  6},
	{ "%085: &138",  6},
	{ "%085: &139",  6},
	{ "%085: &140",  6},
	{ "%085: &141",  6},
	{ "%085: &142",  6},
	{ "%085: &143",  6},
	{ "%085: &144",  6},
	{ "%085: &145",  6},
	{ "%085: &146",  6},
	{ "%085: &147",  6},
	{ "%085: &148",  6},
	{ "%085: &149",  6},
	{ "%085: &150",  6},
	{ "%085: &151",  6},
	{ "%085: &152",  6},
	{ "%086: &153",  6},
	{ "%086: &154",  6},
	{ "%086: &155",  6},
	{ "%088: &156",  6},
	{ "%088: &157",  6},
	{ "%088: &158",  6},
	{ "%087: &159",  6},
	{ "%087: &160",  6},
	{ "%087: &161",  6},
{ "$accept",  0},{ "error",  0}
};
yyNamedType yyTokenTypes[] = {
	{ "$end",  0,  0},
	{ "error",  256,  0},
	{ "'|'",  124,  1},
	{ "'+'",  43,  1},
	{ "'-'",  45,  1},
	{ "'*'",  42,  1},
	{ "'/'",  47,  1},
	{ "'('",  40,  1},
	{ "')'",  41,  1},
	{ "':'",  58,  1},
	{ "'{'",  123,  1},
	{ "'}'",  125,  1},
	{ "'.'",  46,  1},
	{ "MOD",  257,  1},
	{ "POW",  258,  1},
	{ "AND",  259,  1},
	{ "OR",  260,  1},
	{ "XOR",  261,  1},
	{ "NOT",  262,  1},
	{ "EQ",  263,  1},
	{ "NE",  264,  1},
	{ "LT",  265,  1},
	{ "LE",  266,  1},
	{ "GT",  267,  1},
	{ "GE",  268,  1},
	{ "BECOMES",  269,  1},
	{ "DOTDOT",  270,  1},
	{ "IF",  271,  1},
	{ "THEN",  272,  1},
	{ "ELSIF",  273,  1},
	{ "ELSE",  274,  1},
	{ "END_IF",  275,  1},
	{ "CASE",  276,  1},
	{ "OF",  277,  1},
	{ "END_CASE",  278,  1},
	{ "RETURN",  279,  1},
	{ "WHILE",  280,  1},
	{ "DO",  281,  1},
	{ "END_WHILE",  282,  1},
	{ "REPEAT",  283,  1},
	{ "UNTIL",  284,  1},
	{ "END_REPEAT",  285,  1},
	{ "FOR",  286,  1},
	{ "TO",  287,  1},
	{ "BY",  288,  1},
	{ "END_FOR",  289,  1},
	{ "EXIT",  290,  1},
	{ "ON",  291,  1},
	{ "TYPE",  292,  1},
	{ "END_TYPE",  293,  1},
	{ "STRUCT",  294,  1},
	{ "END_STRUCT",  295,  1},
	{ "PROGRAM",  296,  1},
	{ "END_PROGRAM",  297,  1},
	{ "FUNCTION",  298,  1},
	{ "END_FUNCTION",  299,  1},
	{ "FUNCTION_BLOCK",  300,  1},
	{ "END_FUNCTION_BLOCK",  301,  1},
	{ "AT",  302,  1},
	{ "RIGHT_ARROW",  303,  1},
	{ "CONFIGURATION",  304,  1},
	{ "END_CONFIGURATION",  305,  1},
	{ "RESOURCE",  306,  1},
	{ "END_RESOURCE",  307,  1},
	{ "TASK",  308,  1},
	{ "F_EDGE",  309,  1},
	{ "R_EDGE",  310,  1},
	{ "WITH",  311,  1},
	{ "VAR_ACCESS",  312,  1},
	{ "READ_ONLY",  313,  1},
	{ "READ_WRITE",  314,  1},
	{ "PERIOD",  315,  1},
	{ "ARRAY",  316,  1},
	{ "VAR",  317,  1},
	{ "VAR_INPUT",  318,  1},
	{ "VAR_OUTPUT",  319,  1},
	{ "VAR_IN_OUT",  320,  1},
	{ "VAR_EXTERNAL",  321,  1},
	{ "VAR_GLOBAL",  322,  1},
	{ "VAR_TEMP",  323,  1},
	{ "VAR_IN_EXT",  324,  1},
	{ "VAR_CONFIG",  325,  1},
	{ "END_VAR",  326,  1},
	{ "RETAIN",  327,  1},
	{ "NON_RETAIN",  328,  1},
	{ "CONSTANT",  329,  1},
	{ "STEP",  330,  1},
	{ "END_STEP",  331,  1},
	{ "INITIAL_STEP",  332,  1},
	{ "TRANSITION",  333,  1},
	{ "END_TRANSITION",  334,  1},
	{ "ACTION",  335,  1},
	{ "END_ACTION",  336,  1},
	{ "FROM",  337,  1},
	{ "SYS_COMMENT_BEGIN",  338,  1},
	{ "SYS_COMMENT_END",  339,  1},
	{ "GOTO",  340,  1},
	{ "SYNCHRONIZED",  341,  1},
	{ "END_SYNCHRONIZED",  342,  1},
	{ "DECL_CONST",  343,  1},
	{ "DECL_END_CONST",  344,  1},
	{ "END_NATIVE",  345,  1},
	{ "NATIVE",  346,  1},
	{ "VAR_NATIVE",  347,  1},
	{ "OVERLOAD",  348,  1},
	{ "KW_INLINE",  349,  1},
	{ "IMPORT_DIRECTIVE",  350,  1},
	{ "WSTRING_BEG",  351,  1},
	{ "STRING_BEG",  352,  1},
	{ "IDENTIFIER",  353,  2},
	{ "DIRECT_VARIABLE",  354,  3},
	{ "SIMPLE_LITERAL",  355,  4},
	{ "BASIC_TYP",  356,  5},
	{ "QVT_TYP",  357,  5},
	{ "GVLCST_START",  358,  0},
	{ "HDRFILE_START",  359,  0},
	{ "EXPR_START",  360,  0},
	{ "STACTION_START",  361,  0},
	{ "BODY_START",  362,  0},
	{ "IL_BODY_START",  363,  0},
	{ "IL_OP_LD",  364,  6},
	{ "IL_OP_LDN",  365,  6},
	{ "IL_OP_ST",  366,  6},
	{ "IL_OP_STN",  367,  6},
	{ "IL_OP_NOT",  368,  6},
	{ "IL_OP_RPAR",  369,  6},
	{ "IL_OP_S",  370,  6},
	{ "IL_OP_R",  371,  6},
	{ "IL_OP_S1",  372,  6},
	{ "IL_OP_R1",  373,  6},
	{ "IL_OP_CLK",  374,  6},
	{ "IL_OP_CU",  375,  6},
	{ "IL_OP_CD",  376,  6},
	{ "IL_OP_PV",  377,  6},
	{ "IL_OP_IN",  378,  6},
	{ "IL_OP_PT",  379,  6},
	{ "IL_OP_AND",  380,  6},
	{ "IL_OP_OR",  381,  6},
	{ "IL_OP_XOR",  382,  6},
	{ "IL_OP_ANDN",  383,  6},
	{ "IL_OP_ORN",  384,  6},
	{ "IL_OP_XORN",  385,  6},
	{ "IL_OP_ADD",  386,  6},
	{ "IL_OP_SUB",  387,  6},
	{ "IL_OP_MUL",  388,  6},
	{ "IL_OP_DIV",  389,  6},
	{ "IL_OP_MOD",  390,  6},
	{ "IL_OP_GT",  391,  6},
	{ "IL_OP_GE",  392,  6},
	{ "IL_OP_EQ",  393,  6},
	{ "IL_OP_LT",  394,  6},
	{ "IL_OP_LE",  395,  6},
	{ "IL_OP_NE",  396,  6},
	{ "IL_OP_CAL",  397,  6},
	{ "IL_OP_CALC",  398,  6},
	{ "IL_OP_CALCN",  399,  6},
	{ "IL_OP_RET",  400,  6},
	{ "IL_OP_RETC",  401,  6},
	{ "IL_OP_RETCN",  402,  6},
	{ "IL_OP_JMP",  403,  6},
	{ "IL_OP_JMPC",  404,  6},
	{ "IL_OP_JMPCN",  405,  6},
	{ "IL_IDENTIFIER",  406,  2},
	{ "','",  44,  0},
	{ "';'",  59,  0},
	{ "'['",  91,  0},
	{ "']'",  93,  0}

};
#endif
static short yydef[] = {

	   5, 65535, 65477, 65473, 65461, 65451, 65439,    5,    5, 65433, 
	65429,    7,  441,  419,   81,  420,  421, 65419, 65389,  429, 
	65385, 65375,    3, 65371, 65363,   26,   24,  428,    6,    5, 
	  89, 65359,   80,   84, 65355, 65351, 65345, 65339, 65333, 65329, 
	65325, 65321, 65317, 65297,   48,   48,   49,   31,   17,    9, 
	 439, 65293,   78,   57, 65289,   77,   76,   75,   74,   73, 
	  72,   71,   70,   69,   68,   67,   66,   65,   64, 65279, 
	65261, 65257, 65247,   87, 65243,   83,   82, 65239,   60, 65233, 
	65227, 65217, 65211, 65207, 65203,   51,   51,   51,   51,   51, 
	  51,   51,   51,   49,   32, 65195,   29, 65189, 65033, 65009, 
	64999,   79, 64993, 64989, 64983, 64967,  423, 64963,   38, 64955, 
	64951,   50, 64939,   48,   48,   27, 64931, 64925,   86,   85, 
	64921,   61, 64917, 64913,   46, 64907, 64901,   10, 64897, 64893, 
	  53, 64885, 64877, 64863, 64859,  435,   62, 64855, 64845,   47, 
	64839, 64835, 64831, 64827, 64823,   12, 64817, 64813,   42, 64809, 
	  43,   14, 64805,   44,   43,   15,   44,  431,  432
};
static short yyex[] = {

	   0,   20,  256,   21,  257,   21,  259,   21,  260,   21, 
	 261,   21,  271,   21,  276,   21,  279,   21,  280,   21, 
	 283,   21,  286,   21,  290,   21,  297,   21,  299,   21, 
	 301,   21,  330,   22,  332,   22,  333,   22,  335,   22, 
	 340,   21,  341,   21,  346,   21,  348,   25,  349,   25, 
	 353,   21,  354,   21,   59,   21, 65535,   23,  339,  440, 
	65535,    1,    0,    4,  292,    8,  296,   40,  298,   40, 
	 300,   40, 65535,    1,    0,   19,  297,   88,  299,   88, 
	 301,   88, 65535,    1,    0,   18,  297,   55,  299,   55, 
	 301,   55,   59,   56, 65535,    1,    0,   55,   59,   56, 
	65535,    1,    0,    0, 65535,    1,  297,   55,  299,   55, 
	 301,   55,   59,   56, 65535,    1,    0,   54,  273,   54, 
	 274,   54,  275,   54,  278,   54,  282,   54,  284,   54, 
	 289,   54,  297,   54,  299,   54,  301,   54,  336,   54, 
	 342,   54,   59,   56, 65535,    1,  337,   52, 65535,    1, 
	  40,  277,   46,  108,  269,  108,   91,  108, 65535,    1, 
	  40,  277, 65535,  108,  296,   40,  298,   40,  300,   40, 
	65535,    1,   40,   33, 65535,    1,  369,   88, 65535,    1, 
	  40,  277, 65535,  108,  342,   55,   59,   56, 65535,    1, 
	 284,   55,   59,   56, 65535,    1,  289,   55,   59,   56, 
	65535,    1,   41,   81, 65535,    1,   59,   56, 65535,    1, 
	  41,   81, 65535,    1,   41,   81, 65535,    1,    0,  426, 
	 317,   35,  318,   35,  319,   35,  320,   35,  321,   35, 
	 322,   35,  323,   35,  324,   35, 65535,    1,  277,   45, 
	65535,    1,  369,   88, 65535,    1,   40,  277,   46,  108, 
	 269,  108,   91,  108, 65535,    1,  317,   35,  318,   35, 
	 319,   35,  320,   35,  321,   35,  322,   35,  323,   35, 
	 324,   35, 65535,  427,   41,   30, 65535,    1,  305,  436, 
	 306,    5,  312,  436,  325,  436, 65535,    1,   41,   81, 
	65535,    1,   40,  277, 65535,  108,  282,   55,   59,   56, 
	65535,    1,  278,   59,   59,   56, 65535,    1,  273,   55, 
	 274,   55,  275,   55,   59,   56, 65535,    1,  336,   55, 
	  59,   56, 65535,    1,  331,  422, 65535,    1,  331,  422, 
	65535,    1,   58,   39,  302,   39,  344,  424, 65535,    1, 
	  41,   34,   44,   34, 65535,    1,    0,  426,  257,  426, 
	 259,  426,  260,  426,  261,  426,  271,  426,  276,  426, 
	 279,  426,  280,  426,  283,  426,  286,  426,  290,  426, 
	 297,  426,  299,  426,  301,  426,  317,   35,  318,   35, 
	 319,   35,  320,   35,  321,   35,  322,   35,  323,   35, 
	 324,   35,  330,  426,  332,  426,  333,  426,  335,  426, 
	 340,  426,  341,  426,  346,  426,  348,  426,  349,  426, 
	 353,  426,  354,  426,  364,  426,  365,  426,  366,  426, 
	 367,  426,  368,  426,  370,  426,  371,  426,  372,  426, 
	 373,  426,  374,  426,  375,  426,  376,  426,  377,  426, 
	 378,  426,  379,  426,  380,  426,  381,  426,  382,  426, 
	 383,  426,  384,  426,  385,  426,  386,  426,  387,  426, 
	 388,  426,  389,  426,  390,  426,  391,  426,  392,  426, 
	 393,  426,  394,  426,  395,  426,  396,  426,  397,  426, 
	 398,  426,  399,  426,  400,  426,  401,  426,  402,  426, 
	 403,  426,  404,  426,  405,  426,  406,  426,   59,  426, 
	65535,    1,  296,  426,  307,  426,  308,  426,  317,   35, 
	 318,   35,  319,   35,  320,   35,  321,   35,  322,   35, 
	 323,   35,  324,   35, 65535,    1,  305,  437,  306,    5, 
	 312,  437,  325,  437, 65535,    1,  305,  430,  325,  430, 
	65535,    1,   59,   56, 65535,    1,  278,   55,   59,   56, 
	65535,    1,   40,  277,   58,  197,   46,  108,  269,  108, 
	 270,  197,   44,  197,   91,  108, 65535,    1,  275,   58, 
	65535,    1,   58,    5,  302,    5,   44,    5, 65535,    1, 
	  58,   37, 65535,    1,   58,   39,  295,  425,  302,   39, 
	 326,  425,  344,  425, 65535,    1,   58,   39,  302,   39, 
	 326,  424, 65535,    1,  296,   11,  307,   11, 65535,    1, 
	 305,  438, 65535,    1,  281,   63, 65535,    1,   59,   56, 
	65535,    1,  275,   55,   59,   56, 65535,    1,   41,   34, 
	  44,   34, 65535,    1,   59,   56, 65535,    1,  307,  434, 
	65535,    1,   58,   39,  295,  424,  302,   39, 65535,    1, 
	  58,    5,  302,    5,   44,    5, 65535,    1,  297,   28, 
	 299,   28,  301,   28,  348,   28,  349,   28,   59,   56, 
	65535,    1,   40,    5, 65535,    1,  353,   51, 65535,    1, 
	 273,   55,  274,   55,  275,   55,   59,   56, 65535,    1, 
	 269,   36,   59,   36, 65535,    1,   40,    5, 65535,    1, 
	 275,   58, 65535,    1,   59,   41, 65535,    1,   41,   13, 
	65535,    1,   58,    5,  311,    5, 65535,    1,   41,   13, 
	65535,    1,   58,   16, 65535,    1,   40,  277, 65535,  108, 
	  59,  433, 65535,    1
};
static short yyact[] = {

	65148, 65527, 65528, 65149, 65529, 65530, 65531,  363,  362,  361, 
	 360,  359,  358,  338, 64923, 65524,  353,  339, 65523,   44, 
	65158, 65157, 65020,  346,  306,  304, 64858, 64857, 64856, 64855, 
	64859, 64854, 64853, 64852, 64851, 64850, 64849, 64848, 64847, 64846, 
	64845, 64844, 64843, 64842, 64841, 64840, 64839, 64838, 64837, 64836, 
	64835, 64834, 64833, 64832, 64831, 64830, 64829, 64828, 64827, 64826, 
	64825, 64824, 64823, 64822, 64821, 64820, 64819, 65521,  406,  405, 
	 404,  403,  402,  401,  400,  399,  398,  397,  396,  395, 
	 394,  393,  392,  391,  390,  389,  388,  387,  386,  385, 
	 384,  383,  382,  381,  380,  379,  378,  377,  376,  375, 
	 374,  373,  372,  371,  370,  368,  367,  366,  365,  364, 
	65089, 64961, 64962, 64963, 64964, 65094, 65167, 65091, 65107, 65109, 
	65165, 65090, 65173, 65172, 65517, 65171, 65164, 65111, 65092, 65515, 
	65128,  354,  353,  346,  341,  340,  335,  333,  332,  330, 
	 290,  286,  283,  280,  279,  276,  271,  261,  260,  259, 
	 257,  256, 65089, 64961, 64962, 64963, 64964, 65094, 65167, 65091, 
	65107, 65109, 65165, 65090, 65164, 65111, 65092, 65515, 65128,  354, 
	 353,  346,  341,  340,  290,  286,  283,  280,  279,  276, 
	 271,  261,  260,  259,  257,  256, 65177, 65179, 65180, 64961, 
	64962, 64963, 64964, 65178, 65123, 65124, 65514, 65128, 65125, 65175, 
	 357,  355,  354,  353,  352,  351,  262,  261,  260,  259, 
	 257,   45,   43,   40, 65148,  338, 65511, 65181,  349,  348, 
	65173, 65172, 65517, 65171,  335,  333,  332,  330, 64975, 64974, 
	64973,  301,  299,  297, 65182,   46, 65507,  263, 65524,  353, 
	64922,  339, 64954, 64956, 64955,  300,  298,  296, 65506,  353, 
	64938,  353, 64931,  292, 65505,  353, 65139,  353, 65504,   40, 
	65185, 65184, 65123, 65124, 65129, 65128, 65125,  355,  354,  353, 
	 352,  351,   45,   43, 65177, 65179, 65180, 65134, 64961, 64962, 
	64963, 64964, 65178, 65123, 65124, 65501, 65128, 65125, 65175,  357, 
	 355,  354,  353,  352,  351,  262,  261,  260,  259,  257, 
	  58,   45,   43,   40, 64970, 64969, 64968,  301,  299,  297, 
	65186, 65187,   91,   46, 65113,  353, 65189,  353, 65498,  281, 
	65497,   40, 65192,  269, 65085,   59, 65194,  353, 65073,  353, 
	65196,  353, 65197,  353, 64967, 64966, 64965,  301,  299,  297, 
	65496,   58, 65495,   40, 65494,   40, 65122,   58, 65202, 65204, 
	65203, 65201, 65200, 65199, 65211, 65213, 65212, 65210, 65209, 65208, 
	65207, 65206, 65205,  268,  267,  266,  265,  264,  263,  261, 
	 260,  259,  258,  257,   47,   45,   43,   42, 65020,  346, 
	65214, 65001, 64999, 65000, 65002, 64980, 65003, 65004, 64992, 64990, 
	64991, 65005, 64993, 64994, 64995, 64996, 64997, 64998, 64989,  269, 
	 268,  267,  266,  265,  264,  263,  262,  261,  260,  259, 
	 258,  257,  123,   47,   45,   43,   42,   40, 65492, 65491, 
	65051, 65052,  357,  356,  353,  316, 64928,  353, 64926, 64927, 
	 353,  351, 64961, 64962, 64963, 64964, 64959, 64960,  353,  262, 
	 261,  260,  259,  257, 65146,   40, 65185, 65184, 65123, 65124, 
	65129, 65128, 65125, 64858, 64857, 64856, 64855, 64859, 64854, 64853, 
	64852, 64851, 64850, 64849, 64848, 64847, 64846, 64845, 64844, 64843, 
	64842, 64841, 64840, 64839, 64838, 64837, 64836, 64835, 64834, 64833, 
	64832, 64831, 64830, 64829, 64828, 64827, 64826, 64825, 64824, 64823, 
	64822, 64821, 64820, 64819, 65521,  406,  405,  404,  403,  402, 
	 401,  400,  399,  398,  397,  396,  395,  394,  393,  392, 
	 391,  390,  389,  388,  387,  386,  385,  384,  383,  382, 
	 381,  380,  379,  378,  377,  376,  375,  374,  373,  372, 
	 371,  370,  368,  367,  366,  365,  364,  355,  354,  353, 
	 352,  351,   45,   43, 65123, 65124, 65129, 65128, 65125,  355, 
	 354,  353,  352,  351, 65218,   44, 65122, 65220, 65219,  303, 
	 269,   58, 65131,  353, 65225,  269, 65202, 65204, 65203, 65201, 
	65200, 65199, 65211, 65213, 65212, 65210, 65209, 65208, 65207, 65206, 
	65205, 65227,  277,  268,  267,  266,  265,  264,  263,  261, 
	 260,  259,  258,  257,   47,   45,   43,   42, 65177, 65179, 
	65180, 64961, 64962, 64963, 64964, 65178, 65123, 65124, 65501, 65128, 
	65125, 65175,  357,  355,  354,  353,  352,  351,  262,  261, 
	 260,  259,  257,   45,   43,   40, 65086,   59, 65081,   58, 
	65070,  337, 65068,   58, 65066,   58, 65089, 64961, 64962, 64963, 
	64964, 65094, 65167, 65091, 65107, 65109, 65165, 65090, 65164, 65111, 
	65092, 65481, 65128,  354,  353,  346,  341,  340,  290,  286, 
	 283,  280,  279,  276,  271,  261,  260,  259,  257,  256, 
	65120, 65202, 65204, 65203, 65201, 65200, 65199, 65211, 65213, 65212, 
	65210, 65209, 65208, 65207, 65206, 65205,  268,  267,  266,  265, 
	 264,  263,  261,  260,  259,  258,  257,   47,   45,   43, 
	  42,   41, 64894, 65012, 65010, 65011,  350,  347,  343,  256, 
	65006,   41, 65234,   91, 65236,   91, 65237, 65050, 65049,  310, 
	 309,  287, 65238,  124, 65465,   40, 65239,   58, 65240,  291, 
	64939,  322, 64909, 65241,  353,  256, 65137,  369, 65177, 65179, 
	65180, 64961, 64962, 64963, 64964, 65178, 65123, 65124, 65461, 65128, 
	65125, 65175,  357,  355,  354,  353,  352,  351,  262,  261, 
	 260,  259,  257,   45,   43,   40, 65245, 65130,   93,   44, 
	65112,  342, 65246,  284, 65202, 65204, 65203, 65201, 65200, 65199, 
	65211, 65213, 65212, 65210, 65209, 65208, 65207, 65206, 65205, 65458, 
	 281,  268,  267,  266,  265,  264,  263,  261,  260,  259, 
	 258,  257,   47,   45,   43,   42, 65105,  289, 65250, 65249, 
	65123, 65124, 65040, 65125,  355,  353,  352,  351,   45,   43, 
	65202, 65204, 65203, 65201, 65200, 65199, 65211, 65213, 65212, 65210, 
	65209, 65208, 65207, 65206, 65205, 65455,  272,  268,  267,  266, 
	 265,  264,  263,  261,  260,  259,  258,  257,   47,   45, 
	  43,   42, 65093,   41, 65074,  337, 65127,   41, 65126,   41, 
	65199,  258, 65202, 65201, 65200, 65199,  258,  257,   47,   42, 
	65202, 65204, 65203, 65201, 65200, 65199,  258,  257,   47,   45, 
	  43,   42, 65202, 65204, 65203, 65201, 65200, 65199, 65208, 65207, 
	65206, 65205,  268,  267,  266,  265,  258,  257,   47,   45, 
	  43,   42, 65202, 65204, 65203, 65201, 65200, 65199, 65210, 65209, 
	65208, 65207, 65206, 65205,  268,  267,  266,  265,  264,  263, 
	 258,  257,   47,   45,   43,   42, 65202, 65204, 65203, 65201, 
	65200, 65199, 65211, 65210, 65209, 65208, 65207, 65206, 65205,  268, 
	 267,  266,  265,  264,  263,  259,  258,  257,   47,   45, 
	  43,   42, 65202, 65204, 65203, 65201, 65200, 65199, 65211, 65212, 
	65210, 65209, 65208, 65207, 65206, 65205,  268,  267,  266,  265, 
	 264,  263,  261,  259,  258,  257,   47,   45,   43,   42, 
	65444, 65445, 65446, 65447, 65448, 65443, 65449, 65450,  324,  323, 
	 322,  321,  320,  319,  318,  317, 65012, 65010, 65011,  350, 
	 347,  343, 65254,  277, 64946, 64945,  353,  351, 65148, 64941, 
	 350,  338, 65258,   58, 64912,   59, 64909, 64932, 65241,  353, 
	 293,  256, 65138,  369, 65122, 65262, 65261,  303,  269,   58, 
	65202, 65204, 65203, 65201, 65200, 65199, 65211, 65213, 65212, 65210, 
	65209, 65208, 65207, 65206, 65205, 65265,  287,  268,  267,  266, 
	 265,  264,  263,  261,  260,  259,  258,  257,   47,   45, 
	  43,   42, 65266,  270, 65267, 65433,   58,   44, 65250, 65249, 
	65089, 64961, 64962, 64963, 64964, 65094, 65432, 65167, 65091, 65107, 
	65109, 65165, 65090, 65164, 65111, 65092, 65123, 65124, 65431, 65128, 
	65125,  355,  354,  353,  352,  351,  346,  341,  340,  290, 
	 286,  283,  280,  279,  276,  274,  271,  261,  260,  259, 
	 257,  256,   45,   43, 65123, 65124, 65042, 65125,  355,  353, 
	 352,  351, 65123, 65124, 65041, 65125,  355,  353,  352,  351, 
	65273, 65077,  353,   40, 65275,  353, 64891, 65428,  353,  256, 
	65063, 65064, 65065,  329,  328,  327, 65202, 65204, 65203, 65201, 
	65200, 65199, 65211, 65213, 65212, 65210, 65209, 65208, 65207, 65206, 
	65205, 65281,  270,  268,  267,  266,  265,  264,  263,  261, 
	 260,  259,  258,  257,   47,   45,   43,   42, 65282, 65047, 
	  93,   44, 65422, 65051, 65052,  357,  356,  353, 65202, 65204, 
	65203, 65201, 65048, 65200, 65199, 65211, 65213, 65212, 65210, 65209, 
	65208, 65207, 65206, 65205,  268,  267,  266,  265,  264,  263, 
	 261,  260,  259,  258,  257,   93,   47,   45,   43,   42, 
	65050, 65049,  310,  309, 65238, 65283,  287,  124, 65284,   44, 
	65420,   41, 65157,  306, 65148, 64942,  350,  338, 64952,  312, 
	64936, 64933, 64935, 64934, 65051, 65052,  357,  356,  353,  316, 
	 294,   40, 64911,   59, 65147,   41, 65202, 65204, 65203, 65201, 
	65200, 65199, 65211, 65213, 65212, 65210, 65209, 65208, 65207, 65206, 
	65205, 65110,  285,  268,  267,  266,  265,  264,  263,  261, 
	 260,  259,  258,  257,   47,   45,   43,   42, 65108,  282, 
	65101,   59, 65267, 65413,   58,   44, 65098,  278, 65287, 65412, 
	 274,  273, 65082,  336, 65290,  353, 65071,  287, 65291,   40, 
	64884,   59, 65069,  331, 65067,  331, 65293,   44, 65294,  302, 
	64893,   59, 65013,  344, 65051, 65052,  357,  356, 64983, 65492, 
	65491, 65051, 65052,  357,  356,  353,  316,  315, 65298,  349, 
	65299,  308, 64940,  325, 65301,   40, 65202, 65204, 65203, 65201, 
	65200, 65199, 65211, 65213, 65212, 65210, 65209, 65208, 65207, 65206, 
	65205, 65302,  288,  268,  267,  266,  265,  264,  263,  261, 
	 260,  259,  258,  257,   47,   45,   43,   42, 65303,  270, 
	65099,   59, 65095,  275, 65075,  287, 65306,   44, 65405,  353, 
	64883,   59, 65404,  353, 65017, 65016,  354,  353, 65309,   58, 
	64892,   59, 65202, 65204, 65203, 65201, 65200, 65199, 65211, 65213, 
	65212, 65210, 65209, 65208, 65207, 65206, 65205, 65311,  270,  268, 
	 267,  266,  265,  264,  263,  261,  260,  259,  258,  257, 
	  47,   45,   43,   42, 64982,  123, 65402,  353, 65312,  308, 
	65401,  296, 64908,  305, 65100,   59, 65202, 65204, 65203, 65201, 
	65200, 65199, 65211, 65213, 65212, 65210, 65209, 65208, 65207, 65206, 
	65205, 65398,  272,  268,  267,  266,  265,  264,  263,  261, 
	 260,  259,  258,  257,   47,   45,   43,   42, 65079,  353, 
	65320,   44, 65083,   41, 65009,  326, 65395,  353, 64905,   59, 
	64944,  307, 65324,  270, 64910,  295, 65078, 65326,   44,   41, 
	65327,  269, 65123, 65124, 65125,  355,  352,  351, 65015,  329, 
	65392,   40, 65391,  353, 64904,   59, 65330,  269, 65080,  353, 
	65332,  269, 65333,  353, 65389,   40, 64937,   41, 65202, 65204, 
	65203, 65201, 65336, 65200, 65199, 65211, 65213, 65212, 65210, 65209, 
	65208, 65207, 65206, 65205,  268,  267,  266,  265,  264,  263, 
	 261,  260,  259,  258,  257,   59,   47,   45,   43,   42, 
	65337, 65179, 65180, 65338, 64961, 64962, 64963, 64964, 65178, 65123, 
	65124, 65514, 65128, 65125, 65175,  357,  355,  354,  353,  352, 
	 351,  262,  261,  260,  259,  257,   91,   45,   43,   40, 
	65339,  269, 65340,   44, 65341,   41, 65343,  311, 65202, 65204, 
	65203, 65201, 65345, 65200, 65199, 65211, 65213, 65212, 65210, 65209, 
	65208, 65207, 65206, 65205,  268,  267,  266,  265,  264,  263, 
	 261,  260,  259,  258,  257,   59,   47,   45,   43,   42, 
	65072,  334, 65177, 65179, 65180, 64961, 64962, 64963, 64964, 65178, 
	65123, 65124, 65386, 65128, 65125, 65175,  357,  355,  354,  353, 
	 352,  351,  262,  261,  260,  259,  257,   45,   43,   40, 
	65347, 65250, 65249, 65123, 65124, 65040, 65125,  355,  353,  352, 
	 351,   45,   43,   40, 65349,  353, 64947,   59, 65350,   41, 
	64950,  353, 65351,   58, 65076,  334, 65023, 65352,   44,   41, 
	65122, 65353,  269,   58, 65356,   40, 65357, 65022,   93,   44, 
	65358,  269, 64948,   59, 65383,  353, 65359,  353, 65382, 65202, 
	65204, 65203, 65201, 65200, 65199, 65211, 65213, 65212, 65210, 65209, 
	65208, 65207, 65206, 65205,  268,  267,  266,  265,  264,  263, 
	 261,  260,  259,  258,  257,   47,   45,   43,   42,   41, 
	65036, 65352,   44,   41, 65347, 65028, 65250, 65249, 65123, 65124, 
	65040, 65125,  355,  353,  352,  351,   45,   43,   41,   40, 
	65361, 65250, 65249, 65123, 65124, 65040, 65125,  355,  353,  352, 
	 351,   45,   43,   40, 65362,   40, 65363,  269, 65364,   40, 
	65027, 65357,   44,   41, 65366,   40, 65367,  353, 65347, 65030, 
	65250, 65249, 65123, 65124, 65040, 65125,  355,  353,  352,  351, 
	  45,   43,   41,   40, 65379, 65202, 65204, 65203, 65201, 65200, 
	65199, 65211, 65213, 65212, 65210, 65209, 65208, 65207, 65206, 65205, 
	 268,  267,  266,  265,  264,  263,  261,  260,  259,  258, 
	 257,   47,   45,   43,   42,   41, 65347, 65033, 65250, 65249, 
	65123, 65124, 65040, 65125,  355,  353,  352,  351,   45,   43, 
	  41,   40, 65372, 65371, 65373,  311,  303,  269, 64951, 65374, 
	  44,   41, 65029, 65357,   44,   41, 65375,   40, 65032, 65357, 
	  44,   41, 64901,  353, 65347, 65035, 65250, 65249, 65123, 65124, 
	65040, 65125,  355,  353,  352,  351,   45,   43,   41,   40, 
	65034, 65357,   44,   41,   -1
};
static short yypact[] = {

	   7,   14,   19,   23,   68,  131,  169,  215,  215,  216, 
	 169,  235,  239,  259,  289,   68,  312,  169,  329,  224, 
	 341,  347,  363,  379,  422,  218,   68,  224,  430,  215, 
	 445,  495,  555,  363,  559,  169,  169,  169,  612,  653, 
	 612,  612,  706,  713,  715,  715,  719,  723,  727,  729, 
	 731,   68,  363,  363,  856,  861,  861,  861,  866,  866, 
	 876,  876,  876,  876,  892,  892,  914,  939,  966,  999, 
	 422, 1010,  612,  363, 1027,  363,  363,  169, 1063, 1091, 
	 169,  169, 1135, 1135, 1138, 1143, 1143, 1143, 1143, 1143, 
	1143, 1143, 1143, 1222,  723, 1226, 1229,  706,  706, 1236, 
	1239,  363,  653,  169, 1298, 1300, 1135,  215, 1317, 1319, 
	1138, 1143, 1138,  715,  715, 1339, 1341, 1343,  363,  363, 
	1362, 1379,  653,  169,  363, 1226,  169, 1439, 1441, 1138, 
	1481,  215,  169,  215, 1143, 1441,  363,  169, 1509,  363, 
	 215, 1300, 1521, 1523,  215, 1593, 1523, 1597,  363, 1692, 
	1695,  363, 1775, 1779, 1785,  363, 1867,  363,  363, 1892, 
	1882, 1787, 1873,  200,  200, 1870, 1864, 1860, 1855, 1844, 
	1820, 1796, 1575, 1787, 1646, 1782, 1777,  200, 1767, 1752, 
	1742, 1724, 1575, 1707, 1705, 1703, 1701, 1698, 1646, 1688, 
	1685, 1683, 1681, 1679, 1677, 1675,  200, 1667, 1646, 1631, 
	1614, 1595, 1591, 1575, 1544,  200, 1527, 1525,  200, 1519, 
	1517,  814, 1515, 1513, 1511, 1505, 1501, 1498, 1132, 1495, 
	1493, 1491, 1489, 1487,  200, 1485,  422, 1483, 1132, 1479, 
	1462, 1445,  814,  200,  814, 1443, 1437, 1435, 1418, 1401, 
	1399, 1396, 1393, 1391, 1389, 1387, 1385, 1383,  200, 1381, 
	1345, 1333, 1326,  200,  200, 1323, 1321, 1315, 1313, 1311, 
	1309, 1307, 1305, 1132, 1303, 1297, 1294, 1291,  814,  814, 
	 200, 1289, 1272,  200,  200, 1255, 1253, 1246, 1233, 1231, 
	1204, 1185, 1180, 1162, 1132, 1126, 1118, 1066, 1046,  200, 
	 200, 1023, 1019, 1015, 1013, 1006,  422,  422,  422,  200, 
	1003,  200,  988,  859,  857,  855,  853,  836,  814,  807, 
	 200,  790,  773,  771,  768,  200,  200,  752,  737,  734, 
	 725,  711,  200,  200,  200,  200,  200,  200,  200,  200, 
	 200,  200,  200,  200,  200,  200,  200,  686,  635,  633, 
	 631,  629,  627,  200,  200,  582,  565,  200,  200,  563, 
	 549,  549,  438,  427,  399,  200,  200,  200,  200,  345, 
	 343,  337,  333,  331,  327,  325,  323,  321,  200,  319, 
	 317,  315,  307,  267,  257,  255,  253,  251,  249,  245, 
	 241,  237,  231,  224,   68,  218,  200,   16
};
static short yygo[] = {

	65377, 65378, 65387, 65365, 65380, 65387, 65354, 65384, 65198, 65387, 
	65335, 65331, 65396, 65399, 65305, 65297, 65411, 65415, 65416, 65417, 
	65263, 65434, 65255, 65252, 65247, 65459, 65460, 65462, 65467, 65468, 
	65469, 65470, 65471, 65472, 65473, 65474, 65475, 65476, 65477, 65478, 
	65479, 65480, 65114, 65482, 65228, 65224, 65483, 65115, 65116, 65117, 
	65198, 65190, 65513, 65502,  386,  368,  358,  357,  356,  355, 
	 348,  347,  344,  343,  336,  335,  334,  333,  332,  331, 
	 330,  329,  328,  327,  326,  325,  324,  323,  322,  317, 
	 316,  315,  310,  301,  299,  290,  289,  274,  273,  270, 
	 254,  253,  248,  233,  224,  208,  205,  203,  198,  196, 
	 188,  182,  177,  174,  172,  164,  163, 64869, 65457, 65381, 
	65329, 65104, 65315, 65414, 65103, 65457, 65385,  308,  269,  268, 
	 234,  232,  211,  178,   79, 65169, 65169, 65169, 65169, 65143, 
	65169, 65169, 65169, 65169, 65169, 65169, 65169, 65169, 65169, 65169, 
	65169, 65169, 65169, 65169, 65169, 65144, 65145, 65143, 65119,  373, 
	 351,  350,  137,  132,  126,  123,  122,  103,  102,   81, 
	  80,   79,   77,   39,   37,   36,   35,   31,   17,   10, 
	   6,    5, 64868, 65519, 64867, 64866, 64865, 65043, 65046, 65045, 
	65044,  114,  113,   45, 65014, 65025, 65024, 65021,  182,  172, 
	65031, 65026,  178, 65106, 65229, 65231, 65232, 65260, 65136,   72, 
	  41,   40,   38, 65503, 65121, 65376, 65370, 65369, 65360, 65348, 
	 179,  171,  169,  160, 65346, 65355,  198, 65235, 65253, 65221, 
	65421, 65490,  281, 65489, 64986, 65285, 65442,  277,  252,   24, 
	65397, 64957, 64988, 64987,  297,  296,  226, 64953, 65215, 64985, 
	64984,  125, 65439, 65256, 65427, 65426, 64925, 64924,   12, 65533, 
	65532, 65512, 64929, 65486, 65018, 65019, 65321, 65328, 65388, 65257, 
	 144,  140,  133,  131,  107,   29,    8,    7,    0, 65168, 
	65168, 65168, 65168, 65168, 65168, 65168, 65168, 65168, 65168, 65168, 
	65168, 65168, 65168, 65168, 65168, 65168, 65168, 65168, 64958, 65176, 
	 352,  137,  132,  126,  123,  122,  103,  102,   81,   80, 
	  79,   77,   39,   37,   36,   35,   17,   10,    6,    5, 
	65344, 65487, 64943, 64978, 64981, 65062, 65061,  111, 65424, 65059, 
	65058, 65057, 65056, 65055, 65054, 65053, 65322, 65060,  134,   92, 
	  91,   90,   89,   88,   87,   86, 65295, 65183, 65156, 65154, 
	65140, 65037, 65037, 65037, 65037, 65037, 65037, 65037, 65037, 65084, 
	65037, 65037, 65037, 65037, 65038, 65039, 65037, 65141, 65142, 65140, 
	65118,  373,  351,  350,  308,  286,  285,  269,  268,  234, 
	 232,  215,  211,  197,  179,  178,  171,  169,  160,   79, 
	  31, 65390, 65342, 65334,  146, 65408, 65407, 65403, 65518,  126, 
	65193, 65193, 65170,  132,   17, 64921, 64976, 65222, 65223, 65226, 
	65264, 65430, 65271, 65102, 65097, 65394, 64971,  137,  123,  103, 
	  81,   80,   77,   37,   36,   35,   10,    6, 65087, 65268, 
	65286, 65304, 65088,  122,  102,   79,   39, 64882, 64881, 65096, 
	65288,  141, 65270, 65456, 65269, 65248,   79, 64880, 64879, 64878, 
	64877, 65166, 64876, 64875, 64874, 64873, 64872, 64871, 64870, 65393, 
	65217, 65244, 64972,   51,   31, 65509, 65520,  384, 65133, 65133, 
	65132,   26,   15, 64864, 64863, 64862, 64861, 65162, 65522, 65160, 
	65161, 64860, 65484, 65135,   31, 65526, 64919, 64918, 64917, 64907, 
	64906, 64916,   99,   71, 64915, 64920, 65534,    7, 64914, 64913, 
	65155, 65493, 64899, 65419, 64930,   98,   97, 65159, 65216, 65243, 
	65259, 65242,  292, 65406, 65008, 65316, 65280,  129,  112, 65485, 
	65464, 65435, 65418, 65300, 65436, 65437, 65314, 65400, 65323, 65313, 
	 135, 64949, 65368, 64902, 64903,  161, 64900, 65438, 65174, 65163, 
	65508, 65516,  383, 65153, 65525, 65152, 64977, 65151, 65150, 65510, 
	64897, 64898,   25, 64979, 65409, 65440, 65410, 65441, 65488,  298, 
	 251,   70, 65466, 64895, 64896,   69, 65233, 65007, 65423, 65310, 
	65451, 65425, 65296, 65279,  110, 64889, 64889, 64890,   27,   19, 
	64888, 64887, 64886, 64885, 65452, 65278, 65277,   83, 65453, 65195, 
	65251, 65325, 65319, 65289, 65274,  263,  228,  218, 65307, 65230, 
	65272, 65317, 65318, 65454, 65429, 65292, 65276,  106, 65308, 65191, 
	65188, 65499, 65500, 65463,   -1
};
static short yypgo[] = {

	   0,    0,    0,  475,  475,  259,  247,  339,  497,  312, 
	 386,  386,  383,  383,  381,  381,  310,  237,  488,  489, 
	 526,  534,  535,  537,  533,  538,  536,  544,  313,  243, 
	 243,  238,  238,  238,  240,  556,  449,  336,  245,  245, 
	 338,  184,  187,  191,  191,  217,  218,  218,  180,  221, 
	 327,  327,  579,  598,  406,  406,  427,  428,  430,  432, 
	 435,  435,  193,  193,   53,   53,   53,   53,   53,   53, 
	  53,   53,   53,   53,   53,   53,   53,   53,  219,  219, 
	 198,  198,  203,  203,  203,  203,  203,  203,  452,  466, 
	 466,  603,  473,  473,  473,  473,  473,  473,  465,  464, 
	 464,  463,  463,  460,  456,  456,  176,  175,  172,  148, 
	 204,  204,  360,  360,  360,  107,  107,  107,  107,  107, 
	  53,   53,   53,   53,  448,  447,  602,  443,  601,  442, 
	 600,  441,  440,  435,  435,  432,  433,  433,  433,  439, 
	 430,  430,  438,  599,  437,  446,  445,  444,  422,  392, 
	 392,  388,  388,  598,  596,  573,  593,  592,  592,  584, 
	 584,  572,  591,  590,  589,  572,  588,  580,  570,  578, 
	 571,  574,  316,  316,  316,  318,  318,  557,  557,  557, 
	 557,  557,  557,  557,  557,  226,  226,  221,  221,  180, 
	 217,  233,  233,  233,  233,  116,  116,  116,  116,  116, 
	 116,  191,  209,  209,  209,  209,  209,  209,  209,  209, 
	 209,  209,  215,  215,  187,  187,  184,  338,  244,  244, 
	 336,  336,  449,  563,  554,  560,  554,  554,  554,  559, 
	 558,  314,  314,  314,  314,  314,  314,  314,  314,  314, 
	 314,  314,  314,  314,  314,  314,  314,  314,  314,  548, 
	 548,  240,  242,  242,  243,  313,  541,  541,  541,  543, 
	 533,  533,  526,  526,  526,  529,  528,  489,  489,  489, 
	 488,  488,  488,  289,  289,  289,  289,  289,  311,  311, 
	 237,  337,  337,  337,  527,  512,  521,  310,  519,  385, 
	 385,  312,  312,  481,  515,  514,  514,  513,  510,  509, 
	 501,  501,  501,  501,  503,  477,  498,  484,  491,  339, 
	 247,  247,  249,  249,  259,  259,  475,  475,  475,  475, 
	 475,  475,  475,  475,  475,  499,  499,  501,  501,  478, 
	 514,  514,  517,  517,  522,  522,  524,  476,  486,  539, 
	 539,  552,  552,  552,  561,  561,  563,  531,  531,  567, 
	 567,  567,  567,  594,  594,  422,  422,  422,  422,  422, 
	 422,  422,  422,  422,  422,  422,  422,  422,   53,  173, 
	 173,  174,  174,  460,  460,  460,  460,  460,  463,  467, 
	 467,  467,  467,  467,  467,  467,  467,  467,  467,  467, 
	 467,  467,  467,  468,  468,  468,  468,  468,  468,  468, 
	 468,  468,  468,  468,  468,  468,  468,  468,  468,  468, 
	 469,  469,  469,  471,  471,  471,  470,  470,  470,  467, 
	 452,  148,  576,  576,  506,  506,  494,  494,  533,  528, 
	 512,  524,  524,  521,  516,  516,  511,  511,  513,  510, 
	 490,  490,    0
};
static short yyrlen[] = {

	   0,    0,    0,    2,    1,    0,    2,    1,    0,    0, 
	   1,    0,    1,    0,    3,    5,    0,    0,    0,    0, 
	   0,    0,    0,    0,    2,    0,    2,    0,    2,    1, 
	   0,    1,    3,    0,    0,    0,    0,    0,    1,    0, 
	   0,    0,    1,    1,    3,    0,    3,    5,    0,    1, 
	   1,    0,    0,    1,    1,    0,    0,    3,    0,    0, 
	   1,    3,    2,    0,    3,    3,    3,    3,    3,    3, 
	   3,    3,    3,    3,    3,    3,    3,    3,    1,    3, 
	   1,    0,    3,    3,    1,    5,    5,    3,    0,    2, 
	   6,    0,    2,    2,    1,    2,    2,    1,    2,    5, 
	   4,    2,    2,    2,    2,    1,    3,    4,    1,    1, 
	   4,    4,    1,    1,    1,    2,    1,    3,    1,    1, 
	   2,    2,    2,    3,    2,    4,    0,    6,    0,    6, 
	   0,    7,    4,    5,    3,    2,    3,    5,    4,    6, 
	   2,    5,    7,    0,    4,    1,    1,    1,    1,    1, 
	   3,    3,    2,    3,    4,    6,    0,    3,    1,    5, 
	   1,   13,    0,    0,    0,   12,    0,    0,    6,    0, 
	   6,    0,    1,    1,    1,    2,    1,    2,    2,    2, 
	   2,    2,    2,    2,    2,    1,    1,    2,    2,    3, 
	   3,    5,    5,    2,    2,    2,    2,    1,    2,    2, 
	   1,    3,    7,    8,    5,    6,    3,    5,    6,    3, 
	   4,    1,    5,    3,    3,    3,    2,    1,    4,    2, 
	   2,    2,    1,    6,    4,    0,    1,    1,    6,    0, 
	   0,    2,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    3, 
	   1,    2,    4,    2,    3,    2,    2,    2,    7,    0, 
	   1,    2,    2,    2,    2,    1,    1,    2,    2,    2, 
	   2,    2,    2,    1,    1,    1,    1,    1,    1,    1, 
	   2,    1,    1,    1,    0,    1,    3,    2,    8,    8, 
	   7,    2,    2,   10,    0,    2,    1,    1,    1,    0, 
	   8,    3,    3,    3,    0,    6,    0,    3,    0,    3, 
	   3,    3,    3,    2,    2,    3,    2,    2,    1,    1, 
	   1,    1,    2,    2,    2,    2,    3,    6,    1,    9, 
	   1,    2,    2,    3,    1,    3,    3,    2,    7,    1, 
	   2,    1,    2,    1,    2,    3,    1,    1,    2,    1, 
	   1,    1,    1,    2,    3,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    0,    1,    0,    1,    0,    1,    2,    1, 
	   0,    3,    3,    0,    0,    1,    0,    1,    0,    0, 
	   0,    1,    2
};
#define YYS0	0
#define YYDELTA	298
#define YYNPACT	388
#define YYNDEF	159

#define YYr440	0
#define YYr441	1
#define YYr442	2
#define YYr7	3
#define YYr11	4
#define YYr14	5
#define YYr21	6
#define YYr22	7
#define YYr26	8
#define YYr54	9
#define YYr55	10
#define YYr56	11
#define YYr59	12
#define YYr60	13
#define YYr61	14
#define YYr62	15
#define YYr69	16
#define YYr86	17
#define YYr97	18
#define YYr101	19
#define YYr108	20
#define YYr109	21
#define YYr111	22
#define YYr114	23
#define YYr115	24
#define YYr116	25
#define YYr117	26
#define YYr125	27
#define YYr126	28
#define YYr127	29
#define YYr129	30
#define YYr132	31
#define YYr133	32
#define YYr134	33
#define YYr136	34
#define YYr162	35
#define YYr177	36
#define YYr180	37
#define YYr181	38
#define YYr182	39
#define YYr186	40
#define YYr188	41
#define YYr189	42
#define YYr204	43
#define YYr205	44
#define YYr218	45
#define YYr219	46
#define YYr220	47
#define YYr222	48
#define YYr223	49
#define YYr236	50
#define YYr237	51
#define YYr253	52
#define YYr272	53
#define YYr274	54
#define YYr275	55
#define YYr294	56
#define YYr295	57
#define YYr304	58
#define YYr310	59
#define YYr311	60
#define YYr313	61
#define YYr317	62
#define YYr318	63
#define YYr326	64
#define YYr327	65
#define YYr328	66
#define YYr329	67
#define YYr330	68
#define YYr331	69
#define YYr332	70
#define YYr333	71
#define YYr334	72
#define YYr335	73
#define YYr336	74
#define YYr337	75
#define YYr338	76
#define YYr339	77
#define YYr353	78
#define YYr354	79
#define YYr357	80
#define YYr358	81
#define YYr359	82
#define YYr360	83
#define YYr361	84
#define YYr362	85
#define YYr363	86
#define YYr364	87
#define YYr375	88
#define YYr396	89
#define YYr398	90
#define YYr397	91
#define YYr395	92
#define YYr394	93
#define YYr393	94
#define YYr392	95
#define YYr391	96
#define YYr390	97
#define YYr389	98
#define YYr388	99
#define YYr387	100
#define YYr386	101
#define YYr384	102
#define YYr383	103
#define YYr377	104
#define YYr376	105
#define YYr373	106
#define YYr372	107
#define YYr369	108
#define YYr365	109
#define YYr356	110
#define YYr355	111
#define YYr352	112
#define YYr351	113
#define YYr350	114
#define YYr349	115
#define YYr348	116
#define YYr347	117
#define YYr346	118
#define YYr345	119
#define YYr343	120
#define YYr342	121
#define YYr341	122
#define YYr340	123
#define YYr325	124
#define YYr324	125
#define YYr323	126
#define YYr322	127
#define YYr321	128
#define YYr320	129
#define YYr319	130
#define YYr316	131
#define YYr315	132
#define YYr314	133
#define YYr312	134
#define YYr309	135
#define YYr308	136
#define YYr307	137
#define YYr306	138
#define YYr305	139
#define YYr303	140
#define YYr302	141
#define YYr301	142
#define YYr300	143
#define YYr299	144
#define YYr298	145
#define YYr297	146
#define YYr296	147
#define YYr293	148
#define YYr279	149
#define YYr278	150
#define YYr277	151
#define YYr276	152
#define YYr273	153
#define YYr271	154
#define YYr266	155
#define YYr265	156
#define YYr264	157
#define YYr263	158
#define YYr262	159
#define YYr261	160
#define YYr260	161
#define YYr259	162
#define YYr258	163
#define YYr257	164
#define YYr256	165
#define YYr255	166
#define YYr254	167
#define YYr252	168
#define YYr251	169
#define YYr250	170
#define YYr249	171
#define YYr242	172
#define YYr241	173
#define YYr240	174
#define YYr239	175
#define YYr238	176
#define YYr235	177
#define YYr234	178
#define YYr233	179
#define YYr232	180
#define YYr231	181
#define YYr230	182
#define YYr229	183
#define YYr228	184
#define YYr227	185
#define YYr226	186
#define YYr225	187
#define YYr224	188
#define YYr221	189
#define YYr217	190
#define YYr216	191
#define YYr215	192
#define YYr214	193
#define YYr213	194
#define YYr212	195
#define YYr211	196
#define YYr210	197
#define YYr209	198
#define YYr208	199
#define YYr207	200
#define YYr206	201
#define YYr203	202
#define YYr202	203
#define YYr201	204
#define YYr200	205
#define YYr199	206
#define YYr198	207
#define YYr197	208
#define YYr196	209
#define YYr195	210
#define YYr194	211
#define YYr193	212
#define YYr192	213
#define YYr191	214
#define YYr190	215
#define YYr187	216
#define YYr185	217
#define YYr184	218
#define YYr183	219
#define YYr179	220
#define YYr178	221
#define YYr176	222
#define YYr174	223
#define YYr169	224
#define YYr168	225
#define YYr167	226
#define YYr166	227
#define YYr165	228
#define YYr164	229
#define YYr163	230
#define YYr156	231
#define YYr155	232
#define YYr154	233
#define YYr153	234
#define YYr152	235
#define YYr151	236
#define YYr150	237
#define YYr149	238
#define YYr148	239
#define YYr147	240
#define YYr146	241
#define YYr145	242
#define YYr144	243
#define YYr143	244
#define YYr142	245
#define YYr141	246
#define YYr140	247
#define YYr139	248
#define YYr138	249
#define YYr137	250
#define YYr135	251
#define YYr131	252
#define YYr130	253
#define YYr128	254
#define YYr124	255
#define YYr123	256
#define YYr122	257
#define YYr121	258
#define YYr120	259
#define YYr113	260
#define YYr110	261
#define YYr107	262
#define YYr106	263
#define YYr105	264
#define YYr104	265
#define YYr102	266
#define YYr100	267
#define YYr99	268
#define YYr98	269
#define YYr96	270
#define YYr95	271
#define YYr94	272
#define YYr93	273
#define YYr92	274
#define YYr91	275
#define YYr90	276
#define YYr89	277
#define YYr88	278
#define YYr87	279
#define YYr85	280
#define YYr84	281
#define YYr83	282
#define YYr82	283
#define YYr80	284
#define YYr77	285
#define YYr70	286
#define YYr68	287
#define YYr67	288
#define YYr58	289
#define YYr57	290
#define YYr53	291
#define YYr52	292
#define YYr51	293
#define YYr50	294
#define YYr49	295
#define YYr47	296
#define YYr42	297
#define YYr40	298
#define YYr38	299
#define YYr36	300
#define YYr35	301
#define YYr34	302
#define YYr33	303
#define YYr31	304
#define YYr28	305
#define YYr27	306
#define YYr25	307
#define YYr24	308
#define YYr23	309
#define YYr20	310
#define YYr19	311
#define YYr18	312
#define YYr17	313
#define YYr13	314
#define YYr12	315
#define YYr8	316
#define YYr6	317
#define YYrACCEPT	YYr440
#define YYrERROR	YYr441
#define YYrLR2	YYr442
#if YYDEBUG
char * yysvar[] = {
	"$accept",
	"expression",
	"primary_expression",
	"signed_lit_or_const",
	"variable",
	"variable_name",
	"symbolic_variable",
	"multi_element_variable",
	"array_variable",
	"structured_variable",
	"opt_strlen",
	"opt_init",
	"initializer",
	"init_simple",
	"opt_BY",
	"opt_any_param_list",
	"any_param_list",
	"any_call",
	"array_initial_elements",
	"structInit",
	"opt_array_dim_list",
	"array_dim_list",
	"expression_list",
	"basic_type_edge",
	"basic_type_kw",
	"data_type",
	"opt_ret_type",
	"opt_ovRetType",
	"opt_cast",
	"typeList",
	"opt_TypeList",
	"decl_idlist",
	"opt_decl_idlist",
	"AttribAssignment",
	"AttribList",
	"opt_sysComment",
	"fun_name",
	"opt_task_name",
	"pouname",
	"opt_ResType",
	"overload_body",
	"stop_token",
	"decl_modifier",
	"decl_modifiers",
	"opt_decl_modifiers",
	"opt_addr",
	"poutyp_kw",
	"opt_NATIVE",
	"IDDotList",
	"LITERAL",
	"task_initialisation_list",
	"opt_task_initialisation_list",
	"task_configuration_list",
	"opt_task_configuration_list",
	"statement_list",
	"labeled_statement",
	"opt_statement_list",
	"statement",
	"empty_statement",
	"assignment_statement",
	"elsif_statement_list",
	"opt_else_statement_list",
	"case_element_list",
	"case_list",
	"fb_invocation",
	"if_statement",
	"case_statement",
	"for_statement",
	"for_assignmet",
	"while_statement",
	"repeat_statement",
	"exit_statement",
	"return_statement",
	"native_statement",
	"synchronized_statement",
	"goto_statement",
	"opt_CONSTANT",
	"opt_instruction_list",
	"instruction_list",
	"il_instruction",
	"il_simple_operation",
	"il_expression",
	"il_jump_operation",
	"il_fb_call",
	"il_simple_operator",
	"il_expr_operator",
	"il_call_operator",
	"il_jump_operator",
	"il_return_operator",
	"il_operand",
	"file",
	"POU_Decl",
	"data_type_declaration",
	"configuration_declaration",
	"resource_declaration",
	"gvlcst_file",
	"POUheader",
	"opt_pou_body2",
	"il_opt_pou_body2",
	"opt_comma",
	"$24",
	"opt_decl_sections",
	"$26",
	"$27",
	"type_declaration_list",
	"type_declaration",
	"$31",
	"opt_decl_list",
	"$38",
	"opt_conf_decl_sections",
	"opt_resource_declaration_list",
	"opt_access_declaration",
	"opt_instance_specific_init",
	"resource_declaration_list",
	"$50",
	"opt_program_configuration_list",
	"program_configuration_list",
	"program_configuration",
	"opt_conf_elements",
	"conf_elements",
	"conf_element",
	"opt_pou_body",
	"$80",
	"pou_body2",
	"il_pou_body2",
	"sfc_element_list",
	"pou_body",
	"$109",
	"$111",
	"overloads",
	"$114",
	"$116",
	"overloadlist",
	"overload",
	"$120",
	"$125",
	"data_type_or",
	"decl_sections",
	"decl_section",
	"$162",
	"decl_scope",
	"$163",
	"$164",
	"$168",
	"decl_list",
	"decl",
	"sfc_element",
	"initial_step",
	"step",
	"transition",
	"action",
	"$249",
	"opt_action_association_list",
	"$251",
	"$253",
	"$254",
	"steps",
	"$255",
	"$257",
	"$258",
	"$259",
	"step_name_list",
	"$265",
	"action_association_list",
	"action_association",
	"action_qualifier_list",
	"$300",
	"$319",
	"$321",
	"$323",
	"$397",
	0
};
short yyrmap[] = {

	 440,  441,  442,    7,   11,   14,   21,   22,   26,   54, 
	  55,   56,   59,   60,   61,   62,   69,   86,   97,  101, 
	 108,  109,  111,  114,  115,  116,  117,  125,  126,  127, 
	 129,  132,  133,  134,  136,  162,  177,  180,  181,  182, 
	 186,  188,  189,  204,  205,  218,  219,  220,  222,  223, 
	 236,  237,  253,  272,  274,  275,  294,  295,  304,  310, 
	 311,  313,  317,  318,  326,  327,  328,  329,  330,  331, 
	 332,  333,  334,  335,  336,  337,  338,  339,  353,  354, 
	 357,  358,  359,  360,  361,  362,  363,  364,  375,  396, 
	 398,  397,  395,  394,  393,  392,  391,  390,  389,  388, 
	 387,  386,  384,  383,  377,  376,  373,  372,  369,  365, 
	 356,  355,  352,  351,  350,  349,  348,  347,  346,  345, 
	 343,  342,  341,  340,  325,  324,  323,  322,  321,  320, 
	 319,  316,  315,  314,  312,  309,  308,  307,  306,  305, 
	 303,  302,  301,  300,  299,  298,  297,  296,  293,  279, 
	 278,  277,  276,  273,  271,  266,  265,  264,  263,  262, 
	 261,  260,  259,  258,  257,  256,  255,  254,  252,  251, 
	 250,  249,  242,  241,  240,  239,  238,  235,  234,  233, 
	 232,  231,  230,  229,  228,  227,  226,  225,  224,  221, 
	 217,  216,  215,  214,  213,  212,  211,  210,  209,  208, 
	 207,  206,  203,  202,  201,  200,  199,  198,  197,  196, 
	 195,  194,  193,  192,  191,  190,  187,  185,  184,  183, 
	 179,  178,  176,  174,  169,  168,  167,  166,  165,  164, 
	 163,  156,  155,  154,  153,  152,  151,  150,  149,  148, 
	 147,  146,  145,  144,  143,  142,  141,  140,  139,  138, 
	 137,  135,  131,  130,  128,  124,  123,  122,  121,  120, 
	 113,  110,  107,  106,  105,  104,  102,  100,   99,   98, 
	  96,   95,   94,   93,   92,   91,   90,   89,   88,   87, 
	  85,   84,   83,   82,   80,   77,   70,   68,   67,   58, 
	  57,   53,   52,   51,   50,   49,   47,   42,   40,   38, 
	  36,   35,   34,   33,   31,   28,   27,   25,   24,   23, 
	  20,   19,   18,   17,   13,   12,    8,    6,    1,    2, 
	   3,    4,    5,    9,   10,   29,   30,   32,   37,   39, 
	  46,   48,   65,   66,   72,   73,   74,   79,   81,  118, 
	 119,  159,  160,  161,  172,  173,  175,  243,  244,  245, 
	 246,  247,  248,  269,  270,  280,  281,  282,  283,  284, 
	 285,  286,  287,  288,  289,  290,  291,  292,  344,  367, 
	 368,  370,  371,  378,  379,  380,  381,  382,  385,  399, 
	 400,  401,  402,  403,  404,  405,  406,  407,  408,  409, 
	 410,  411,  412,  414,  415,  416,  417,  418,  419,  420, 
	 421,  422,  423,  424,  425,  426,  427,  428,  429,  430, 
	 431,  432,  433,  434,  435,  436,  437,  438,  439,  413, 
	 374,  366,  268,  267,  171,  170,  158,  157,  112,  103, 
	  78,   76,   75,   71,   64,   63,   45,   44,   43,   41, 
	  16,   15,    0
};
short yysmap[] = {

	   0,    1,    3,    4,    5,    6,    7,    9,   10,   15, 
	  20,   23,   27,   76,   79,   86,   94,  125,  127,  135, 
	 142,  158,  159,  160,  165,  167,  168,  169,  175,  182, 
	 185,  187,  196,  197,  198,  206,  207,  210,  213,  226, 
	 227,  228,  249,  272,  273,  274,  276,  277,  286,  287, 
	 288,  291,  302,  311,  319,  324,  325,  326,  327,  328, 
	 329,  330,  331,  332,  333,  334,  335,  336,  337,  344, 
	 356,  362,  367,  370,  371,  372,  373,  378,  381,  383, 
	 388,  390,  393,  394,  397,  398,  399,  400,  401,  402, 
	 403,  404,  405,  412,  413,  415,  416,  419,  422,  426, 
	 427,  436,  442,  443,  447,  452,  460,  463,  464,  466, 
	 468,  474,  483,  487,  488,  493,  495,  499,  507,  508, 
	 511,  513,  517,  519,  540,  545,  547,  551,  552,  556, 
	 568,  571,  579,  582,  584,  586,  591,  594,  602,  604, 
	 606,  613,  620,  621,  623,  633,  635,  636,  642,  653, 
	 655,  658,  675,  678,  683,  685,  699,  710,  711,  715, 
	 708,  705,  704,  703,  702,  701,  698,  695,  693,  692, 
	 691,  689,  688,  686,  682,  681,  676,  673,  671,  670, 
	 669,  668,  667,  665,  663,  661,  659,  657,  654,  652, 
	 650,  649,  648,  647,  646,  645,  644,  641,  640,  639, 
	 638,  634,  632,  630,  629,  627,  625,  622,  617,  615, 
	 614,  611,  609,  607,  605,  599,  598,  597,  595,  590, 
	 589,  587,  585,  583,  577,  576,  574,  569,  567,  566, 
	 563,  561,  559,  557,  555,  554,  550,  548,  541,  536, 
	 534,  533,  532,  528,  526,  524,  523,  521,  520,  514, 
	 500,  492,  490,  485,  484,  469,  467,  462,  461,  459, 
	 458,  457,  455,  454,  453,  446,  445,  444,  441,  440, 
	 439,  438,  437,  435,  434,  432,  430,  428,  423,  417, 
	 411,  410,  409,  408,  392,  386,  385,  382,  379,  377, 
	 375,  368,  366,  365,  364,  359,  357,  355,  354,  349, 
	 348,  347,  341,  321,  320,  314,  310,  309,  308,  307, 
	 306,  305,  304,  303,  301,  299,  298,  297,  292,  289, 
	 278,  250,  248,  247,  246,  245,  244,  243,  242,  241, 
	 240,  239,  238,  237,  236,  235,  234,  229,  221,  220, 
	 219,  217,  216,  214,  212,  211,  209,  208,  204,  203, 
	 190,  189,  181,  174,  164,  157,  156,  155,  151,  146, 
	 145,  137,  129,  128,  126,  124,  108,  104,  102,  101, 
	 100,   96,   88,   78,   75,   74,   33,   32,   31,   30, 
	  28,   24,   21,   19,   17,   16,    8,    2,  506,  290, 
	 293,  295,  188,  294,  296,  191,  186,  433,  369,  194, 
	 192,  195,  199,   85,  300,  374,  193,   95,  395,  396, 
	 147,  148,  149,  233,  150,  322,  152,  153,  230,  231, 
	 232,  323,  205,  376,   97,  509,   98,  510,   99,  558, 
	 380,  592,  512,  515,  516,  593,  560,  518,  562,  626, 
	 564,  103,  389,  105,  106,  107,  109,  123,  318,  312, 
	 215,  618,  600,  522,  313,  628,  596,  616,  456,  664, 
	 565,  391,  218,  651,  525,  315,  529,  316,  530,  317, 
	 470,  471,  472,  538,  473,  475,  476,  477,  478,  479, 
	 480,  481,  482,  270,  271,  352,  353,  489,  486,  542, 
	 543,  350,  351,  448,  450,  384,  449,  451,  387,  679, 
	 714,  716,  700,  709,  684,  697,  707,  680,  690,  656, 
	 696,  677,  666,  672,  643,   29,  601,  531,  572,  573, 
	 619,  631,  537,  338,  339,  340,  603,  539,  406,  346, 
	 251,  252,  253,  254,  255,  256,  257,  258,  259,  260, 
	 261,  262,  263,  264,  265,  266,  267,  414,  275,  544, 
	 578,  491,  546,  580,  268,  269,  581,  549,   18,  170, 
	 171,  172,  173,   87,  136,  200,  201,  202,  223,  224, 
	 225,  138,  139,  140,  141,  283,  284,  285,  418,  178, 
	 179,  180,  358,  498,  706,  662,  687,  674,  660,  420, 
	 421,  610,  360,  496,  424,  553,  361,  183,  637,  501, 
	 502,  503,  504,  431,  184,  345,  162,  280,  281,  282, 
	 176,   25,   26,  177,  144,  161,   14,   13,   12,   11, 
	 163,  143,   89,  429,  505,  612,  363,  588,  425,  497, 
	 608,  624,  694,  713,  712,   22,  494,  166,  279,  343, 
	 407,  342,  535,  575,  465,  134,  222,  133,  132,  131, 
	 130,  527,  570,  122,  121,  120,  119,  118,  117,  116, 
	 115,  114,  113,  112,  111,  110,  154,   93,   92,   91, 
	  90,   84,   83,   82,   81,   80,   77,   73,   72,   71, 
	  70,   69,   68,   67,   66,   65,   64,   63,   62,   61, 
	  60,   59,   58,   57,   56,   55,   54,   53,   52,   51, 
	  50,   49,   48,   47,   46,   45,   44,   43,   42,   41, 
	  40,   39,   38,   37,   36,   35,   34
};
int st_parse::yyntoken = 167;
int st_parse::yynvar = 171;
int st_parse::yynstate = 717;
int st_parse::yynrule = 443;
#endif



// C++ YACC parser code
// Copyright 1991 by Mortice Kern Systems Inc.  All rights reserved.
//
// If YYDEBUG is defined as 1 and st_parse::yydebug is set to 1,
// yyparse() will print a travelogue of its actions as it reads
// and parses input.
//
// YYSYNC can be defined to cause yyparse() to attempt to always
// hold a lookahead token

const YY_MIN_STATE_NUM = 20;	// not useful to be too small!

#if YYDEBUG
#ifdef YYTRACE
long	* st_parse::States	= yyStates;
#endif
yyTypedRules * st_parse::Rules	= yyRules;
yyNamedType * st_parse::TokenTypes = yyTokenTypes;

#define YY_TRACE(fn) { done = 0; fn(); if (done) YYRETURN(-1); }
#endif

// Constructor for st_parse: user-provided tables
st_parse::st_parse(int *pError, int sz, short * states, YYSTYPE * stack)
{
	*pError = 0;
    pContext = 0;
	mustfree = 0;
	if ((size = sz) < YY_MIN_STATE_NUM
	 || (stateStack = states) == (short *) 0
	 || (valueStack = stack) == (YYSTYPE *) 0) {
		*pError = 2;
		return;
	}
	reset = 1;		// force reset
#if YYDEBUG
	yydebug = 0;
	typeStack = new short[size+1];
	if (typeStack == (short *) 0) {
		*pError = 1;
		return;
	}
#endif
}
// Constructor for st_parse: allocate tables with new
st_parse::st_parse(int *pError, int sz)
{
	*pError = 0;
    pContext = 0;
	size = sz;
	reset = 1;		// force reset
	mustfree = 1;		// delete space in deconstructor
#if YYDEBUG
	yydebug = 0;
	typeStack = new short[size+1];
#endif
	stateStack = new short[size+1];
	valueStack = new YYSTYPE[size+1];

	if (stateStack == (short *) 0 || valueStack == (YYSTYPE *) 0
#if YYDEBUG
		|| typeStack == (short *) 0
#endif
	    ) {
        delete(stateStack);
        delete(valueStack);
        *pError =1;
		return;
	}
}
// Destructor for class st_parse
//	Free up space
st_parse::~st_parse()
{
	if (mustfree) {
		delete stateStack;
		delete valueStack;
	}
	stateStack = (short *) 0;
#if YYDEBUG
	delete typeStack;
#endif
}

// The parser proper.
//	Note that this code is reentrant; you can return a value
//	and then resume parsing by recalling yyparse().
//	Call yyreset() before yyparse() if you want a fresh start
int
st_parse::yyparse()
{
	short	* yyp, * yyq;		// table lookup
	int	yyj;
#if YYDEBUG
	int	yyruletype = 0;
#endif


	if (reset) {			// start new parse
		yynerrs = 0;
		yyerrflag = 0;
		yyps = stateStack;
		yypv = valueStack;
#if YYDEBUG
		yytp = typeStack;
#endif
		yystate = YYS0;
		yyclearin();
		reset = 0;
	} else			// continue saved parse
		goto yyNext;			// after action

yyStack:
	if (++yyps > &stateStack[size]) {
		yyerrorStackOverflow();
		YYABORT;
	}
	*yyps = yystate;	/* stack current state */
	*++yypv = yyval;	/* ... and value */
#if YYDEBUG
	if (yydebug) {
		*++yytp = yyruletype;	/* ... and type */
		YY_TRACE(yyShowState)
	}
#endif

	/*
	 * Look up next action in action table.
	 */
yyEncore:
#ifdef YYSYNC
	if (yychar < 0) {
		if ((yychar = yynexttoken(&yylval)) < 0) {
			if (yychar == -2) YYABORT;
			yychar = 0;
		}	/* endif */
#if YYDEBUG
		if (yydebug)
			yyShowRead();	// show new input token
#endif
	}
#endif
	if (yystate >= sizeof yypact/sizeof yypact[0]) 	/* simple state */
		yyi = yystate - YYDELTA;	/* reduce in any case */
	else {
		if(*(yyp = &yyact[yypact[yystate]]) >= 0) {
			/* Look for a shift on yychar */
#ifndef YYSYNC
			if (yychar < 0) {
				if ((yychar = yynexttoken(&yylval)) < 0) {
					if (yychar == -2) YYABORT;
					yychar = 0;
				}	/* endif */
				
#if YYDEBUG
				if (yydebug)
					yyShowRead();	// show new input token
#endif
			}
#endif
			yyq = yyp;
			yyi = yychar;
			while (yyi < *yyp++)
				;
			if (yyi == yyp[-1]) {
				yystate = yyneg(yyq[yyq-yyp]);
#if YYDEBUG
				if (yydebug) {
					yyruletype = yyGetType(yychar);
					YY_TRACE(yyShowShift)
				}
#endif
				yyval = yylval;		/* stack value */
				yyclearin();		/* clear token */
				if (yyerrflag)
					yyerrflag--;	/* successful shift */
				goto yyStack;
			}
		}

		/*
	 	 *	Fell through - take default action
	 	 */

		if (yystate >= sizeof yydef /sizeof yydef[0])
			goto yyError;
		if ((yyi = yydef[yystate]) < 0)	 { /* default == reduce? */

			/* Search exception table */
			yyp = &yyex[yyneg(yyi)];
#ifndef YYSYNC
			if (yychar < 0) {
				if ((yychar = yynexttoken(&yylval)) < 0) {
					if (yychar == -2) YYABORT;
					yychar = 0;
				}	/* endif */
				
#if YYDEBUG
				if (yydebug)
					yyShowRead();	// show new input token
#endif
			}
#endif
			while((yyi = *yyp) >= 0 && yyi != yychar)
				yyp += 2;
			yyi = yyp[1];
		}
	}

	yyj = yyrlen[yyi];

#if YYDEBUG
	if (yydebug) {
		npop = yyj; rule = yyi;
		YY_TRACE(yyShowReduce)
		yytp -= yyj;
	}
#endif
	yyps -= yyj;		/* pop stacks */
	yypvt = yypv;		/* save top */
	yypv -= yyj;
	yyval = yypv[1];	/* default action $ = $1 */
#if YYDEBUG
	if (yydebug)
		yyruletype = yyRules[yyrmap[yyi]].type;
#endif
	switch (yyi) {		/* perform semantic action */
		
case YYr6: {	/* file :  HDRFILE_START POUheader */

    pContext->endOfDecls(true);
 
} break;

case YYr7: {	/* file :  EXPR_START expression */

    pContext->m_pSingleExpression = yypvt[0].expr;
 
} break;

case YYr8: {	/* file :  STACTION_START opt_statement_list */
 
    assert(!pContext->m_pSTAction); 
    pContext->m_pSTAction = yypvt[0].stmt;
 
} break;

case YYr11: {	/* file :  opt_sysComment */

    pContext->handleEmptyFile();
 
} break;

case YYr12: {	/* opt_sysComment :  AttribList opt_comma SYS_COMMENT_END */
 
    yyval.attrlist = yypvt[-2].attrlist;
 
} break;

case YYr13: {	/* opt_sysComment :  SYS_COMMENT_BEGIN SYS_COMMENT_END */
 yyval.attrlist = NULL;
} break;

case YYr14: {	/* opt_sysComment :  */
 yyval.attrlist = NULL;
} break;

case YYr17: {	/* AttribList :  SYS_COMMENT_BEGIN AttribAssignment */

    yyval.attrlist = new ST_CAttrList(&yypvt[-1].edp, pContext);
    if(yypvt[0].tagval.pTag)
    {
        assert(yypvt[0].tagval.pVal);
        yyval.attrlist->addAttr(yypvt[0].tagval.pTag, yypvt[0].tagval.pVal);
    }
 
} break;

case YYr18: {	/* AttribList :  AttribList ',' AttribAssignment */

    if(yypvt[0].tagval.pTag)
    {
        assert(yyval.attrlist && yypvt[0].tagval.pVal);
        yyval.attrlist->addAttr(yypvt[0].tagval.pTag, yypvt[0].tagval.pVal);
    }
 
} break;

case YYr19: {	/* AttribAssignment :  IDDotList EQ WSTRING_BEG */

    yyval.tagval.pVal = pContext->getAttribVal(&yypvt[0].edp);
    if(yyval.tagval.pVal)
    {
        yyval.tagval.pTag = yypvt[-2].ident;
    }
    else
    {
        
        delete(yypvt[-2].ident);
        yyval.tagval.pTag = NULL;
    }
 
} break;

case YYr20: {	/* AttribAssignment :  IDDotList EQ IDENTIFIER */

    yyval.tagval.pTag = NULL;
    pContext->m_pdm->msg1(CG_E_ATTRIB_VALUE_NOT_STRING, yypvt[0].ident->getEdp(), yypvt[-2].ident->getName());
 
} break;

case YYr21: {	/* AttribAssignment :  IDDotList EQ */
  
    yyval.tagval.pTag = yypvt[-1].ident;
    yyval.tagval.pVal = new ST_Identifier_C(&yypvt[0].edp, pContext, _T(""));
 
} break;

case YYr22: {	/* IDDotList :  IDENTIFIER */
 
    yyval.ident = yypvt[0].ident;
 
} break;

case YYr23: {	/* IDDotList :  IDENTIFIER '.' IDENTIFIER */

    FC_CString jot(MAX_PATH);
    const CG_Edipos* pEdp1 = yypvt[-2].ident->getEdp();
    const CG_Edipos* pEdp2 = yypvt[0].ident->getEdp();

    (jot<<yypvt[-2].ident->getName()).addc(_T('.'));
    
    if(pEdp1->lc.l!=pEdp2->lc.l || pEdp1->lc.c + jot.len() != pEdp2->lc.c)
    {
        
        pContext->m_pdm->msg1(CG_E_SYNTAX_UNEXPECTED, &yypvt[-1].edp, 
			pContext->m_pdm->res1(CG_RES_STR_ST1));
    }
    jot<<yypvt[0].ident->getName();
    yyval.ident = new ST_Identifier_C(pEdp1, pContext, jot);
    delete(yypvt[-2].ident);
    delete(yypvt[0].ident);
 
} break;

case YYr24: {	/* gvlcst_file :  opt_sysComment */
 
    //TODO check std attribs:
    if(yypvt[0].attrlist)
    {
        pContext->m_pSymtabPrv->registerAttributes(yypvt[0].attrlist->convertToStruct());
        delete(yypvt[0].attrlist);
    }
 
} break;

case YYr25: {	/* gvlcst_file :  opt_sysComment $24 opt_decl_sections */
 
    pContext->endOfDecls(false);
 
} break;

case YYr26: {	/* data_type_declaration :  opt_sysComment */

    assert(!pContext->m_pSysCommentTMP);
    pContext->m_pSysCommentTMP = yypvt[0].attrlist;
 
} break;

case YYr27: {	/* data_type_declaration :  opt_sysComment $26 TYPE */

    if(pContext->checkFileNameToPOUTyp(&yypvt[0].edp, CG_POU_SDT)!=CG_POU_SDT)
        YYABORT;
 
} break;

case YYr28: {	/* data_type_declaration :  opt_sysComment $26 TYPE $27 type_declaration_list END_TYPE */

    pContext->endDeclSection(pContext->m_ulhdrEndTMP);
    pContext->endOfDecls(false);

 
} break;

case YYr31: {	/* type_declaration :  IDENTIFIER ':' STRUCT */

    bool bOk = pContext->newPOU(pContext->m_pSysCommentTMP, CG_POU_SDT, yypvt[-2].ident, NULL);
    pContext->m_pSysCommentTMP = NULL;
    if(!bOk) 
        YYABORT;
 
} break;

case YYr33: {	/* type_declaration :  IDENTIFIER ':' IDENTIFIER */
pContext->m_pdm->msg0(CG_E_ONLY_DUT_IMPL, yypvt[-2].ident->getEdp());YYABORT;
} break;

case YYr34: {	/* type_declaration :  IDENTIFIER ':' ARRAY */
pContext->m_pdm->msg0(CG_E_ONLY_DUT_IMPL, yypvt[-2].ident->getEdp());YYABORT;
} break;

case YYr35: {	/* type_declaration :  IDENTIFIER ':' '(' */
pContext->m_pdm->msg0(CG_E_ONLY_DUT_IMPL, yypvt[-2].ident->getEdp());YYABORT;
} break;

case YYr36: {	/* type_declaration :  IDENTIFIER ':' basic_type_kw '(' signed_lit_or_const DOTDOT signed_lit_or_const ')' */
pContext->m_pdm->msg0(CG_E_ONLY_DUT_IMPL, yypvt[-7].ident->getEdp());YYABORT;
} break;

case YYr38: {	/* configuration_declaration :  opt_sysComment CONFIGURATION IDENTIFIER */
 
     CG_AttribList* pAttr = yypvt[-2].attrlist ? yypvt[-2].attrlist->convertToStruct() : NULL;
     delete(yypvt[-2].attrlist);
     if(!pContext->newCON(yypvt[0].ident->getEdp(), yypvt[0].ident->getName(), pAttr))
         YYABORT; 
      delete(yypvt[0].ident);
   
} break;

case YYr40: {	/* opt_conf_decl_sections :  VAR_GLOBAL */

     pContext->m_pdm->msg1(CG_E_NOT_SUPPORTED, &yypvt[0].edp,
       pContext->m_pdm->res1(CG_RES_STR_ST2));
 
} break;

case YYr42: {	/* opt_instance_specific_init :  VAR_CONFIG */
 
   pContext->m_pdm->msg1(CG_E_NOT_SUPPORTED, &yypvt[0].edp, _T("VAR_CONFIG"));
   YYABORT;
 
} break;

case YYr47: {	/* resource_declaration_list :  IMPORT_DIRECTIVE */

     TCHAR* psz = pContext->getImportFile(&yypvt[0].edp);
     if(psz)
     {
        pContext->RESImport(&yypvt[0].edp, psz); 
        delete(psz);
     }
 
} break;

case YYr49: {	/* resource_declaration_list :  resource_declaration_list IMPORT_DIRECTIVE */

     TCHAR* psz = pContext->getImportFile(&yypvt[0].edp);
     if(psz)
     {
        pContext->RESImport(&yypvt[0].edp, psz); 
        delete(psz);
     }
 
} break;

case YYr50: {	/* resource_declaration :  opt_sysComment RESOURCE IDENTIFIER opt_sysComment opt_ResType */

        if(pContext->m_srcType == CG_SRC_TYPE_CON)
        { 
            pContext->m_pdm->msg1(CG_E_NOT_SUPPORTED, &yypvt[-3].edp, 
				pContext->m_pdm->res1(CG_RES_STR_ST3));
            YYABORT;
        }
        if(!pContext->newRES(yypvt[-4].attrlist, yypvt[-2].ident, yypvt[-1].attrlist, yypvt[0].ident))
            YYABORT;
   
} break;

case YYr51: {	/* resource_declaration :  opt_sysComment RESOURCE IDENTIFIER opt_sysComment opt_ResType $50 opt_decl_sections opt_task_configuration_list opt_program_configuration_list END_RESOURCE */

        assert(pContext->m_pCurrTaskList == yypvt[-2].tasklist);
        pContext->m_pCurrTaskList = NULL;
        pContext->endOfResource(yypvt[-2].tasklist);
   
} break;

case YYr52: {	/* opt_ResType :  ON IDENTIFIER */
 yyval.ident = yypvt[0].ident;
} break;

case YYr53: {	/* opt_ResType :  ON WSTRING_BEG */
 yyval.ident = pContext->getAttribVal(&yypvt[0].edp); 
} break;

case YYr54: {	/* opt_ResType :  */
 yyval.ident = NULL;
} break;

case YYr55: {	/* opt_task_configuration_list :  task_configuration_list */
 yyval.tasklist = yypvt[0].tasklist; 
} break;

case YYr56: {	/* opt_task_configuration_list :  */
 yyval.tasklist = NULL; 
} break;

case YYr57: {	/* task_configuration_list :  TASK IDENTIFIER opt_sysComment '(' opt_task_initialisation_list ')' ';' */

    yyval.tasklist = new ST_CTaskList(pContext, yypvt[-5].ident, yypvt[-4].attrlist, yypvt[-2].taskinit);
    pContext->m_pCurrTaskList = yyval.tasklist;
 
} break;

case YYr58: {	/* task_configuration_list :  task_configuration_list TASK IDENTIFIER opt_sysComment '(' opt_task_initialisation_list ')' ';' */

    yypvt[-7].tasklist->addTask(pContext, yypvt[-5].ident, yypvt[-4].attrlist, yypvt[-2].taskinit);
 
} break;

case YYr59: {	/* opt_task_initialisation_list :  task_initialisation_list */
 yyval.taskinit = yypvt[0].taskinit; 
} break;

case YYr60: {	/* opt_task_initialisation_list :  */
 yyval.taskinit = NULL; 
} break;

case YYr61: {	/* task_initialisation_list :  IDENTIFIER BECOMES expression */
 
    yyval.taskinit = new ST_CTaskInits(pContext, &pContext->m_pFront->m_exprMem, yypvt[-2].ident, yypvt[0].expr);
 
} break;

case YYr62: {	/* task_initialisation_list :  task_initialisation_list ',' IDENTIFIER BECOMES expression */

    yypvt[-4].taskinit->addPair(pContext, &pContext->m_pFront->m_exprMem, yypvt[-2].ident, yypvt[0].expr);
 
} break;

case YYr67: {	/* program_configuration :  PROGRAM opt_decl_modifiers IDENTIFIER opt_sysComment opt_task_name ':' IDENTIFIER opt_conf_elements */
 
    pContext->attachPrgToTask(yypvt[-6].declmod, yypvt[-5].ident, yypvt[-4].attrlist, yypvt[-3].ident, yypvt[-1].ident); 
 
} break;

case YYr68: {	/* opt_task_name :  WITH IDENTIFIER */
 yyval.ident = yypvt[0].ident; 
} break;

case YYr69: {	/* opt_task_name :  */
 yyval.ident = NULL;
} break;

case YYr70: {	/* opt_conf_elements :  '(' conf_elements ')' */
 
    pContext->m_pdm->msg1(CG_E_NOT_SUPPORTED, &yypvt[-2].edp, 
		pContext->m_pdm->res1(CG_RES_STR_ST4)); 
 
} break;

case YYr77: {	/* opt_access_declaration :  VAR_ACCESS */

   pContext->m_pdm->msg1(CG_E_NOT_SUPPORTED, &yypvt[0].edp, _T("VAR_ACCESS"));
   YYABORT;
 
} break;

case YYr80: {	/* POUheader :  opt_sysComment opt_NATIVE poutyp_kw pouname opt_ret_type */
 
    if(yypvt[-2].poutyp==CG_POUTYP_UNDEF || !yypvt[0].dtype)
        YYABORT; 
    if(yypvt[-2].poutyp!=CG_POU_FUN || yypvt[0].dtype->type==CG_VOID)
    {
        //HACK yypvt[-1].ident->m_FilePos is null for MOD,AND,OR,XOR but they have decl sections...
        pContext->m_ulhdrEndTMP = yypvt[-1].ident->m_FilePos; 
    }
    if(!pContext->newPOU(yypvt[-4].attrlist, yypvt[-2].poutyp, yypvt[-1].ident, yypvt[0].dtype)) 
        YYABORT;
    assert(pContext->m_ulhdrEndTMP > 0);
    pContext->m_pSymtabPrv->setNewHdrIFEnd(pContext->m_ulhdrEndTMP, true);
    if(yypvt[-3].ident)
    {
        //convert to new syntax:
        FC_CString jot;
        jot<<_T("#movetop")<<yypvt[-3].ident->getName();
        pContext->m_pSymtabPrv->registerVarNative(yypvt[-3].ident->getEdp(), jot);
        delete(yypvt[-3].ident);
    }
  
} break;

case YYr82: {	/* poutyp_kw :  PROGRAM */
 yyval.poutyp = pContext->checkFileNameToPOUTyp(&yypvt[0].edp, CG_POU_PRG);
} break;

case YYr83: {	/* poutyp_kw :  FUNCTION_BLOCK */
 yyval.poutyp = pContext->checkFileNameToPOUTyp(&yypvt[0].edp, CG_POU_FB);
} break;

case YYr84: {	/* poutyp_kw :  FUNCTION */
 yyval.poutyp = pContext->checkFileNameToPOUTyp(&yypvt[0].edp, CG_POU_FUN);
} break;

case YYr85: {	/* opt_ret_type :  ':' data_type */
 yyval.dtype = yypvt[0].dtype; 
} break;

case YYr86: {	/* opt_ret_type :  */
 yyval.dtype = pContext->m_pFront->registerDType(CG_VOID, -1); 
} break;

case YYr87: {	/* pouname :  fun_name */
 yyval.ident = yypvt[0].ident; 
} break;

case YYr88: {	/* pouname :  NOT */
 yyval.ident = new ST_Identifier_C(&yypvt[0].edp, pContext, _T("NOT")); 
} break;

case YYr89: {	/* fun_name :  IDENTIFIER */
 yyval.ident = yypvt[0].ident;
} break;

case YYr90: {	/* fun_name :  MOD */
 yyval.ident = new ST_Identifier_C(&yypvt[0].edp, pContext, _T("MOD"));
} break;

case YYr91: {	/* fun_name :  AND */
 yyval.ident = new ST_Identifier_C(&yypvt[0].edp, pContext, _T("AND"));
} break;

case YYr92: {	/* fun_name :  OR */
 yyval.ident = new ST_Identifier_C(&yypvt[0].edp, pContext, _T("OR"));
} break;

case YYr93: {	/* fun_name :  XOR */
 yyval.ident = new ST_Identifier_C(&yypvt[0].edp, pContext, _T("XOR"));
} break;

case YYr94: {	/* opt_pou_body2 :  pou_body2 END_FUNCTION_BLOCK */
pContext->endOfPou(&yypvt[0].edp, CG_POU_FB);
} break;

case YYr95: {	/* opt_pou_body2 :  pou_body2 END_FUNCTION */
pContext->endOfPou(&yypvt[0].edp, CG_POU_FUN);
} break;

case YYr96: {	/* opt_pou_body2 :  pou_body2 END_PROGRAM */
pContext->endOfPou(&yypvt[0].edp, CG_POU_PRG);
} break;

case YYr97: {	/* opt_pou_body2 :  */
pContext->endOfPou(pContext->getCurrEdp(), CG_POUTYP_UNDEF);
} break;

case YYr98: {	/* il_opt_pou_body2 :  il_pou_body2 END_FUNCTION_BLOCK */
pContext->endOfPou(&yypvt[0].edp, CG_POU_FB);
} break;

case YYr99: {	/* il_opt_pou_body2 :  il_pou_body2 END_FUNCTION */
pContext->endOfPou(&yypvt[0].edp, CG_POU_FUN);
} break;

case YYr100: {	/* il_opt_pou_body2 :  il_pou_body2 END_PROGRAM */
pContext->endOfPou(&yypvt[0].edp, CG_POU_PRG);
} break;

case YYr101: {	/* il_opt_pou_body2 :  */
pContext->endOfPou(pContext->getCurrEdp(), CG_POUTYP_UNDEF);
} break;

case YYr102: {	/* pou_body2 :  opt_statement_list */
pContext->endOfSTBody(yypvt[0].stmt);
} break;

case YYr104: {	/* il_pou_body2 :  opt_instruction_list */

    assert(pContext->m_srcType==CG_SRC_TYPE_IL);
    pContext->m_IlContext.m_Instrs = yypvt[0].instrlist.pinstrbegn;
    pContext->endOfSTBody(pContext->m_IlContext.transformToST());
 
} break;

case YYr105: {	/* opt_pou_body :  pou_body END_FUNCTION_BLOCK */
pContext->endOfPou(&yypvt[0].edp, CG_POU_FB);
} break;

case YYr106: {	/* opt_pou_body :  pou_body END_FUNCTION */
pContext->endOfPou(&yypvt[0].edp, CG_POU_FUN);
} break;

case YYr107: {	/* opt_pou_body :  pou_body END_PROGRAM */
pContext->endOfPou(&yypvt[0].edp, CG_POU_PRG);
} break;

case YYr108: {	/* opt_pou_body :  */

    if(!pContext->endOfDecls(true))
       YYABORT;
    pContext->endOfPou(pContext->getCurrEdp(), CG_POUTYP_UNDEF);
 
} break;

case YYr109: {	/* pou_body :  */

     if(!pContext->endOfDecls(true))
        YYABORT;
   
} break;

case YYr110: {	/* pou_body :  $109 opt_statement_list */
 pContext->endOfSTBody(yypvt[0].stmt);
} break;

case YYr111: {	/* pou_body :  */

     if(!pContext->endOfDecls(true))
        YYABORT;
   
} break;

case YYr113: {	/* pou_body :  overloads */

    pContext->endOfDecls(false);
 
} break;

case YYr114: {	/* pou_body :  */

     if(!pContext->endOfDecls(true))
        YYABORT;
   
} break;

case YYr115: {	/* pou_body :  $114 instruction_list */

    assert(pContext->m_srcType==CG_SRC_TYPE_IL);
    pContext->m_IlContext.m_Instrs = yypvt[0].instrlist.pinstrbegn;
    pContext->endOfSTBody(pContext->m_IlContext.transformToST());
   
} break;

case YYr116: {	/* overloads :  */
  
     assert(!pContext->m_bDontCheckBackendSupportedTypes);
     pContext->m_bDontCheckBackendSupportedTypes = true;
 
} break;

case YYr117: {	/* overloads :  $116 overloadlist */
  
     assert(pContext->m_bDontCheckBackendSupportedTypes);
     pContext->m_bDontCheckBackendSupportedTypes = false;
 
} break;

case YYr120: {	/* overload :  OVERLOAD opt_ovRetType '(' opt_TypeList ')' overload_body */

} break;

case YYr121: {	/* overload :  OVERLOAD opt_ovRetType '(' opt_TypeList ')' overload_body $120 */

    pContext->m_pSymtabPrv->registerMacroBody(
        &yypvt[-6].edp,
        true, 
        pContext->m_typeorRetTMP,
        yypvt[-5].dtype,
        yypvt[-3].typeor ? yypvt[-3].typeor->m_iArgCount    : -1,
        yypvt[-3].typeor ? yypvt[-3].typeor->m_pArgTypeSets : NULL,
        yypvt[-3].typeor ? yypvt[-3].typeor->m_optCastToType: NULL,
        yypvt[-3].typeor ? yypvt[-3].typeor->m_bExtended    : false,
        yypvt[-1].ident->getEdp(),
        yypvt[-1].ident->getName()
       );//alles klar?
       delete(yypvt[-3].typeor);
       delete(yypvt[-1].ident);
 
} break;

case YYr122: {	/* overload :  KW_INLINE '{' */

    const TCHAR* psz = pContext->getSkippedBraceText(&yypvt[0].edp, '{');
    if(!psz)
        YYABORT;

    pContext->m_pSymtabPrv->registerMacroBody(
        &yypvt[-1].edp,
        false, 
        CG_TBS_EMPTY,
        NULL,
        0,
        NULL,
        NULL,
        false,
        &yypvt[0].edp,
        psz
       );//alles klar?
 
} break;

case YYr123: {	/* overload :  KW_INLINE stop_token */

    pContext->m_pSymtabPrv->registerOpAlias(pContext->getCurrEdp(),yypvt[0].exprtyp);
 
} break;

case YYr124: {	/* overload_body :  KW_INLINE '{' */

    const TCHAR* psz = pContext->getSkippedBraceText(&yypvt[0].edp, '{');
    if(!psz)
        YYABORT;
    yyval.ident = new ST_Identifier_C(&yypvt[0].edp, pContext, psz);
 
} break;

case YYr125: {	/* overload_body :  */

    pContext->m_pdm->msg0(CG_E_BODY_IN_POLY_FUN, pContext->getCurrEdp());
    YYABORT;
 
} break;

case YYr126: {	/* overload_body :  $125 statement_list */
 yyval.ident = NULL; 
} break;

case YYr127: {	/* opt_TypeList :  typeList */
 yyval.typeor = yypvt[0].typeor;
} break;

case YYr128: {	/* opt_TypeList :  typeList ',' PERIOD */
 yyval.typeor = yypvt[-2].typeor; yyval.typeor->m_bExtended = true;
} break;

case YYr129: {	/* opt_TypeList :  */
 yyval.typeor = NULL;
} break;

case YYr130: {	/* typeList :  data_type_or opt_cast */

    yyval.typeor = new ST_CTypeOrList(pContext->getCurrEdp(), pContext);
    yyval.typeor->addType(pContext->getCurrEdp(), pContext->m_typeorTMP, yypvt[0].dtype);
 
} break;

case YYr131: {	/* typeList :  typeList ',' data_type_or opt_cast */

    (yyval.typeor = yypvt[-3].typeor)->addType(pContext->getCurrEdp(), pContext->m_typeorTMP, yypvt[0].dtype);
 
} break;

case YYr132: {	/* opt_ovRetType :  data_type_or */
 
    yyval.dtype = NULL;
    pContext->m_typeorRetTMP = pContext->m_typeorTMP; 
 
} break;

case YYr133: {	/* opt_ovRetType :  basic_type_kw TO data_type_or */

    if(!CG_IsMonomorph(yypvt[-2].btype) || CG_IsUserTyp(yypvt[-2].btype))
    {
        pContext->m_pdm->msg1(CG_E_ANYTYPE_BAD_USE, &yypvt[-1].edp, CGT_DTYPES_ToString(yypvt[-2].btype));
        yyval.dtype = NULL;
    }
    else
    {
        yyval.dtype = pContext->m_pFront->registerDType(yypvt[-2].btype, -1); 
    }
    pContext->m_typeorRetTMP = pContext->m_typeorTMP; 
 
} break;

case YYr134: {	/* opt_ovRetType :  */

    yyval.dtype = NULL;
    pContext->m_typeorRetTMP = CG_TBS_VOID; 
 
} break;

case YYr135: {	/* opt_cast :  TO basic_type_kw */
 
    if(!CG_IsMonomorph(yypvt[0].btype) || CG_IsUserTyp(yypvt[0].btype))
    {
        pContext->m_pdm->msg1(CG_E_ANYTYPE_BAD_USE, 
            pContext->getCurrEdp(), CGT_DTYPES_ToString(yypvt[0].btype));
        yyval.dtype = NULL;
    }
    else
    {
        yyval.dtype = pContext->m_pFront->registerDType(yypvt[0].btype, -1); 
    }
 
} break;

case YYr136: {	/* opt_cast :  */
 
    yyval.dtype = NULL;
 
} break;

case YYr137: {	/* data_type_or :  data_type */
 
    if(yypvt[0].dtype) //may be error! ##AC
        pContext->m_typeorTMP.initFromCG_DType(yypvt[0].dtype);
    else
        assert(pContext->getErrorsInFile()>0);
 
} break;

case YYr138: {	/* data_type_or :  data_type_or '|' data_type */

    if(yypvt[0].dtype) //may be error! ##AC
 { 
    if(pContext->m_typeorTMP.hasExtTypeDescr() || CG_HasExtTypeDescr(yypvt[0].dtype))
    {
        pContext->m_pdm->msg1(CG_E_NOT_SUPPORTED, 
            &yypvt[-1].edp, pContext->m_pdm->res1(CG_RES_STR_ST6));
    }
    else
    {
        pContext->m_typeorTMP = pContext->m_typeorTMP.GetTypeSet() | yypvt[0].dtype->tbs;
    }
 }
    else
        assert(pContext->getErrorsInFile()>0);
 
} break;

case YYr139: {	/* stop_token :  BECOMES */
 yyval.exprtyp = CG_MOVE;
} break;

case YYr140: {	/* stop_token :  OR */
 yyval.exprtyp = CG_OR;  
} break;

case YYr141: {	/* stop_token :  XOR */
 yyval.exprtyp = CG_XOR; 
} break;

case YYr142: {	/* stop_token :  AND */
 yyval.exprtyp = CG_AND; 
} break;

case YYr143: {	/* stop_token :  EQ */
 yyval.exprtyp = CG_EQ;  
} break;

case YYr144: {	/* stop_token :  NE */
 yyval.exprtyp = CG_NE;  
} break;

case YYr145: {	/* stop_token :  LT */
 yyval.exprtyp = CG_LT;  
} break;

case YYr146: {	/* stop_token :  LE */
 yyval.exprtyp = CG_LE;  
} break;

case YYr147: {	/* stop_token :  GT */
 yyval.exprtyp = CG_GT;  
} break;

case YYr148: {	/* stop_token :  GE */
 yyval.exprtyp = CG_GE;  
} break;

case YYr149: {	/* stop_token :  '+' */
 yyval.exprtyp = CG_ADD; 
} break;

case YYr150: {	/* stop_token :  '-' */
 yyval.exprtyp = CG_SUB; 
} break;

case YYr151: {	/* stop_token :  '*' */
 yyval.exprtyp = CG_MUL; 
} break;

case YYr152: {	/* stop_token :  '/' */
 yyval.exprtyp = CG_DIV; 
} break;

case YYr153: {	/* stop_token :  MOD */
 yyval.exprtyp = CG_MOD; 
} break;

case YYr154: {	/* stop_token :  POW */
 yyval.exprtyp = CG_POW; 
} break;

case YYr155: {	/* stop_token :  NOT */
 yyval.exprtyp = CG_NOT; 
} break;

case YYr156: {	/* stop_token :  '(' ')' */
 yyval.exprtyp = CG_NOOP; 
} break;

case YYr162: {	/* decl_section :  */
 
    if(pContext->m_srcType==CG_SRC_TYPE_IL) 
        pContext->m_IlContext.m_bParseBody = false;
 
} break;

case YYr163: {	/* decl_section :  $162 decl_scope */
 pContext->m_bDeclSecHasAddr = false; 
} break;

case YYr164: {	/* decl_section :  $162 decl_scope $163 opt_decl_list */
  pContext->endDeclSection(pContext->m_ulhdrEndTMP); 
} break;

case YYr165: {	/* decl_section :  $162 decl_scope $163 opt_decl_list $164 END_VAR */
  
    if(pContext->m_srcType==CG_SRC_TYPE_IL) 
        pContext->m_IlContext.m_bParseBody = true;
 
} break;

case YYr166: {	/* decl_section :  VAR_NATIVE */
 
    const TCHAR* psz;
    pContext->newDeclScope(&yypvt[0].edp, CG_VAR_NATIVE,  0); 
    psz  = pContext->getSkippedText(&yypvt[0].edp, _T("END_VAR"));
    if(!psz)
        YYABORT;
    pContext->m_ulhdrEndTMP = UTIL_STS_GetFPosOfNextChar(pContext->m_pScanner);
    pContext->m_pSymtabPrv->registerVarNative(&yypvt[0].edp, psz);
    pContext->endDeclSection(pContext->m_ulhdrEndTMP);
 
} break;

case YYr167: {	/* decl_section :  IMPORT_DIRECTIVE */

    TCHAR* psz = pContext->getImportFile(&yypvt[0].edp);
    if(psz)
    {
        pContext->GVLImport(&yypvt[0].edp, psz);
        pContext->m_ulhdrEndTMP = UTIL_STS_GetFPosOfNextChar(pContext->m_pScanner);
        pContext->endDeclSection(pContext->m_ulhdrEndTMP);
        delete(psz);
    }
 
} break;

case YYr168: {	/* decl_section :  DECL_CONST */
pContext->newDeclScope(&yypvt[0].edp, CG_CONST,  0);
} break;

case YYr169: {	/* decl_section :  DECL_CONST $168 opt_decl_list DECL_END_CONST */
 pContext->endDeclSection(pContext->m_ulhdrEndTMP); 
} break;

case YYr174: {	/* decl :  opt_decl_idlist opt_addr ':' data_type opt_CONSTANT opt_init */
 
     pContext->appendDeclListToSymTab(yypvt[-5].decllist, yypvt[-4].optaddr.optdirect, yypvt[-4].optaddr.optsysvar ? yypvt[-4].optaddr.optsysvar->getName() : NULL, yypvt[-2].dtype, yypvt[-1].declmod, yypvt[0].expr);
	 delete(yypvt[-4].optaddr.optsysvar);
 
} break;

case YYr176: {	/* opt_CONSTANT :  CONSTANT */
 yyval.declmod = CG_DMOD_CONSTANT; 
} break;

case YYr177: {	/* opt_CONSTANT :  */
 yyval.declmod = 0; 
} break;

case YYr178: {	/* opt_addr :  AT DIRECT_VARIABLE */
 
	yyval.optaddr.optdirect = yypvt[0].direct; 
	yyval.optaddr.optsysvar = NULL; 
	pContext->m_bDeclSecHasAddr = true;
 
} break;

case YYr179: {	/* opt_addr :  AT IDENTIFIER */

	yyval.optaddr.optdirect = pContext->directAddrFromSysVar(yypvt[0].ident->getEdp(), yypvt[0].ident->getName()); 
	yyval.optaddr.optsysvar = yypvt[0].ident; 
	pContext->m_bDeclSecHasAddr = true;
  
} break;

case YYr180: {	/* opt_addr :  */
 
    yyval.optaddr.optdirect = NULL; 
    yyval.optaddr.optsysvar = NULL;
 
} break;

case YYr181: {	/* opt_decl_idlist :  decl_idlist */
 yyval.decllist = yypvt[0].decllist;
} break;

case YYr182: {	/* opt_decl_idlist :  */
 yyval.decllist = NULL;
} break;

case YYr183: {	/* decl_idlist :  IDENTIFIER opt_sysComment */
 
   yyval.decllist = new ST_CDeclList(yypvt[-1].ident->getEdp(), pContext);
   yyval.decllist->addIdAttr(yypvt[-1].ident, yypvt[0].attrlist); 
 
} break;

case YYr184: {	/* decl_idlist :  decl_idlist ',' IDENTIFIER opt_sysComment */
 
   yypvt[-3].decllist->addIdAttr(yypvt[-1].ident, yypvt[0].attrlist); 
 
} break;

case YYr185: {	/* opt_NATIVE :  NATIVE */
 
    const TCHAR* psz = pContext->getSkippedText(&yypvt[0].edp, _T("END_NATIVE"));
    if(!psz)
        YYABORT;
    yyval.ident = new ST_Identifier_C(&yypvt[0].edp, pContext, psz);
 
} break;

case YYr186: {	/* opt_NATIVE :  */
 yyval.ident = NULL;
} break;

case YYr187: {	/* opt_init :  BECOMES initializer */
yyval.expr = yypvt[0].expr;
} break;

case YYr188: {	/* opt_init :  */
yyval.expr = NULL;
} break;

case YYr189: {	/* initializer :  expression */
yyval.expr = yypvt[0].expr;
} break;

case YYr190: {	/* initializer :  '[' array_initial_elements ']' */
yyval.expr = yypvt[-1].arrayInit;
} break;

case YYr191: {	/* initializer :  '(' structInit ')' */
yyval.expr = yypvt[-1].structInit;
} break;

case YYr192: {	/* structInit :  IDENTIFIER BECOMES initializer */

    yyval.structInit = new ST_StructInit_C(yypvt[-2].ident->getEdp(), pContext, yypvt[-2].ident,yypvt[0].expr);
 
} break;

case YYr193: {	/* structInit :  structInit ',' IDENTIFIER BECOMES initializer */

    yyval.structInit->append(yypvt[-2].ident,yypvt[0].expr);
 
} break;

case YYr194: {	/* array_initial_elements :  init_simple */

    yyval.arrayInit = new ST_ArrayInit_C(yypvt[0].expr->getEdp(), pContext, NULL,yypvt[0].expr);
 
} break;

case YYr195: {	/* array_initial_elements :  signed_lit_or_const '(' array_initial_elements ')' */

    yyval.arrayInit = new ST_ArrayInit_C(yypvt[-3].expr->getEdp(), pContext, yypvt[-3].expr,  yypvt[-1].arrayInit);
 
} break;

case YYr196: {	/* array_initial_elements :  signed_lit_or_const '(' ')' */

    yyval.arrayInit = new ST_ArrayInit_C(yypvt[-2].expr->getEdp(), pContext, yypvt[-2].expr,  NULL);
 
} break;

case YYr197: {	/* array_initial_elements :  '(' expression ')' '(' array_initial_elements ')' */

    yyval.arrayInit = new ST_ArrayInit_C(&yypvt[-5].edp, pContext, yypvt[-4].expr,  yypvt[-1].arrayInit);
 
} break;

case YYr198: {	/* array_initial_elements :  '(' expression ')' '(' ')' */

    yyval.arrayInit = new ST_ArrayInit_C(&yypvt[-4].edp, pContext, yypvt[-3].expr,  NULL );
 
} break;

case YYr199: {	/* array_initial_elements :  array_initial_elements ',' init_simple */

    yyval.arrayInit->append(NULL, yypvt[0].expr);
 
} break;

case YYr200: {	/* array_initial_elements :  array_initial_elements ',' signed_lit_or_const '(' array_initial_elements ')' */

    yyval.arrayInit->append(yypvt[-3].expr, yypvt[-1].arrayInit);
 
} break;

case YYr201: {	/* array_initial_elements :  array_initial_elements ',' signed_lit_or_const '(' ')' */

    yyval.arrayInit->append(yypvt[-2].expr, NULL);
 
} break;

case YYr202: {	/* array_initial_elements :  array_initial_elements ',' '(' expression ')' '(' array_initial_elements ')' */

    yyval.arrayInit->append(yypvt[-4].expr, yypvt[-1].arrayInit);
 
} break;

case YYr203: {	/* array_initial_elements :  array_initial_elements ',' '(' expression ')' '(' ')' */

    yyval.arrayInit->append(yypvt[-3].expr, NULL);
 
} break;

case YYr204: {	/* init_simple :  signed_lit_or_const */
yyval.expr = yypvt[0].expr;
} break;

case YYr205: {	/* init_simple :  '(' expression ')' */
yyval.expr = yypvt[-1].expr;
} break;

case YYr206: {	/* init_simple :  '(' structInit ')' */
yyval.expr = yypvt[-1].structInit;
} break;

case YYr207: {	/* signed_lit_or_const :  LITERAL */
yyval.expr = yypvt[0].lit;
} break;

case YYr208: {	/* signed_lit_or_const :  '+' LITERAL */
yyval.expr = pContext->checkUPlusMinus(&yypvt[-1].edp, yypvt[0].lit, false);
} break;

case YYr209: {	/* signed_lit_or_const :  '-' LITERAL */
yyval.expr = pContext->checkUPlusMinus(&yypvt[-1].edp, yypvt[0].lit, true);
} break;

case YYr210: {	/* signed_lit_or_const :  IDENTIFIER */
yyval.expr = pContext->createVar(yypvt[0].ident);
} break;

case YYr211: {	/* signed_lit_or_const :  '+' IDENTIFIER */
yyval.expr = pContext->checkUPlusMinus(&yypvt[-1].edp, pContext->createVar(yypvt[0].ident), false);
} break;

case YYr212: {	/* signed_lit_or_const :  '-' IDENTIFIER */
yyval.expr = pContext->checkUPlusMinus(&yypvt[-1].edp, pContext->createVar(yypvt[0].ident), true);
} break;

case YYr213: {	/* data_type :  basic_type_edge opt_strlen */
 
    long    lStrLen  = -1;
    bool    bStrLenOk= true;
    if(yypvt[0].expr)
    {
        if(yypvt[-1].btype!=CG_DTYPES_UNDEF)
            lStrLen = pContext->checkTypeStrLen(yypvt[-1].btype, yypvt[0].expr);
        bStrLenOk = lStrLen>=0;;
    }
    
    assert(yypvt[-1].btype!=CG_DTYPES_UNDEF || pContext->getErrorsInFile()>0);
    if(yypvt[-1].btype!=CG_DTYPES_UNDEF && bStrLenOk)
        yyval.dtype = pContext->m_pFront->registerDType(yypvt[-1].btype, lStrLen);
    else
        yyval.dtype = NULL;
 
} break;

case YYr214: {	/* data_type :  IDENTIFIER opt_strlen */

    const CG_Symtab* pSym;
    yyval.dtype = NULL;

    if(!yypvt[0].expr)
        pContext->m_ulhdrEndTMP = yypvt[-1].ident->m_FilePos;

    //##AC beg
    const TCHAR*         pszType = yypvt[-1].ident->getName();
    if(pContext->pSymtab && pContext->pSymtab->flags & CG_STAB_FORCEACTASK) //d-306: ->pSymtab may be 
    {                                                                       //NULL if parsing function return type
        //todo check
        if(!_tcsicmp(pszType, "ANY_WAITABLE")) // TODO make real keywords 
            yyval.dtype = pContext->m_pFront->registerDType(CG_ANY_WAITABLE, -1);
        else if(!_tcsicmp(pszType, "GOTOLABEL"))
            yyval.dtype = pContext->m_pFront->registerDType(CG_GOTOLABEL, -1);
        else if(!_tcsicmp(pszType, "VOID"))
            yyval.dtype = pContext->m_pFront->registerDType(CG_VOID, -1);
    }
    
    if(!yyval.dtype)
    {
        pSym = pContext->getSymtabForDType(yypvt[-1].ident->getEdp(), pszType, ST_WANT_FB|ST_WANT_SDT);
        if(pSym)
            yyval.dtype = pContext->m_pFront->registerDType(pSym);
    }

    if(yypvt[0].expr)
    {
        pContext->m_pdm->msg0(CG_E_BAD_STRLENGTH_TYPE, yypvt[0].expr->getEdp());
        delete(yypvt[0].expr);
    }
    //##AC end
    delete(yypvt[-1].ident);
 
} break;

case YYr215: {	/* data_type :  ARRAY opt_array_dim_list OF basic_type_edge opt_strlen */

    CG_Subrange ranges[CG_MAX_ARRAY_DIM];
    int         nDims  = 0;
    bool        bDimOk = true;
    long        lStrLen= -1;
    bool        bStrLenOk = true;

    yyval.dtype = NULL;
    if(yypvt[-3].list)
    {
       nDims = pContext->checkArrayDims(yypvt[-3].list, ranges);
       bDimOk= nDims>0;
    }
    if(yypvt[0].expr)
    {
        if(yypvt[-1].btype!=CG_DTYPES_UNDEF)
            lStrLen = pContext->checkTypeStrLen(yypvt[-1].btype, yypvt[0].expr);
        bStrLenOk = lStrLen>=0;
    }

    assert(yypvt[-1].btype!=CG_DTYPES_UNDEF || pContext->getErrorsInFile()>0);
    if(bDimOk && bStrLenOk && yypvt[-1].btype!=CG_DTYPES_UNDEF)
    {
        yyval.dtype = pContext->m_pFront->registerDType(
                      nDims, ranges, yypvt[-1].btype, lStrLen, NULL);
    }
 
} break;

case YYr216: {	/* data_type :  ARRAY opt_array_dim_list OF IDENTIFIER opt_strlen */

    CG_Subrange      ranges[CG_MAX_ARRAY_DIM];
    const CG_Symtab* pSym;
    int              nDims = 0;
    bool             bDimOk = true;

    if(!yypvt[0].expr)
        pContext->m_ulhdrEndTMP = yypvt[-1].ident->m_FilePos;

    yyval.dtype = NULL;
    if(yypvt[-3].list)
    {
       nDims = pContext->checkArrayDims(yypvt[-3].list, ranges);
       bDimOk= nDims>0;
    }

    pSym = pContext->getSymtabForDType(yypvt[-1].ident->getEdp(), yypvt[-1].ident->getName(), ST_WANT_SDT);

    if(yypvt[0].expr)
    {
        pContext->m_pdm->msg0(CG_E_BAD_STRLENGTH_TYPE, yypvt[0].expr->getEdp());
        delete(yypvt[0].expr);
    }
    else if(pSym && bDimOk)
    {
        yyval.dtype = pContext->m_pFront->registerDType(
                    nDims, ranges, CG_STRUCT, -1, pSym); 
    }
    delete(yypvt[-1].ident);
 
} break;

case YYr217: {	/* opt_array_dim_list :  '[' array_dim_list ']' */
 yyval.list = yypvt[-1].list;
} break;

case YYr218: {	/* opt_array_dim_list :  */
 yyval.list = NULL;
} break;

case YYr219: {	/* array_dim_list :  expression DOTDOT expression */
 
    yyval.list = new ST_ExpressionList_C(pContext, yypvt[-2].expr); 
    yypvt[0].expr->Detach(); 
    yyval.list->m_list.add(yypvt[0].expr); //##AC
 
} break;

case YYr220: {	/* array_dim_list :  array_dim_list ',' expression DOTDOT expression */
 
    pContext->m_pdm->msg0(CG_E_ONLY_ONE_DIM, yypvt[-2].expr->getEdp()); 
 
} break;

case YYr221: {	/* opt_strlen :  '[' expression ']' */
 yyval.expr = yypvt[-1].expr; 
} break;

case YYr222: {	/* opt_strlen :  */
 yyval.expr = NULL; 
} break;

case YYr223: {	/* basic_type_edge :  basic_type_kw */

    yyval.btype = yypvt[0].btype;
 
} break;

case YYr224: {	/* basic_type_edge :  basic_type_kw R_EDGE */

    if(yypvt[-1].btype==CG_BOOL)
    {
        yyval.btype = CG_BOOL_R_EDGE;
    }
    else
    {
        pContext->m_pdm->msg0(CG_E_ILLUSE_EDGE, &yypvt[0].edp);
        yyval.btype = CG_DTYPES_UNDEF;
    }
 
} break;

case YYr225: {	/* basic_type_edge :  basic_type_kw F_EDGE */

    if(yypvt[-1].btype==CG_BOOL)
    {
        yyval.btype = CG_BOOL_F_EDGE;
    }
    else
    {
        pContext->m_pdm->msg0(CG_E_ILLUSE_EDGE, &yypvt[0].edp);
        yyval.btype = CG_DTYPES_UNDEF;
    }
 
} break;

case YYr226: {	/* basic_type_kw :  BASIC_TYP */
 yyval.btype = yypvt[0].btype; 
} break;

case YYr227: {	/* basic_type_kw :  QVT_TYP */
 yyval.btype = yypvt[0].btype; 
} break;

case YYr228: {	/* decl_scope :  VAR_GLOBAL opt_decl_modifiers */
pContext->newDeclScope(&yypvt[-1].edp, CG_VAR_GLOBAL,  yypvt[0].declmod);
} break;

case YYr229: {	/* decl_scope :  VAR opt_decl_modifiers */
pContext->newDeclScope(&yypvt[-1].edp, CG_VAR,         yypvt[0].declmod);
} break;

case YYr230: {	/* decl_scope :  VAR_INPUT opt_decl_modifiers */
pContext->newDeclScope(&yypvt[-1].edp, CG_VAR_INPUT,   yypvt[0].declmod);
} break;

case YYr231: {	/* decl_scope :  VAR_OUTPUT opt_decl_modifiers */
pContext->newDeclScope(&yypvt[-1].edp, CG_VAR_OUTPUT,  yypvt[0].declmod);
} break;

case YYr232: {	/* decl_scope :  VAR_IN_OUT opt_decl_modifiers */
pContext->newDeclScope(&yypvt[-1].edp, CG_VAR_IN_OUT,  yypvt[0].declmod);
} break;

case YYr233: {	/* decl_scope :  VAR_EXTERNAL opt_decl_modifiers */
pContext->newDeclScope(&yypvt[-1].edp, CG_VAR_EXTERNAL,yypvt[0].declmod);
} break;

case YYr234: {	/* decl_scope :  VAR_TEMP opt_decl_modifiers */
pContext->newDeclScope(&yypvt[-1].edp, CG_VAR_TEMP,    yypvt[0].declmod);
} break;

case YYr235: {	/* decl_scope :  VAR_IN_EXT opt_decl_modifiers */
pContext->newDeclScope(&yypvt[-1].edp, CG_VAR_IN_EXT,  yypvt[0].declmod);
} break;

case YYr236: {	/* opt_decl_modifiers :  decl_modifiers */
yyval.declmod = yypvt[0].declmod;
} break;

case YYr237: {	/* opt_decl_modifiers :  */
yyval.declmod = 0;
} break;

case YYr238: {	/* decl_modifiers :  decl_modifier */
 yyval.declmod = yypvt[0].declmod;
} break;

case YYr239: {	/* decl_modifiers :  decl_modifiers decl_modifier */

    if((yypvt[-1].declmod & yypvt[0].declmod)!=0 || ((yypvt[-1].declmod | yypvt[0].declmod) & CG_DMOD_ANY_RETAIN)==CG_DMOD_ANY_RETAIN)
    {
        pContext->m_pdm->msg0(CG_E_MODIFIER_TWICE, pContext->getCurrEdp());
        yyval.declmod = yypvt[-1].declmod;
    }
    else
    {
        yyval.declmod = yypvt[-1].declmod | yypvt[0].declmod;
    }
 
} break;

case YYr240: {	/* decl_modifier :  RETAIN */
 yyval.declmod = CG_DMOD_RETAIN;
} break;

case YYr241: {	/* decl_modifier :  NON_RETAIN */
 yyval.declmod = CG_DMOD_NON_RETAIN;
} break;

case YYr242: {	/* decl_modifier :  CONSTANT */
 yyval.declmod = CG_DMOD_CONSTANT;
} break;

case YYr249: {	/* step :  STEP IDENTIFIER ':' */

        pContext->addSFC();
        pContext->m_pSFC->sfcAddStep(yypvt[-1].ident);
        pContext->m_pSFC->sfcStartStep();
  
} break;

case YYr250: {	/* step :  STEP IDENTIFIER ':' $249 opt_action_association_list END_STEP */

        pContext->m_pSFC->sfcEndStep();
  
} break;

case YYr251: {	/* initial_step :  INITIAL_STEP IDENTIFIER ':' */

      pContext->addSFC();
      pContext->m_pSFC->sfcAddInitialStep(yypvt[-1].ident);
      pContext->m_pSFC->sfcStartStep();
  
} break;

case YYr252: {	/* initial_step :  INITIAL_STEP IDENTIFIER ':' $251 opt_action_association_list END_STEP */

      pContext->m_pSFC->sfcEndStep();
  
} break;

case YYr253: {	/* transition :  TRANSITION */

       pContext->addSFC();
       pContext->m_pSFC->sfcStartTransition(&yypvt[0].edp);
    
} break;

case YYr254: {	/* transition :  TRANSITION $253 FROM */

       pContext->m_pSFC->sfcStartTransitionFrom();
    
} break;

case YYr255: {	/* transition :  TRANSITION $253 FROM $254 steps TO */

       pContext->m_pSFC->sfcStartTransitionTo();
    
} break;

case YYr256: {	/* transition :  TRANSITION $253 FROM $254 steps TO $255 steps BECOMES expression ';' END_TRANSITION */

       const CG_STStmt* pTrn;
       pTrn = pContext->newTransAssignStmt(yypvt[-2].expr->getEdp(), yypvt[-2].expr);
       pContext->m_pSFC->sfcAddTransitionPrio(-1);
       pContext->m_pSFC->sfcEndTransition(&yypvt[0].edp, pTrn);
    
} break;

case YYr257: {	/* transition :  TRANSITION IDENTIFIER */

       pContext->addSFC();
       pContext->m_pSFC->sfcStartTransitionNamed(yypvt[0].ident);
    
} break;

case YYr258: {	/* transition :  TRANSITION IDENTIFIER $257 FROM */

       pContext->m_pSFC->sfcStartTransitionFrom();
    
} break;

case YYr259: {	/* transition :  TRANSITION IDENTIFIER $257 FROM $258 steps TO */

       pContext->m_pSFC->sfcStartTransitionTo();
    
} break;

case YYr260: {	/* transition :  TRANSITION IDENTIFIER $257 FROM $258 steps TO $259 steps BECOMES expression ';' END_TRANSITION */

       const CG_STStmt* pTrn;
       pTrn = pContext->newTransAssignStmt(yypvt[-2].expr->getEdp(), yypvt[-2].expr);
       pContext->m_pSFC->sfcEndTransition(&yypvt[0].edp, pTrn);
    
} break;

case YYr261: {	/* steps :  IDENTIFIER */

   pContext->m_pSFC->sfcAddTransitionStep(yypvt[0].ident, true);
 
} break;

case YYr262: {	/* steps :  '(' IDENTIFIER ',' step_name_list ')' */

   pContext->m_pSFC->sfcAddTransitionStep(yypvt[-3].ident, false);
 
} break;

case YYr263: {	/* step_name_list :  IDENTIFIER */

   pContext->m_pSFC->sfcAddTransitionStep(yypvt[0].ident, false);
 
} break;

case YYr264: {	/* step_name_list :  step_name_list ',' IDENTIFIER */

   pContext->m_pSFC->sfcAddTransitionStep(yypvt[0].ident, false);
 
} break;

case YYr265: {	/* action :  ACTION IDENTIFIER ':' */

     pContext->addSFC();
     pContext->m_pSFC->sfcAddAction(yypvt[-1].ident);
     pContext->m_pSFC->sfcStartAction();
   
} break;

case YYr266: {	/* action :  ACTION IDENTIFIER ':' $265 opt_statement_list END_ACTION */

     pContext->m_pSFC->sfcEndAction(&yypvt[0].edp, yypvt[-1].stmt, yypvt[-4].ident->getName(), yypvt[-4].ident->getEdp());
     delete yypvt[-4].ident;
   
} break;

case YYr271: {	/* action_association :  IDENTIFIER '(' action_qualifier_list ')' */

    pContext->m_pSFC->sfcAddActionAssociation(yypvt[-3].ident);
 
} break;

case YYr272: {	/* action_qualifier_list :  IDENTIFIER */

    pContext->m_pSFC->sfcAddActionAssociationQualifier(yypvt[0].ident);
    pContext->m_pSFC->sfcAddActionAssociationTime(0);
  
} break;

case YYr273: {	/* action_qualifier_list :  IDENTIFIER ',' LITERAL */

    pContext->m_pSFC->sfcAddActionAssociationQualifier(yypvt[-2].ident);
    pContext->m_pSFC->sfcAddActionAssociationTime(yypvt[0].lit);
  
} break;

case YYr274: {	/* opt_statement_list :  statement_list */

    yyval.stmt=yypvt[0].stmtlist.plistbegn; 
    pContext->foundStmts(true);
 
} break;

case YYr275: {	/* opt_statement_list :  */

    yyval.stmt = NULL; 
    pContext->foundStmts(false);
 
} break;

case YYr276: {	/* statement_list :  labeled_statement ';' */
 
    yyval.stmtlist.plistbegn = yypvt[-1].stmtlist.plistbegn; 
    yyval.stmtlist.plistlast = yypvt[-1].stmtlist.plistlast;
    assert(pContext->getErrorsInFile()>0 || !yyval.stmtlist.plistlast->pNext); 
 
} break;

case YYr277: {	/* statement_list :  statement_list labeled_statement ';' */
 
    if(yypvt[-2].stmtlist.plistbegn && yypvt[-2].stmtlist.plistlast && yypvt[-1].stmtlist.plistbegn && yypvt[-1].stmtlist.plistlast)
    {
        //optimise  ;;;;;;;;;;;;;;; in the same ST line, is it worth it??
        yyval.stmtlist.plistbegn = yypvt[-2].stmtlist.plistbegn; 
        assert(!yypvt[-2].stmtlist.plistlast->pNext);
        yypvt[-2].stmtlist.plistlast->pNext = yypvt[-1].stmtlist.plistbegn;
        yyval.stmtlist.plistlast = yypvt[-1].stmtlist.plistlast;
        assert(!yyval.stmtlist.plistlast->pNext); 
    }
    else
    {
        assert(pContext->getErrorsInFile()>0);
        yyval.stmtlist.plistbegn = NULL; 
        yyval.stmtlist.plistlast = NULL; 
    }
 
} break;

case YYr278: {	/* labeled_statement :  IDENTIFIER ':' statement */
 
    if(yypvt[0].stmt)
    {
        yyval.stmtlist.plistbegn = pContext->newLabel(yypvt[-2].ident->getEdp(), yypvt[-2].ident->getName(), yypvt[0].stmt);
        yyval.stmtlist.plistlast = yypvt[0].stmt;   
        assert(!yyval.stmtlist.plistlast->pNext); 
    }
    else
    {
        assert(pContext->getErrorsInFile()>0);
        //error handling: insert just the label to avoid later undef label msg.
        pContext->newLabel(yypvt[-2].ident->getEdp(), yypvt[-2].ident->getName(), NULL);
        yyval.stmtlist.plistbegn = NULL; 
        yyval.stmtlist.plistlast = NULL; 
    }
    delete(yypvt[-2].ident);
 
} break;

case YYr279: {	/* labeled_statement :  statement */
 
    yyval.stmtlist.plistbegn = yypvt[0].stmt; 
    yyval.stmtlist.plistlast = yypvt[0].stmt; 
 
} break;

case YYr293: {	/* statement :  error */
 yyval.stmt  = NULL; 
} break;

case YYr294: {	/* empty_statement :  */
 yyval.stmt = pContext->newEmptyStmt(pContext->getCurrEdp()); 
} break;

case YYr295: {	/* assignment_statement :  variable BECOMES expression */
 yyval.stmt = pContext->newAssignStmt(&yypvt[-1].edp, yypvt[-2].expr, yypvt[0].expr); 
} break;

case YYr296: {	/* exit_statement :  EXIT */
 yyval.stmt = pContext->newExitStmt(&yypvt[0].edp);
} break;

case YYr297: {	/* return_statement :  RETURN */
 yyval.stmt = pContext->newReturnStmt(&yypvt[0].edp);
} break;

case YYr298: {	/* native_statement :  NATIVE */

    const TCHAR* psz = pContext->getSkippedText(&yypvt[0].edp, _T("END_NATIVE"));
    if(!psz)
        YYABORT;
    yyval.stmt = pContext->newNativeStmt(&yypvt[0].edp, psz);
 
} break;

case YYr299: {	/* fb_invocation :  fun_name '(' opt_any_param_list ')' */

    const CG_Symtab* pSym;
    ST_Expression_C* pE = pContext->newCallExpr(yypvt[-3].ident->getEdp(), yypvt[-3].ident->getName(), CG_POUTYP_UNDEF, yypvt[-1].paramlist);
    pE->getCalledPOU(&pSym, NULL);
    pE->fixType();
    if((pSym && pSym->pouTyp==CG_POU_FUN && pSym->pFirst->pType->type!=CG_VOID) && !pE->isErrorExpr())
        pContext->m_pdm->msg2(CG_E_NOVOID_FUNCTION, yypvt[-3].ident->getEdp(), yypvt[-3].ident->getName(), ST_TypeSetToErrMsgString(pE->GetType()));

    delete(yypvt[-3].ident);
    yyval.stmt = pContext->newCallStmt(pE);

} break;

case YYr300: {	/* if_statement :  IF */
pContext->m_pbt->if_stmts++;
} break;

case YYr301: {	/* if_statement :  IF $300 expression THEN opt_statement_list elsif_statement_list END_IF */
 
    pContext->m_pbt->if_stmts--;
    yyval.stmt = pContext->newIfElseStmt(&yypvt[-6].edp, yypvt[-4].expr, yypvt[-2].stmt, yypvt[-1].stmt);
 
} break;

case YYr302: {	/* elsif_statement_list :  ELSIF expression THEN opt_statement_list elsif_statement_list */
 
    yyval.stmt = pContext->newIfElseStmt(&yypvt[-4].edp, yypvt[-3].expr, yypvt[-1].stmt, yypvt[0].stmt); 
 
} break;

case YYr303: {	/* elsif_statement_list :  ELSE opt_statement_list */
 
    yyval.stmt = yypvt[0].stmt; 
 
} break;

case YYr304: {	/* elsif_statement_list :  */
 
    yyval.stmt = NULL; 
 
} break;

case YYr305: {	/* case_statement :  CASE expression OF case_element_list opt_else_statement_list END_CASE */
 
    yyval.stmt = pContext->newCaseStmt(&yypvt[-5].edp, yypvt[-4].expr, yypvt[-2].caselist.pcasebegn, yypvt[-1].stmt);
 
} break;

case YYr306: {	/* case_element_list :  case_list ':' statement ';' */

    yyval.caselist.pcasebegn = pContext->newCase(yypvt[-3].caserange, yypvt[-1].stmt);
    yyval.caselist.plistlast = yypvt[-1].stmt;
 
} break;

case YYr307: {	/* case_element_list :  case_element_list case_list ':' statement ';' */

    if(yypvt[-4].caselist.plistlast && yypvt[-4].caselist.pcasebegn)
    {
        yyval.caselist.pcasebegn = yypvt[-4].caselist.pcasebegn;

        CG_STCaseList* last = yypvt[-4].caselist.pcasebegn;
        while(last->pNextCase) //TODO optimise
            last = (CG_STCaseList*)last->pNextCase;

        last->pNextCase = pContext->newCase(yypvt[-3].caserange, yypvt[-1].stmt);
        yyval.caselist.plistlast = yypvt[-1].stmt;
    }
    else
    {
        assert(pContext->getErrorsInFile()>0);
        yyval.caselist.pcasebegn = NULL;
        yyval.caselist.plistlast = NULL;
    }

 
} break;

case YYr308: {	/* case_element_list :  case_element_list statement ';' */

    if(yypvt[-2].caselist.plistlast && yypvt[-2].caselist.pcasebegn)
    {
        yyval.caselist.pcasebegn = yypvt[-2].caselist.pcasebegn;
        assert(!yypvt[-2].caselist.plistlast->pNext);
        yypvt[-2].caselist.plistlast->pNext = yypvt[-1].stmt;
        yyval.caselist.plistlast = yypvt[-1].stmt;
    }
    else
    {
        assert(pContext->getErrorsInFile()>0);
        yyval.caselist.pcasebegn = NULL;
        yyval.caselist.plistlast = NULL;
    }
 
} break;

case YYr309: {	/* opt_else_statement_list :  ELSE opt_statement_list */
yyval.stmt = yypvt[0].stmt;  
} break;

case YYr310: {	/* opt_else_statement_list :  */
yyval.stmt = NULL;
} break;

case YYr311: {	/* case_list :  signed_lit_or_const */
 
    yyval.caserange = new ST_CCaseExpr(pContext, yypvt[0].expr, NULL);
 
} break;

case YYr312: {	/* case_list :  signed_lit_or_const DOTDOT signed_lit_or_const */
 
    yyval.caserange = new ST_CCaseExpr(pContext, yypvt[-2].expr, yypvt[0].expr);
 
} break;

case YYr313: {	/* case_list :  case_list ',' signed_lit_or_const */

    (yyval.caserange = yypvt[-2].caserange)->addRange(pContext, yypvt[0].expr, NULL);
 
} break;

case YYr314: {	/* case_list :  case_list ',' signed_lit_or_const DOTDOT signed_lit_or_const */

    (yyval.caserange = yypvt[-4].caserange)->addRange(pContext, yypvt[-2].expr, yypvt[0].expr);
 
} break;

case YYr315: {	/* for_statement :  for_assignmet DO opt_statement_list END_FOR */
 
    pContext->m_pbt->for_stmts--;
    ST_Identifier_C *pId = NULL;
    pContext->m_pbt->FORVars.pop(pId);
    assert(pId);
    delete(pId);
    if(yypvt[-3].stmt)
    {
        assert(!yypvt[-3].stmt->fors.pStmts);
        yypvt[-3].stmt->fors.pStmts = yypvt[-1].stmt;
    }
    else
    {
        assert(pContext->getErrorsInFile()>0);
    }
    yyval.stmt = yypvt[-3].stmt;
 
} break;

case YYr316: {	/* for_assignmet :  FOR IDENTIFIER BECOMES expression TO expression opt_BY */

    ST_Identifier_C* pIdCopy;//must create a copy now newForStmt deletes yypvt[-5].ident!
    pIdCopy = new ST_Identifier_C(yypvt[-5].ident->getEdp(), pContext, yypvt[-5].ident->getName());
    pIdCopy->Detach();

    pContext->m_pbt->for_stmts++; 
    yyval.stmt = pContext->newForStmt(&yypvt[-6].edp, yypvt[-5].ident, yypvt[-3].expr, yypvt[-1].expr, yypvt[0].expr); 
    //remember that id is currently non writable:
    pContext->m_pbt->FORVars.push(pIdCopy);
 
} break;

case YYr317: {	/* opt_BY :  BY expression */
 yyval.expr = yypvt[0].expr;
} break;

case YYr318: {	/* opt_BY :  */
 yyval.expr = NULL;
} break;

case YYr319: {	/* while_statement :  WHILE */
pContext->m_pbt->while_stmts++;
} break;

case YYr320: {	/* while_statement :  WHILE $319 expression DO opt_statement_list END_WHILE */
 
    pContext->m_pbt->while_stmts--;
    yyval.stmt = pContext->newWhileStmt(&yypvt[-5].edp, yypvt[-3].expr, yypvt[-1].stmt); 
 
} break;

case YYr321: {	/* repeat_statement :  REPEAT */
pContext->m_pbt->repeat_stmts++;
} break;

case YYr322: {	/* repeat_statement :  REPEAT $321 opt_statement_list UNTIL expression END_REPEAT */
 
    pContext->m_pbt->repeat_stmts--;
    yyval.stmt = pContext->newRepeatStmt(&yypvt[-5].edp, yypvt[-3].stmt, yypvt[-1].expr); 
 
} break;

case YYr323: {	/* synchronized_statement :  SYNCHRONIZED */
 pContext->m_pbt->sync_stmts++;
} break;

case YYr324: {	/* synchronized_statement :  SYNCHRONIZED $323 opt_statement_list END_SYNCHRONIZED */
 
   yyval.stmt = pContext->newSynchronizedStmt(&yypvt[-3].edp, yypvt[-1].stmt); 
   pContext->m_pbt->sync_stmts--;
 
} break;

case YYr325: {	/* goto_statement :  GOTO IDENTIFIER */
 
    yyval.stmt = pContext->newGotoStmt(yypvt[0].ident->getEdp(), yypvt[0].ident->getName());
    delete(yypvt[0].ident);
 
} break;

case YYr326: {	/* expression :  expression OR expression */

    yyval.expr = pContext->createOp(&yypvt[-1].edp, CG_OR, yypvt[-2].expr, yypvt[0].expr);
 
} break;

case YYr327: {	/* expression :  expression XOR expression */

    yyval.expr = pContext->createOp(&yypvt[-1].edp, CG_XOR, yypvt[-2].expr, yypvt[0].expr);
 
} break;

case YYr328: {	/* expression :  expression AND expression */

    yyval.expr = pContext->createOp(&yypvt[-1].edp, CG_AND, yypvt[-2].expr, yypvt[0].expr);
 
} break;

case YYr329: {	/* expression :  expression EQ expression */

    yyval.expr = pContext->createOp(&yypvt[-1].edp, CG_EQ, yypvt[-2].expr, yypvt[0].expr);
 
} break;

case YYr330: {	/* expression :  expression NE expression */

    yyval.expr = pContext->createOp(&yypvt[-1].edp, CG_NE, yypvt[-2].expr, yypvt[0].expr);
 
} break;

case YYr331: {	/* expression :  expression LT expression */

    yyval.expr = pContext->createOp(&yypvt[-1].edp, CG_LT, yypvt[-2].expr, yypvt[0].expr);
 
} break;

case YYr332: {	/* expression :  expression LE expression */

    yyval.expr = pContext->createOp(&yypvt[-1].edp, CG_LE, yypvt[-2].expr, yypvt[0].expr);
 
} break;

case YYr333: {	/* expression :  expression GT expression */

    yyval.expr = pContext->createOp(&yypvt[-1].edp, CG_GT, yypvt[-2].expr, yypvt[0].expr);
 
} break;

case YYr334: {	/* expression :  expression GE expression */

    yyval.expr = pContext->createOp(&yypvt[-1].edp, CG_GE, yypvt[-2].expr, yypvt[0].expr);
 
} break;

case YYr335: {	/* expression :  expression '+' expression */

    yyval.expr = pContext->createOp(&yypvt[-1].edp, CG_ADD, yypvt[-2].expr, yypvt[0].expr);
 
} break;

case YYr336: {	/* expression :  expression '-' expression */

    yyval.expr = pContext->createOp(&yypvt[-1].edp, CG_SUB, yypvt[-2].expr, yypvt[0].expr);
 
} break;

case YYr337: {	/* expression :  expression '*' expression */

    yyval.expr = pContext->createOp(&yypvt[-1].edp, CG_MUL, yypvt[-2].expr, yypvt[0].expr);
 
} break;

case YYr338: {	/* expression :  expression '/' expression */

    yyval.expr = pContext->createOp(&yypvt[-1].edp, CG_DIV, yypvt[-2].expr, yypvt[0].expr);
 
} break;

case YYr339: {	/* expression :  expression MOD expression */

    yyval.expr = pContext->createOp(&yypvt[-1].edp, CG_MOD, yypvt[-2].expr, yypvt[0].expr);
 
} break;

case YYr340: {	/* expression :  expression POW expression */

    yyval.expr = pContext->createOp(&yypvt[-1].edp, CG_POW, yypvt[-2].expr, yypvt[0].expr);
 
} break;

case YYr341: {	/* expression :  '-' expression */

    yyval.expr = pContext->createOp(&yypvt[-1].edp, CG_UMINUS, yypvt[0].expr, NULL);
 
} break;

case YYr342: {	/* expression :  '+' expression */

    yyval.expr = pContext->checkUPlusMinus(&yypvt[-1].edp, yypvt[0].expr, false);
 
} break;

case YYr343: {	/* expression :  NOT expression */

    yyval.expr = pContext->createOp(&yypvt[-1].edp, CG_NOT, yypvt[0].expr, NULL);
 
} break;

case YYr345: {	/* primary_expression :  LITERAL */
yyval.expr = yypvt[0].lit;
} break;

case YYr346: {	/* primary_expression :  variable */
yyval.expr = yypvt[0].expr;
} break;

case YYr347: {	/* primary_expression :  '(' expression ')' */
yyval.expr = pContext->createOp(&yypvt[-2].edp, CG_NOOP, yypvt[-1].expr, NULL);
} break;

case YYr348: {	/* primary_expression :  any_call */
yyval.expr = yypvt[0].expr;
} break;

case YYr349: {	/* primary_expression :  IDENTIFIER ':' */
yyval.expr = new ST_CLabelRef(yypvt[-1].ident->getEdp(), pContext, yypvt[-1].ident->getName()); delete(yypvt[-1].ident);
} break;

case YYr350: {	/* LITERAL :  WSTRING_BEG */
 yyval.lit = pContext->getStringLiteral(&yypvt[0].edp, _T('"'));
} break;

case YYr351: {	/* LITERAL :  STRING_BEG */
 yyval.lit = pContext->getStringLiteral(&yypvt[0].edp, _T('\''));
} break;

case YYr352: {	/* LITERAL :  SIMPLE_LITERAL */
 yyval.lit = yypvt[0].lit;
} break;

case YYr353: {	/* expression_list :  expression */
yyval.list = new ST_ExpressionList_C(pContext, yypvt[0].expr);
} break;

case YYr354: {	/* expression_list :  expression_list ',' expression */
yypvt[0].expr->Detach(); (yyval.list = yypvt[-2].list)->m_list.add(yypvt[0].expr);
} break;

case YYr355: {	/* any_call :  fun_name '(' opt_any_param_list ')' */

    yyval.expr = pContext->newCallExpr(yypvt[-3].ident->getEdp(), yypvt[-3].ident->getName(), CG_POUTYP_UNDEF, yypvt[-1].paramlist);
    delete(yypvt[-3].ident);

} break;

case YYr356: {	/* any_call :  QVT_TYP '(' opt_any_param_list ')' */

    if(yypvt[-3].btype==CG_DTYPES_UNDEF)
        yyval.expr = new ST_ErrorExpr_C(&yypvt[-2].edp, pContext, NULL);
    else
        yyval.expr = pContext->newCallExpr(&yypvt[-2].edp, ST_CG_DTYPES_ToString(yypvt[-3].btype), CG_POU_FUN, yypvt[-1].paramlist);

} break;

case YYr357: {	/* opt_any_param_list :  any_param_list */
 yyval.paramlist = yypvt[0].paramlist; 
} break;

case YYr358: {	/* opt_any_param_list :  */
 yyval.paramlist = NULL; 
} break;

case YYr359: {	/* any_param_list :  IDENTIFIER BECOMES expression */
 
    (yyval.paramlist = new ST_CParamList(yypvt[-2].ident->getEdp(), pContext, 16))->addNamedParam(yypvt[-2].ident->getEdp(), yypvt[-2].ident->getName(), false, false, yypvt[0].expr);
    delete(yypvt[-2].ident);
  
} break;

case YYr360: {	/* any_param_list :  IDENTIFIER RIGHT_ARROW expression */
 
    (yyval.paramlist = new ST_CParamList(yypvt[-2].ident->getEdp(), pContext, 16))->addNamedParam(yypvt[-2].ident->getEdp(), yypvt[-2].ident->getName(), true, false, yypvt[0].expr);
    delete(yypvt[-2].ident);
  
} break;

case YYr361: {	/* any_param_list :  expression */
 
    (yyval.paramlist = new ST_CParamList(yypvt[0].expr->getEdp(), pContext, 16))->addPosParam(yypvt[0].expr);
  
} break;

case YYr362: {	/* any_param_list :  any_param_list ',' IDENTIFIER BECOMES expression */

    (yyval.paramlist = yypvt[-4].paramlist)->addNamedParam(yypvt[-2].ident->getEdp(), yypvt[-2].ident->getName(), false, false, yypvt[0].expr);
    delete(yypvt[-2].ident);
  
} break;

case YYr363: {	/* any_param_list :  any_param_list ',' IDENTIFIER RIGHT_ARROW expression */

    (yyval.paramlist = yypvt[-4].paramlist)->addNamedParam(yypvt[-2].ident->getEdp(), yypvt[-2].ident->getName(), true, false, yypvt[0].expr);
    delete(yypvt[-2].ident);
  
} break;

case YYr364: {	/* any_param_list :  any_param_list ',' expression */

    (yyval.paramlist = yypvt[-2].paramlist)->addPosParam(yypvt[0].expr);
  
} break;

case YYr365: {	/* variable :  DIRECT_VARIABLE */
 yyval.expr = pContext->checkDirectBodyVar(yypvt[0].direct);
} break;

case YYr369: {	/* variable_name :  IDENTIFIER */
 yyval.expr = pContext->createVar(yypvt[0].ident);
} break;

case YYr372: {	/* array_variable :  symbolic_variable '[' expression_list ']' */
 
    
    yyval.expr = yypvt[-3].expr->isErrorExpr() ?  yypvt[-3].expr : new ST_ArrayAccess_C(pContext, yypvt[-3].expr, yypvt[-1].list);
 
} break;

case YYr373: {	/* structured_variable :  symbolic_variable '.' IDENTIFIER */
 
   if (yypvt[-2].expr->toStepActionClass()!=NULL)
   {
       yypvt[-2].expr->toStepActionClass()->setFlagTyp(yypvt[0].ident);   
       yyval.expr = yypvt[-2].expr;
   }
   else if(yypvt[-2].expr->isErrorExpr())
   {
       yyval.expr = yypvt[-2].expr;
   } 
   else
   {
       yyval.expr = new ST_StructAccess_C(pContext, yypvt[-2].expr, yypvt[0].ident);
   }

 
} break;

case YYr375: {	/* opt_instruction_list :  */

    yyval.instrlist.pinstrbegn = yyval.instrlist.pinstrlast = NULL;
 
} break;

case YYr376: {	/* instruction_list :  il_instruction */
 
    yyval.instrlist.pinstrbegn = yypvt[0].instr; 
    yyval.instrlist.pinstrlast = yypvt[0].instr;
    assert(pContext->getErrorsInFile()>0 || !yyval.instrlist.pinstrlast->pNext); 
 
} break;

case YYr377: {	/* instruction_list :  instruction_list il_instruction */
 
    if(yypvt[-1].instrlist.pinstrbegn && yypvt[-1].instrlist.pinstrlast && yypvt[0].instr)
    {
        //optimise  ;;;;;;;;;;;;;;; in the same ST line, is it worth it??
        yyval.instrlist.pinstrbegn = yypvt[-1].instrlist.pinstrbegn; 
        assert(!yypvt[-1].instrlist.pinstrlast->pNext);
        yypvt[-1].instrlist.pinstrlast->pNext = yypvt[0].instr;
        yyval.instrlist.pinstrlast = yypvt[0].instr;
        assert(!yyval.instrlist.pinstrlast->pNext); 
    }
    else
    {
        assert(pContext->getErrorsInFile()>0);
        yyval.instrlist.pinstrbegn = NULL; 
        yyval.instrlist.pinstrlast = NULL; 
    }
 
} break;

case YYr383: {	/* il_instruction :  IL_IDENTIFIER ':' */
 
    yyval.instr = new IL_Instr(yypvt[-1].ident->getEdp(), IL_LABEL, IL_LBLTYP, yypvt[-1].ident->getName());
    delete(yypvt[-1].ident);
 
} break;

case YYr384: {	/* il_simple_operation :  il_simple_operator il_operand */

    assert(yypvt[-1].instr->m_ityp == IL_SIMPLEOP || yypvt[-1].instr->m_ityp == IL_EXPR);
    yypvt[-1].instr->m_ityp = IL_SIMPLEOP;
    yyval.instr = yypvt[-1].instr;
    yyval.instr->simpleop.expr = yypvt[0].expr;
 
} break;

case YYr386: {	/* il_simple_operation :  IL_IDENTIFIER opt_any_param_list */

    yyval.instr = new IL_Instr(yypvt[-1].ident->getEdp(), IL_FUNCALL, IL_CALFUN, yypvt[-1].ident->getName());
    yyval.instr->func.paramlist = yypvt[0].paramlist;
    delete(yypvt[-1].ident); 
 
} break;

case YYr387: {	/* il_expression :  il_expr_operator '(' opt_instruction_list IL_OP_RPAR */

    assert(yypvt[-3].instr->m_ityp == IL_EXPR);
    yyval.instr = yypvt[-3].instr;
    assert(!yyval.instr->expr.subop);
    yyval.instr->expr.instrList = yypvt[-1].instrlist.pinstrbegn;
 
} break;

case YYr388: {	/* il_expression :  il_expr_operator '(' il_operand opt_instruction_list IL_OP_RPAR */

    assert(yypvt[-4].instr->m_ityp == IL_EXPR);
    yyval.instr = yypvt[-4].instr;
    yyval.instr->expr.subop = yypvt[-2].expr;
    yyval.instr->expr.instrList = yypvt[-1].instrlist.pinstrbegn;
 
} break;

case YYr389: {	/* il_jump_operation :  il_jump_operator IDENTIFIER */

    yyval.instr = yypvt[-1].instr;
    yyval.instr->jmp.label = yypvt[0].ident;
 
} break;

case YYr390: {	/* il_operand :  LITERAL */
yyval.expr = yypvt[0].lit;
} break;

case YYr391: {	/* il_operand :  '+' LITERAL */
yyval.expr = pContext->checkUPlusMinus(&yypvt[-1].edp, yypvt[0].lit, false);
} break;

case YYr392: {	/* il_operand :  '-' LITERAL */
yyval.expr = pContext->checkUPlusMinus(&yypvt[-1].edp, yypvt[0].lit, true);
} break;

case YYr393: {	/* il_operand :  variable */
yyval.expr = yypvt[0].expr;
} break;

case YYr394: {	/* il_operand :  '+' variable */
yyval.expr = pContext->checkUPlusMinus(&yypvt[-1].edp, yypvt[0].expr, false);
} break;

case YYr395: {	/* il_operand :  '-' variable */
yyval.expr = pContext->checkUPlusMinus(&yypvt[-1].edp, yypvt[0].expr, true);
} break;

case YYr396: {	/* il_fb_call :  il_call_operator IDENTIFIER */

    assert(yypvt[-1].instr->m_ityp == IL_CALFB);
    yyval.instr = yypvt[-1].instr;
    assert(!yyval.instr->fbc.FBIName);
    yyval.instr->fbc.FBIName = yypvt[0].ident;
    yyval.instr->fbc.paramlist = NULL;
 
} break;

case YYr397: {	/* il_fb_call :  il_call_operator IDENTIFIER '(' */

    pContext->m_IlContext.m_bParseBody = false;
 
} break;

case YYr398: {	/* il_fb_call :  il_call_operator IDENTIFIER '(' $397 opt_any_param_list ')' */

    pContext->m_IlContext.m_bParseBody = true;

    assert(yypvt[-5].instr->m_ityp == IL_CALFB);
    yyval.instr = yypvt[-5].instr;
    yyval.instr->fbc.FBIName = yypvt[-4].ident;
    yyval.instr->fbc.paramlist = yypvt[-1].paramlist;
 
} break;
	case YYrACCEPT:
		YYACCEPT;
	case YYrERROR:
		goto yyError;
	}
yyNext:
	/*
	 *	Look up next state in goto table.
	 */

	yyp = &yygo[yypgo[yyi]];
	yyq = yyp++;
	yyi = *yyps;
	while (yyi < *yyp++)		/* busy little loop */
		;
	yystate = yyneg(yyi == *--yyp? yyq[yyq-yyp]: *yyq);
#if YYDEBUG
	if (yydebug)
		YY_TRACE(yyShowGoto)
#endif
	goto yyStack;

yyerrlabel:	;		/* come here from YYERROR	*/
	yyerrflag = 1;
	if (yyi == YYrERROR) {
		yyps--, yypv--;
#if YYDEBUG
		if (yydebug) yytp--;
#endif
	}
	
yyError:
	switch (yyerrflag) {

	case 0:		/* new error */
		yynerrs++;
		yyi = yychar;
		yyerrorSyntax();
		if (yyi != yychar) {
			/* user has changed the current token */
			/* try again */
			yyerrflag++;	/* avoid loops */
			goto yyEncore;
		}

	case 1:		/* partially recovered */
	case 2:
		yyerrflag = 3;	/* need 3 valid shifts to recover */
			
		/*
		 *	Pop states, looking for a
		 *	shift on `error'.
		 */

		for ( ; yyps > stateStack; yyps--, yypv--
#if YYDEBUG
					, yytp--
#endif
		) {
			if (*yyps >= sizeof yypact/sizeof yypact[0])
				continue;
			yyp = &yyact[yypact[*yyps]];
			yyq = yyp;
			do
				;
			while (YYERRCODE < *yyp++);
			if (YYERRCODE == yyp[-1]) {
				yystate = yyneg(yyq[yyq-yyp]);
				goto yyStack;
			}
				
			/* no shift in this state */
#if YYDEBUG
			if (yydebug && yyps > stateStack+1)
				YY_TRACE(yyShowErrRecovery)
#endif
			/* pop stacks; try again */
		}
		/* no shift on error - abort */
		break;

	case 3:
		/*
		 *	Erroneous token after
		 *	an error - discard it.
		 */

		if (yychar == 0)  /* but not EOF */
			break;
#if YYDEBUG
		if (yydebug)
			YY_TRACE(yyShowErrDiscard)
#endif
		yyclearin();
		goto yyEncore;	/* try again in same state */
	}
	YYABORT;

}
#if YYDEBUG
/*
 * Return type of token
 */
int
st_parse::yyGetType(int tok)
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->type;
	return 0;
}

	
// Print a token legibly.
char *
st_parse::yyptok(int tok)
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->name;
	return "";
}
/*
 * Read state 'num' from YYStatesFile
 */
#ifdef YYTRACE

char *
st_parse::yygetState(int num)
{
	int	size;
	char	*cp;
	static FILE *yyStatesFile = (FILE *) 0;
	static char yyReadBuf[YYMAX_READ+1];

	if (yyStatesFile == (FILE *) 0
	 && (yyStatesFile = fopen(YYStatesFile, "r")) == (FILE *) 0)
		return "yyExpandName: cannot open states file";

	if (num < yynstate - 1)
		size = (int)(States[num+1] - States[num]);
	else {
		/* length of last item is length of file - ptr(last-1) */
		if (fseek(yyStatesFile, 0L, 2) < 0)
			goto cannot_seek;
		size = (int) (ftell(yyStatesFile) - States[num]);
	}
	if (size < 0 || size > YYMAX_READ)
		return "yyExpandName: bad read size";
	if (fseek(yyStatesFile, States[num], 0) < 0) {
	cannot_seek:
		return "yyExpandName: cannot seek in states file";
	}

	(void) fread(yyReadBuf, 1, size, yyStatesFile);
	yyReadBuf[size] = '\0';
	return yyReadBuf;
}
#endif /* YYTRACE */
/*
 * Expand encoded string into printable representation
 * Used to decode yyStates and yyRules strings.
 * If the expansion of 's' fits in 'buf', return 1; otherwise, 0.
 */
int
st_parse::yyExpandName(int num, int isrule, char * buf, int len)
{
	int	i, n, cnt, type;
	char	* endp, * cp, * s;

	if (isrule)
		s = yyRules[num].name;
	else
#ifdef YYTRACE
		s = yygetState(num);
#else
		s = "*no states*";
#endif

	for (endp = buf + len - 8; *s; s++) {
		if (buf >= endp) {		/* too large: return 0 */
		full:	(void) strcpy(buf, " ...\n");
			return 0;
		} else if (*s == '%') {		/* nonterminal */
			type = 0;
			cnt = yynvar;
			goto getN;
		} else if (*s == '&') {		/* terminal */
			type = 1;
			cnt = yyntoken;
		getN:
			if (cnt < 100)
				i = 2;
			else if (cnt < 1000)
				i = 3;
			else
				i = 4;
			for (n = 0; i-- > 0; )
				n = (n * 10) + *++s - '0';
			if (type == 0) {
				if (n >= yynvar)
					goto too_big;
				cp = yysvar[n];
			} else if (n >= yyntoken) {
			    too_big:
				cp = "<range err>";
			} else
				cp = yyTokenTypes[n].name;

			if ((i = strlen(cp)) + buf > endp)
				goto full;
			(void) strcpy(buf, cp);
			buf += i;
		} else
			*buf++ = *s;
	}
	*buf = '\0';
	return 1;
}
#ifndef YYTRACE
/*
 * Show current state of yyparse
 */
void
st_parse::yyShowState()
{
	(void) printf("state %d (%d), char %s (%d)\n%d stateStack entries\n",
		yysmap[yystate],yystate,yyptok(yychar),yychar,
		yypv - valueStack);
}
// show results of reduction: yyi is rule number
void
st_parse::yyShowReduce()
{
	(void) printf("Reduce by rule %d (pop#=%d)\n", yyrmap[rule], npop);
}
// show read token
void
st_parse::yyShowRead()
{
	(void) printf("read %s (%d)\n", yyptok(yychar), yychar);
}
// show Goto
void
st_parse::yyShowGoto()
{
	(void) printf("goto %d (%d)\n", yysmap[yystate], yystate);
}
// show Shift
void
st_parse::yyShowShift()
{
	(void) printf("shift %d (%d)\n", yysmap[yystate], yystate);
}
// show error recovery
void
st_parse::yyShowErrRecovery()
{
	(void) printf("Error recovery pops state %d (%d), uncovers %d (%d)\n",
		yysmap[*(yyps-1)], *(yyps-1), yysmap[yystate], yystate);
}
// show token discards in error processing
void
st_parse::yyShowErrDiscard()
{
	(void) printf("Error recovery discards %s (%d), ",
		yyptok(yychar), yychar);
}
#endif	/* ! YYTRACE */
#endif	/* YYDEBUG */
int st_parse::yynexttoken(YYSTYPE* val)
{
    int          tok;
    int          nLine;
    int          nCol;
    const TCHAR* yytext;
    CG_DTYPES    basicType;


    if(pContext->m_startToken)
    {
        //return a special tok to switch grammer:
        tok = pContext->m_startToken;
        pContext->m_startToken = 0;    
        return tok;
    }
    
nextToken: 

    tok = UTIL_STS_NextToken(pContext->m_pScanner, &yytext, &nLine, &nCol);
        //printf("token: '%s' (%d,%d)\n",tok==UTIL_STS_EOF?"<EOF>":yytext, nLine, nCol);

    if(pContext->m_srcType==CG_SRC_TYPE_IL && pContext->m_IlContext.m_bParseBody)
    {
        switch(tok)
        {
        case '\n':
        case ':':
            pContext->m_IlContext.m_tokensafterCR = 0;
            break;
        default:
            pContext->m_IlContext.m_tokensafterCR++;

            if(tok==')' && pContext->m_IlContext.m_tokensafterCR==1)
            {
                val->edp  = *pContext->setCurrEdp(nLine, nCol);
                return IL_OP_RPAR;
            }
        }
    }

    if(tok=='\n')
        goto nextToken;

    val->edp    = *pContext->setCurrEdp(nLine, nCol);

    switch(tok)
    {
    case UTIL_STS_TOKEN_TO_LONG:
        pContext->m_pdm->msg0(CG_E_TOKEN_TO_LONG, pContext->getCurrEdp());
        //CAUTION: you must skip this line otherwise you get an endless loop
        UTIL_STS_SkipLine(pContext->m_pScanner);
    goto nextToken; 

    case UTIL_STS_SYNTAX_ERROR:
    {
        TCHAR buff[256];
        unsigned int ui;
        if(!_istascii(*yytext))
        {
            ui = *yytext & 0xff; 
            wsprintf(buff, "'%c' = 0x%x", *yytext, ui);
            pContext->m_pdm->msg1(CG_E_SYNTAX_UNKNOWNCHAR,
                pContext->getCurrEdp(), buff);
        }
        else    
        {
            pContext->m_pdm->msg0(CG_E_SYNTAX, 
                pContext->getCurrEdp());
        }
    }
    goto nextToken;
    
    case UTIL_STS_SYS_COMMENT_BEGIN:        return SYS_COMMENT_BEGIN;
    case UTIL_STS_SYS_COMMENT_END:          return SYS_COMMENT_END;
    case UTIL_STS_ST_COMMENT_BEGIN:
        switch(UTIL_STS_SkipComment(pContext->m_pScanner, _T("*)")))
        {
        case 0:
            pContext->m_pdm->msg0(CG_E_EOF_IN_COMMENT, pContext->getCurrEdp());
            return UTIL_STS_EOF;
        case 2:
            pContext->m_pdm->msg0(CG_W_NESTED_COMMENT, pContext->getCurrEdp());
            goto nextToken;
        case 1:
            goto nextToken; 
        default:
            assert(!"bad enum");
            goto nextToken;
        }

    case UTIL_STS_DIRECT_VARIABLE:
        val->direct = pContext->getDirectAddr(yytext);
    return DIRECT_VARIABLE; 

    //literals:
    case UTIL_STS_DT_LITERAL:
    case UTIL_STS_TOD_LITERAL:
    case UTIL_STS_INT_LITERAL:
    case UTIL_STS_DATE_LITERAL:
    case UTIL_STS_TRUE_LITERAL:
    case UTIL_STS_TIME_LITERAL: 
    case UTIL_STS_FALSE_LITERAL:
    case UTIL_STS_FLOAT_LITERAL:
        val->lit = ST_LitTokenToLiteral(
                pContext->m_pdm,
                pContext->getCurrEdp(), 
                pContext, 
                &pContext->m_pFront->m_features,
                tok, 
                yytext
              );
    return SIMPLE_LITERAL;
    case UTIL_STS_STRING_LITERAL_BEGIN:
    return *yytext==_T('"') ? WSTRING_BEG : STRING_BEG;

    case UTIL_STS_PERIOD:                return PERIOD;
    case UTIL_STS_POW:                   return POW;
    case UTIL_STS_AND:                   return AND;
    case UTIL_STS_EQ:                    return EQ; 
    case UTIL_STS_NE:                    return NE; 
    case UTIL_STS_LT:                    return LT; 
    case UTIL_STS_LE:                    return LE; 
    case UTIL_STS_GT:                    return GT; 
    case UTIL_STS_GE:                    return GE;
    case UTIL_STS_BECOMES:               return BECOMES;

    case UTIL_STS_DOTDOT:                return DOTDOT;
    case UTIL_STS_RIGHT_ARROW:           return RIGHT_ARROW;

    case UTIL_STS_PRAGMA_DIRECTIVE: 
        do{
            tok = UTIL_STS_NextToken(pContext->m_pScanner, &yytext, &nLine, &nCol);
        }while(tok=='\n');

        val->edp = *pContext->setCurrEdp(nLine, nCol);
        if(tok != UTIL_STS_IDENTIFIER_EX)
        {
            pContext->m_pdm->msg1(CG_E_SYNTAX_EXPECTED, &val->edp, 
				pContext->m_pdm->res1(CG_RES_STR_ST7));
            goto nextToken;
        }
     
        if(!lstrcmpi(yytext, _T("inline")))
        {
            pContext->m_pdm->msg2(CG_W_OLD_SYNTAX, &val->edp, 
                _T("'#pragma inline {...}'"), 
                pContext->m_pdm->jot1()<<_T("\n    'inline{...}'")<<
                pContext->m_pdm->res2(CG_RES_STR_ST8)
               );
            return KW_INLINE;
        }
        else if(!lstrcmpi(yytext, _T("overload")))
        {
            pContext->m_pdm->msg2(CG_W_OLD_SYNTAX, &val->edp, 
                pContext->m_pdm->res1(CG_RES_STR_ST9), 
                pContext->m_pdm->res1(CG_RES_STR_ST10)<<
                pContext->m_pdm->res1(CG_RES_STR_ST11)
              );
            return OVERLOAD;
        }
        //TODO #pragma error|warning,  more old stuff ??
        pContext->m_pdm->msg1(CG_W_UNKNOWN_PRAGMA, &val->edp, yytext); 
        UTIL_STS_SkipLine(pContext->m_pScanner);
        goto nextToken;
   
    case UTIL_STS_IMPORT_DIRECTIVE:      return IMPORT_DIRECTIVE;

    case UTIL_STS_IDENTIFIER_EX:
    {
        UTIL_KW_ENUM kwEnum;
        HRESULT res;
        res = UTIL_CheckIdentifierEx(yytext, &kwEnum);

        if(pContext->m_srcType==CG_SRC_TYPE_IL && pContext->m_IlContext.m_bParseBody)
        {
            int op = -1;
            // in IL mode these are il operators
            switch(kwEnum)
            {
            case UTIL_KW_NO_KEYWORD: op = pContext->m_IlContext.getOperator(yytext); break;
            case UTIL_KW_MOD:        op = IL_OP_MOD;                                 break;
            case UTIL_KW_AND:        op = IL_OP_AND;                                 break;
            case UTIL_KW_OR:         op = IL_OP_OR;                                  break;
            case UTIL_KW_XOR:        op = IL_OP_XOR;                                 break;
            case UTIL_KW_NOT:        op = IL_OP_NOT;                                 break;
            }
            if(op != -1)
            {
                IL_OP il_op = il_ParseContext::getILOp(op);
                val->instr = new IL_Instr(pContext->getCurrEdp(), il_op, il_ParseContext::getInstType(il_op), yytext);
                return op;
            }
        }
                    
        switch(kwEnum)
        {
        case UTIL_KW_NO_KEYWORD:
            //check if special predefined var:
            if(res == E_UTIL_ID_SYNTAX && !_tcsicmp(yytext, _T("__edipos")))
            {
                TCHAR         szEdipos[2*MAX_PATH];
                ST_BINVAL_TYP*pBinVal;

                if((pContext->m_pFront->m_features.m_pCFeat->allTypes & CG_TBS_WSTRING)==0)
                {
                    pContext->m_pdm->errNS2(pContext->getCurrEdp(), pContext->m_pdm->res1(CG_RES_STR_DATATYPE),
                          ST_CG_DTYPES_ToString(CG_WSTRING));
                }
                
                pContext->m_pdm->edpToStrBuffer(pContext->getCurrEdp(), 
                    szEdipos+1, FC_ARRAY_LEN(szEdipos)-1-1, false);

                pBinVal = new ST_BINVAL_TYP;
                CG_BITSET strType = pContext->m_pFront->m_features.m_pCFeat->allTypes & CG_TBS_STRING ? 
                                    CG_TBS_STRING : CG_TBS_WSTRING; 
                strType = CG_TBS_WSTRING; //HCAK todo don't fix type now, wait until Propagate...

                //power HACK we need a function like bin string to IEC string.
                TCHAR delim = strType == CG_TBS_STRING ? _T('\'') : _T('"');
                int iStrLen = _tcslen(szEdipos+1);
                szEdipos[0] = delim;
                szEdipos[1+ iStrLen] = delim;
                szEdipos[2+ iStrLen] = 0;

                assert(!_tcschr(szEdipos, _T('$')));

                ST_InitBinValString(pBinVal, szEdipos);
				assert(pBinVal->iLen>=2); //TODO HACK
                val->lit = new ST_Literal_C(
                    pContext->getCurrEdp(), 
                    pContext,
                    pBinVal, 
                    ST_TypeSet_C(strType, iStrLen), //TODO HACK
                    false,
                    NULL
                    );

                return SIMPLE_LITERAL;

            }//else syntax err or correct id:

            val->ident = new ST_Identifier_C(pContext->getCurrEdp(), pContext, yytext);
            
            //HACK for function return see goto PossibleEndHdr:
            val->ident->m_FilePos = UTIL_STS_GetFPosOfNextChar(pContext->m_pScanner);

            if(res != S_OK)
               ST_CheckIdentifier(pContext->m_pdm, val->ident->getEdp(), yytext);
            if(pContext->m_srcType==CG_SRC_TYPE_IL && pContext->m_IlContext.m_bParseBody && 
                                      pContext->m_IlContext.m_tokensafterCR==1)
                return IL_IDENTIFIER;
            else
                return IDENTIFIER; 

        case UTIL_KW_TRUE:
                val->lit = ST_LitTokenToLiteral(
                    pContext->m_pdm,
                    pContext->getCurrEdp(), 
                    pContext,
                    &pContext->m_pFront->m_features,
                    UTIL_STS_TRUE_LITERAL, 
                    yytext
                );
                return SIMPLE_LITERAL;  
                              
        case UTIL_KW_FALSE:                  
                val->lit = ST_LitTokenToLiteral(
                    pContext->m_pdm,
                    pContext->getCurrEdp(), 
                    pContext,
                    &pContext->m_pFront->m_features,
                    UTIL_STS_FALSE_LITERAL, 
                    yytext
                );
                return SIMPLE_LITERAL;

        case UTIL_KW_MOD:                   return MOD; 
        
        case UTIL_KW_AND:                   return AND;
        case UTIL_KW_OR:                    return OR; 
        case UTIL_KW_XOR:                   return XOR; 
        case UTIL_KW_NOT:                   return NOT;
   
        case UTIL_KW_CONFIGURATION:         return CONFIGURATION; 
        case UTIL_KW_END_CONFIGURATION:     return END_CONFIGURATION; 
        case UTIL_KW_RESOURCE:              return RESOURCE; 
        case UTIL_KW_END_RESOURCE:          return END_RESOURCE; 
        case UTIL_KW_ON:                    return ON;
        case UTIL_KW_WITH:                  return WITH; 
        case UTIL_KW_TASK:                  return TASK; 
        case UTIL_KW_TYPE:                  return TYPE;              
        case UTIL_KW_END_TYPE:              return END_TYPE;
        case UTIL_KW_STRUCT:                return STRUCT;
        case UTIL_KW_END_STRUCT:            return END_STRUCT;
        case UTIL_KW_PROGRAM:               return PROGRAM;              
        case UTIL_KW_END_PROGRAM:           return END_PROGRAM;        
        case UTIL_KW_FUNCTION:              return FUNCTION;
        case UTIL_KW_END_FUNCTION:          return END_FUNCTION;
        case UTIL_KW_FUNCTION_BLOCK:        return FUNCTION_BLOCK;     
        case UTIL_KW_END_FUNCTION_BLOCK:    return END_FUNCTION_BLOCK; 

        //basic types:
#define CHKTYPE(type, tk) basicType=type; tok=tk; goto CheckSupportedType
        case UTIL_KW_SINT:          CHKTYPE(CG_SINT, BASIC_TYP);
        case UTIL_KW_INT:           CHKTYPE(CG_INT, BASIC_TYP);
        case UTIL_KW_DINT:          CHKTYPE(CG_DINT, BASIC_TYP);
        case UTIL_KW_LINT:          CHKTYPE(CG_LINT, BASIC_TYP);
        case UTIL_KW_USINT:         CHKTYPE(CG_USINT, BASIC_TYP);
        case UTIL_KW_UINT:          CHKTYPE(CG_UINT, BASIC_TYP);
        case UTIL_KW_UDINT:         CHKTYPE(CG_UDINT, BASIC_TYP);
        case UTIL_KW_ULINT:         CHKTYPE(CG_ULINT, BASIC_TYP);
        case UTIL_KW_REAL:          CHKTYPE(CG_REAL, BASIC_TYP);
        case UTIL_KW_LREAL:         CHKTYPE(CG_LREAL, BASIC_TYP);
        case UTIL_KW_DATE:          CHKTYPE(CG_DATE, BASIC_TYP);
        case UTIL_KW_TIME_OF_DAY:   CHKTYPE(CG_TOD, BASIC_TYP);
        case UTIL_KW_TOD:           CHKTYPE(CG_TOD, BASIC_TYP);
        case UTIL_KW_DATE_AND_TIME: CHKTYPE(CG_DT, BASIC_TYP);
        case UTIL_KW_DT:            CHKTYPE(CG_DT, BASIC_TYP);
        case UTIL_KW_STRING:        CHKTYPE(CG_STRING, BASIC_TYP);
        case UTIL_KW_WSTRING:       CHKTYPE(CG_WSTRING, BASIC_TYP);
        case UTIL_KW_TIME:          CHKTYPE(CG_TIME, BASIC_TYP);
        case UTIL_KW_BOOL:          CHKTYPE(CG_BOOL, BASIC_TYP);
        case UTIL_KW_BYTE:          CHKTYPE(CG_BYTE, BASIC_TYP);
        case UTIL_KW_WORD:          CHKTYPE(CG_WORD, BASIC_TYP);
        case UTIL_KW_DWORD:         CHKTYPE(CG_DWORD, BASIC_TYP);
        case UTIL_KW_LWORD:         CHKTYPE(CG_LWORD, BASIC_TYP);
        //qvt types  TODO add all even if not supported !
        case UTIL_KW_QVT_BOOL:      CHKTYPE(CG_QVT_BOOL, QVT_TYP);
        case UTIL_KW_QVT_BYTE:      CHKTYPE(CG_QVT_BYTE, QVT_TYP);
        case UTIL_KW_QVT_WORD:      CHKTYPE(CG_QVT_WORD, QVT_TYP);
        case UTIL_KW_QVT_DWORD:     CHKTYPE(CG_QVT_DWORD, QVT_TYP);
        case UTIL_KW_QVT_DINT:      CHKTYPE(CG_QVT_DINT, QVT_TYP);
        case UTIL_KW_QVT_LREAL:     CHKTYPE(CG_QVT_LREAL, QVT_TYP);
        case UTIL_KW_QVT_LINT:      CHKTYPE(CG_QVT_LINT, QVT_TYP);
        case UTIL_KW_QVT_LWORD:     CHKTYPE(CG_QVT_LWORD, QVT_TYP);
        case UTIL_KW_QVT_WSTRING:   CHKTYPE(CG_QVT_WSTRING, QVT_TYP);
        //any types
        case UTIL_KW_ANY:           CHKTYPE(CG_ANY, BASIC_TYP);
        case UTIL_KW_ANY_NUM:       CHKTYPE(CG_ANY_NUM, BASIC_TYP);
        case UTIL_KW_ANY_REAL:      CHKTYPE(CG_ANY_REAL, BASIC_TYP); 
        case UTIL_KW_ANY_INT:       CHKTYPE(CG_ANY_INT, BASIC_TYP);
        case UTIL_KW_ANY_BIT:       CHKTYPE(CG_ANY_BIT, BASIC_TYP);
        case UTIL_KW_ANY_STRING:    CHKTYPE(CG_ANY_STRING, BASIC_TYP);
        case UTIL_KW_ANY_DATE:      CHKTYPE(CG_ANY_DATE, BASIC_TYP);
        case UTIL_KW_ANY_ELEMENTARY:CHKTYPE(CG_ANY_ELEMENTARY, BASIC_TYP);
        case UTIL_KW_ANY_MAGNITUDE: CHKTYPE(CG_ANY_MAGNITUDE, BASIC_TYP);
        case UTIL_KW_ANY_DERIVED:   CHKTYPE(CG_ANY_DERIVED, BASIC_TYP);
#undef CHKTYPE

        //misc type decl:
        case UTIL_KW_AT:                    return AT;
        case UTIL_KW_ARRAY:                 return ARRAY;
        case UTIL_KW_EN:
        case UTIL_KW_ENO:
            //not supported msg now and return normal ids: 
            pContext->m_pdm->msg1(CG_E_NOT_SUPPORTED, pContext->getCurrEdp(), yytext);
            val->ident = new ST_Identifier_C(pContext->getCurrEdp(), pContext, yytext);
           return IDENTIFIER;

        case UTIL_KW_R_EDGE:                return R_EDGE;
        case UTIL_KW_F_EDGE:                return F_EDGE;

        //decl scopes:
        case UTIL_KW_VAR:                   return VAR;  
        case UTIL_KW_VAR_INPUT:             return VAR_INPUT;
        case UTIL_KW_VAR_OUTPUT:            return VAR_OUTPUT;
        case UTIL_KW_VAR_IN_OUT:            return VAR_IN_OUT;
        case UTIL_KW_VAR_EXTERNAL:          return VAR_EXTERNAL;
        case UTIL_KW_VAR_ACCESS:            return VAR_ACCESS;
        case UTIL_KW_VAR_GLOBAL:            return VAR_GLOBAL;    
        case UTIL_KW_VAR_TEMP:              return VAR_TEMP;
        case UTIL_KW_VAR_IN_EXT:            return VAR_IN_EXT;
        case UTIL_KW_END_VAR:    tok = END_VAR; goto PossibleEndHdr;
    
        case UTIL_KW_RETAIN:                return RETAIN;
        case UTIL_KW_NON_RETAIN:            return NON_RETAIN;
        case UTIL_KW_CONSTANT:              return CONSTANT;
        case UTIL_KW_VAR_CONFIG:            return VAR_CONFIG;

        case UTIL_KW_READ_ONLY:             
            //not supported msg now: 
            pContext->m_pdm->msg1(CG_E_NOT_SUPPORTED, pContext->getCurrEdp(), yytext);
            return READ_ONLY;
        case UTIL_KW_READ_WRITE:
            //not supported msg now: 
            pContext->m_pdm->msg1(CG_E_NOT_SUPPORTED, pContext->getCurrEdp(), yytext);
            return READ_WRITE;

        //SFC tokens:
        case UTIL_KW_STEP:                  return STEP;
        case UTIL_KW_END_STEP:              return END_STEP;
        case UTIL_KW_INITIAL_STEP:          return INITIAL_STEP;
        case UTIL_KW_TRANSITION:            return TRANSITION;
        case UTIL_KW_END_TRANSITION:        return END_TRANSITION;
        case UTIL_KW_ACTION:                return ACTION;
        case UTIL_KW_END_ACTION:            return END_ACTION;
        case UTIL_KW_FROM:                  return FROM;

        case UTIL_KW_IF:                    return IF; 
        case UTIL_KW_THEN:                  return THEN; 
        case UTIL_KW_ELSIF:                 return ELSIF; 
        case UTIL_KW_ELSE:                  return ELSE; 
        case UTIL_KW_END_IF:                return END_IF;

        case UTIL_KW_CASE:                  return CASE; 
        case UTIL_KW_OF:                    return OF; 
        case UTIL_KW_END_CASE:              return END_CASE;

        case UTIL_KW_WHILE:                 return WHILE; 
        case UTIL_KW_DO:                    return DO; 
        case UTIL_KW_END_WHILE:             return END_WHILE;

        case UTIL_KW_REPEAT:                return REPEAT; 
        case UTIL_KW_UNTIL:                 return UNTIL; 
        case UTIL_KW_END_REPEAT:            return END_REPEAT;

        case UTIL_KW_FOR:                   return FOR; 
        case UTIL_KW_TO:                    return TO; 
        case UTIL_KW_BY:                    return BY; 
        case UTIL_KW_END_FOR:               return END_FOR;

        case UTIL_KW_EXIT:                  return EXIT; 
        case UTIL_KW_RETURN:                return RETURN;
               
        //ATCM enhancements:
        case UTIL_KW_GOTO:                  return GOTO;
        case UTIL_KW_SYNCHRONIZED:          return SYNCHRONIZED;
        case UTIL_KW_END_SYNCHRONIZED:      return END_SYNCHRONIZED;
        case UTIL_KW_NATIVE:                return NATIVE;
        case UTIL_KW_VAR_NATIVE:            return VAR_NATIVE;
        case UTIL_KW_END_NATIVE:            return END_NATIVE;
        case UTIL_KW_CONST:                 return DECL_CONST;
        case UTIL_KW_END_CONST:       tok = DECL_END_CONST; goto PossibleEndHdr;
        case UTIL_KW_INLINE:                return KW_INLINE;
        case UTIL_KW_OVERLOAD:              return OVERLOAD;
        default: 
           assert(!"bad keyword enum");
        }
    }
    
    case ']':  goto PossibleEndHdr; //function return wstring[len']'

    //default: tokens <256 or token not valid in this grammer:
    default:
        return tok;
    }




CheckSupportedType:
    if(pContext->m_bDontCheckBackendSupportedTypes)
    {
        if((CG_FRONT_END_TYPES & ST_DTypesToTBS(basicType))==0)
        {
            pContext->m_pdm->errNS2(&val->edp, pContext->m_pdm->res1(CG_RES_STR_DATATYPE),
              ST_CG_DTYPES_ToString(basicType));
        }
    }
    else
    {
        if(!pContext->m_pFront->m_features.checkBasicType(ST_DTypesToTBS(basicType)))
        {
            pContext->m_pdm->errNS2(&val->edp, pContext->m_pdm->res1(CG_RES_STR_DATATYPE),
              ST_CG_DTYPES_ToString(basicType));
        }
    }

    val->btype = basicType;
   //fall through to HACK 

PossibleEndHdr: //HACK I'm still to stupid to do it any better...
    pContext->m_ulhdrEndTMP = UTIL_STS_GetFPosOfNextChar(pContext->m_pScanner);

    return tok;
}

void st_parse::yyerrorStackOverflow()
{
    pContext->m_pdm->msg0(CG_E_YACC_STACK, pContext->getCurrEdp());
}
void st_parse::yyerrorSyntax()
{
    if(yychar == SYS_COMMENT_BEGIN)
    {
        pContext->m_pdm->msg0(CG_E_MISPLACED_SYS_COMMENT, pContext->getCurrEdp());

        switch(UTIL_STS_SkipComment(pContext->m_pScanner, _T("*)")))
        {
        case 0:
            pContext->m_pdm->msg0(CG_E_EOF_IN_COMMENT, pContext->getCurrEdp());
        break;
        case 2:
            pContext->m_pdm->msg0(CG_W_NESTED_COMMENT, pContext->getCurrEdp());
        break;
        case 1:
        break;
        default:
            assert(!"bad enum");
        }
        yyclearin();
        return;
    }
    
    if(pContext->pSymtab && pContext->pSymtab->ulHdrBytes!=0)
    {
        switch(yychar)
        {
        case VAR: case VAR_INPUT: case VAR_OUTPUT: case VAR_IN_OUT:
        case VAR_EXTERNAL: case VAR_GLOBAL:
        case VAR_TEMP: case VAR_IN_EXT: case VAR_CONFIG:
        //TODO all header decl KWs
            pContext->m_pdm->msg1(CG_E_SYNTAX_UNEXPECTED,
             pContext->getCurrEdp(), pContext->m_pdm->res1(CG_RES_STR_ST12));
        return;    
        }
    }

    pContext->m_pdm->msg0(CG_E_SYNTAX, pContext->getCurrEdp());
}



void st_ParseContext::initTmpMembers()
{
    m_pFirstHeapElement = NULL;
    m_pLastHeapElement = NULL;

    m_errCountBeginFile = 0;

    m_pFront = NULL;
    m_pyacc   = NULL;
	m_pScanner= NULL;


    CG_InitCMDLEdipos(&m_currEdp);
    m_srcType = CG_SRC_TYPE_UNDEF;
    m_ftLastWrite = 0;
    m_pszFile     = NULL;
    m_pLibCtx     = NULL;
    m_pSysCommentTMP = NULL;
    m_typeorTMP      = CG_TBS_EMPTY;
    m_typeorRetTMP   = CG_TBS_EMPTY;

    m_bDontCheckBackendSupportedTypes = false;
    m_currDeclScope = CG_DECLSCOPE_UNDEF;
    m_currDeclBitSet = 0;
    m_pCurrTaskList = NULL;
    //##AC m_pCurrFBICall = NULL;

    m_pResource = NULL;
    m_pConfig   = NULL;

    m_pSFC = NULL;
    m_pBody = NULL;
    m_pbt   = NULL;
    pSymtab = NULL;
    m_pSymtabPrv = NULL;
    assert(m_Tasks.getUsed()==0);

    m_startToken = 0;
    m_lLineOffset= 0;
    m_lColOffset= 0;
    m_pSingleExpression = NULL;
    m_pSTAction = NULL;


    //assert(m_addrExpansionResult.resetUsed());
    m_bDeclSecHasAddr = false;
}

st_ParseContext::st_ParseContext(CG_CIECFront* pFront)
{
    int result;

    initTmpMembers();

    m_pFront = pFront;
    m_pdm    = pFront->m_pdm;
    m_pyacc  = new st_parse(&result, 300);//TODO must use stack size 300
                                          //due to TODO with elsif solution 
    m_pScanner = UTIL_STS_CreateScanner();
    if(!(m_pyacc && m_pScanner && (result==0 || result==1)))
    {
        CGT_IERR(m_pdm, _T("create parser failed"));
        return;
    }

    //set the context for the parser: 
    m_pyacc->setParseContext(this);
    m_IlContext.m_pSTContext = this;
}

st_ParseContext::~st_ParseContext()
{
    if(m_pScanner)
        UTIL_STS_DeleteScanner(m_pScanner);
    delete(m_pyacc);

    //check error and cleanup handling:
    assert(!m_pszFile && !m_ftLastWrite);
    assert(!m_pResource && !m_pConfig && !m_pSymtabPrv);
    assert(!m_pCurrTaskList /*##AC*/ && 
           !m_pSysCommentTMP);
    assert(!m_pSingleExpression);
    assert(!m_pSTAction);
    assert(!m_pFirstHeapElement);
    assert(!m_pSFC && !m_pBody && !m_pbt);
}

 
ST_CSymtabPrv* st_ParseContext::parseHeader(
    const TCHAR*         pszFileName,//used for initial edipos
    const CG_LIBContext* pLibCtx,    //!=NULL if from lib 
    const TCHAR*         pszText,    //text, either a complete file or 
                                     //a 4gr header part or from a lib a .hdr
    unsigned             ulsize,     //size in TCHARs without 
                                     //the terminating 0
    __int64              ftLastWrite //file time of file to parse
)
{
    ST_CSymtabPrv* pRet;
    
   
    //remember the tot err count at begin of file (only for assertions..)
    m_errCountBeginFile = m_pFront->m_pdm->getTotalErrors();    

    //should be false anyway (we have one instace of the parser per POU)
    //but be safe:
    m_bDontCheckBackendSupportedTypes = false;

    //make pszFileName a global string:
    assert(!m_pszFile);
    m_pszFile = m_pFront->registerString(pszFileName);
    CG_InitSTEdipos(&m_currEdp, m_pszFile);
    m_lLineOffset = m_lColOffset = 0;

    m_pLibCtx   = pLibCtx;
    m_ftLastWrite = ftLastWrite;

    m_srcType  = m_pFront->m_kad.getSourceTypeByExt(FC_StringGetFileExt(pszFileName));

    assert(m_startToken==0);
    
    switch(m_srcType)
    {
    case CG_SRC_TYPE_CST:
        //create now, is ok even if file is empty.
        //empty file yields an empty symtab not an error:
        newSymtab(&m_currEdp, CG_POU_CST, m_pszFile);
        //set start token needed to reduce syntax freedom:
        m_startToken = GVLCST_START;
    break;
    case CG_SRC_TYPE_GVL:
        //create now, is ok even if file is empty.
        //empty file yields an empty symtab not an error:
        newSymtab(&m_currEdp, CG_POU_GVL, m_pszFile);

        //set start token needed to reduce syntax freedom:
        m_startToken = GVLCST_START;
    break;
    case CG_SRC_TYPE_SDT:
    case CG_SRC_TYPE_ST:
    case CG_SRC_TYPE_IL:
    break;
    case CG_SRC_TYPE_4GR:
    case CG_SRC_TYPE_HDR:
        m_startToken = HDRFILE_START;
    break;
    default:
        assert(!"bad file type for parseAnyHeader");
    }
    
    UTIL_STS_SetInputString(m_pScanner, pszText, ulsize);
    
    
    assert(!m_pBody);
    m_pyacc->yyreset();
    m_pyacc->yyparse();

    //cannot happen even if syntax error:
    assert(!m_pResource && !m_pCurrTaskList);
    assert(!m_pSFC && !m_pBody /*##AC*/);


    if(getErrorsInFile()==0)
    {
        assert(!m_pSysCommentTMP);
        assert(pSymtab->flags & CG_STAB_HDR_NOERR);
    }
    else
    {
        //only set to NULL, memory is freed in next for loop !
        m_pCurrTaskList = NULL;
        m_pSysCommentTMP= NULL;
        //##AC m_pCurrFBICall  = NULL;
        
        //clean up lost parse tree elements:
        while(m_pFirstHeapElement)
            delete(m_pFirstHeapElement);
    }

    pRet = m_pSymtabPrv;
    m_pSymtabPrv  = NULL;
    m_ftLastWrite = 0;
    m_pszFile     = NULL;

    return pRet;
}


ST_CSymtabPrv* st_ParseContext::parseWholeSTFile(
    const TCHAR*         pszFileName,//used for initial edipos, 
    const CG_LIBContext* pLibCtx,    //!=NULL if from lib 
    const TCHAR*         pszText,    //text, either a complete file or 
                                     //a 4gr header part or from a lib a .hdr
    unsigned             ulsize,     //size in TCHARs without the 
                                     //terminating 0
    ST_CBody**           ppBody,     //the body to be returned
    __int64              ftLastWrite,//file time of file to parse
    ST_CSymtabPrv*       pSymOld     //!=NULL if load body after only hdr was loaded
)
{
    ST_CSymtabPrv* pRet;
   
    //remember the tot err count at begin of file (only for assertions..)
    m_errCountBeginFile = m_pFront->m_pdm->getTotalErrors();
    
    //should be false anyway (we have one instace of the parser per POU)
    //but be safe:
    m_bDontCheckBackendSupportedTypes = false;

    //make pszFileName a global string:
    assert(!m_pszFile);
    m_pszFile = m_pFront->registerString(pszFileName);
    CG_InitSTEdipos(&m_currEdp, m_pszFile);
    m_lLineOffset = m_lColOffset = 0;

    m_pLibCtx = pLibCtx;
    m_ftLastWrite = ftLastWrite;

    m_srcType  = m_pFront->m_kad.getSourceTypeByExt(FC_StringGetFileExt(pszFileName));

    assert(m_srcType==CG_SRC_TYPE_ST);


    if(pSymOld)
    {   //set symtab to old one and skip the header using a start token:
        m_startToken = BODY_START;
        m_pSymtabPrv = pSymOld;
        pSymtab      = pSymOld->getCGSym();
        
        assert(pSymtab->ulHdrBytes>0 && pSymtab->ulHdrBytes<ulsize);
        UTIL_STS_SetInputStringEx(m_pScanner, pszText, ulsize, pSymtab->ulHdrBytes);
    }
    else
    {
        UTIL_STS_SetInputString(m_pScanner, pszText, ulsize);
    }
    
    assert(!m_pBody && !m_pbt);
    m_pBody = new ST_CBody();
    m_pbt   = new ST_CBodyTMP();

    m_pyacc->yyreset();
    m_pyacc->yyparse();

    //cannot happen even if syntax error:
    assert(!m_pResource && !m_pCurrTaskList);

    if(getErrorsInFile()==0)
    {
        assert(!m_pSysCommentTMP && /*##AC*/ !m_pSFC);
        assert(this->m_pSymtabPrv);//must now exist!
    }
    else
    {
        delete(m_pSFC);
        m_pSFC = NULL;

        //only set to NULL, memory is freed in next for loop !
        m_pCurrTaskList  = NULL;
        m_pSysCommentTMP = NULL;
        //##AC m_pCurrFBICall   = NULL;
        
        //delete body if any error but not the symtab:
        delete(m_pBody);
        m_pBody = NULL;
              
        //clean up lost parse tree elements:
        while(m_pFirstHeapElement)
            delete(m_pFirstHeapElement);
    }

    pRet = m_pSymtabPrv;
    m_pSymtabPrv = NULL;

    *ppBody       = m_pBody;
    m_pBody       = NULL;
    m_ftLastWrite = 0;
    m_pszFile     = NULL;
    delete(m_pbt);
    m_pbt         = NULL;    

    return pRet;
}

ST_CSymtabPrv* st_ParseContext::parseWholeILFile(
    const TCHAR*         pszFileName,//used for initial edipos, 
    const CG_LIBContext* pLibCtx,    //!=NULL if from lib 
    const TCHAR*         pszText,    //text, either a complete file or 
                                     //a 4gr header part or from a lib a .hdr
    unsigned             ulsize,     //size in TCHARs without the 
                                     //terminating 0
    ST_CBody**           ppBody,     //the body to be returned
    __int64              ftLastWrite,//file time of file to parse
    ST_CSymtabPrv*       pSymOld     //!=NULL if load body after only hdr was loaded
)
{
    ST_CSymtabPrv* pRet;
 
    //remember the tot err count at begin of file (only for assertions..)
    m_errCountBeginFile = m_pFront->m_pdm->getTotalErrors();
    
    //should be false anyway (we have one instace of the parser per POU)
    //but be safe:
    m_bDontCheckBackendSupportedTypes = false;

    //make pszFileName a global string:
    assert(!m_pszFile);
    m_pszFile = m_pFront->registerString(pszFileName);
    CG_InitSTEdipos(&m_currEdp, m_pszFile);
    m_lLineOffset = m_lColOffset = 0;

    m_pLibCtx = pLibCtx;
    m_ftLastWrite = ftLastWrite;

    m_srcType  = m_pFront->m_kad.getSourceTypeByExt(FC_StringGetFileExt(pszFileName));

    assert(m_srcType==CG_SRC_TYPE_IL);


    if(pSymOld)
    {   //set symtab to old one and skip the header using a start token:
        m_startToken = IL_BODY_START;
        m_pSymtabPrv = pSymOld;
        pSymtab      = pSymOld->getCGSym();
        
        assert(pSymtab->ulHdrBytes>0 && pSymtab->ulHdrBytes<ulsize);
        UTIL_STS_SetInputStringEx(m_pScanner, pszText, ulsize, pSymtab->ulHdrBytes);
    }
    else
    {
        UTIL_STS_SetInputString(m_pScanner, pszText, ulsize);
    }
    
    assert(!m_pBody && !m_pbt);
    m_pBody = new ST_CBody();
    m_pbt   = new ST_CBodyTMP();

    m_pyacc->yyreset();
    m_pyacc->yyparse();

    //cannot happen even if syntax error:
    assert(!m_pResource && !m_pCurrTaskList);

    if(getErrorsInFile()==0)
    {
        assert(!m_pSysCommentTMP && !m_pSFC);
        assert(this->m_pSymtabPrv);//must now exist!
    }
    else
    {
        delete(m_pSFC);
        m_pSFC = NULL;

        //only set to NULL, memory is freed in next for loop !
        m_pCurrTaskList  = NULL;
        m_pSysCommentTMP = NULL;
        
        //delete body if any error but not the symtab:
        delete(m_pBody);
        m_pBody = NULL;
              
        //clean up lost parse tree elements:
        while(m_pFirstHeapElement)
            delete(m_pFirstHeapElement);
    }

    pRet = m_pSymtabPrv;
    m_pSymtabPrv = NULL;

    *ppBody       = m_pBody;
    m_pBody       = NULL;
    m_ftLastWrite = 0;
    m_pszFile     = NULL;
    delete(m_pbt);
    m_pbt         = NULL;    

    return pRet;
}


ST_CSymtabPrv* st_ParseContext::parse4GRFile(
    const TCHAR*          pszFileName,//used for initial edipos, 
    const CG_LIBContext*  pLibCtx,    //!=NULL if from lib 
    const TCHAR*          pszText,    //text, a complete ST file
    unsigned              ulsize,     //size in TCHARs without the 
                                      //terminating 0
    SFC_LDFBD_SignalHash& grElements, //full 4gr body also if SFC,FBD,LD
    ST_CBody**            ppBody,     //the body to be returned
    __int64               ftLastWrite,//file time of file to parse
    ST_CSymtabPrv*        pSymOld,    //!=NULL if load body after only hdr was loaded
    long                  codeGenOpt  //CG_LOADBDY_* bits
)
{
    ST_CSymtabPrv* pRet;
   
    //remember the tot err count at begin of file (only for assertions..)
    m_errCountBeginFile = m_pFront->m_pdm->getTotalErrors();    

    //should be false anyway (we have one instace of the parser per POU)
    //but be safe:
    m_bDontCheckBackendSupportedTypes = false;

    //make pszFileName a global string:
    assert(!m_pszFile);
    m_pszFile = m_pFront->registerString(pszFileName);
    CG_InitSTEdipos(&m_currEdp, m_pszFile);

    m_pLibCtx = pLibCtx;
    m_ftLastWrite = ftLastWrite;

    m_srcType  = m_pFront->m_kad.getSourceTypeByExt(FC_StringGetFileExt(pszFileName));
    assert(m_srcType==CG_SRC_TYPE_4GR);


    if(pSymOld)
    {
        m_pSymtabPrv = pSymOld;
        pSymtab      = pSymOld->getCGSym();
        assert(pSymtab->flags & CG_STAB_HDR_NOERR);
    }
    else
    {
        //parse the header part:
        m_startToken = HDRFILE_START;
        UTIL_STS_SetInputString(m_pScanner, pszText, ulsize);
        m_pyacc->yyreset();
        m_pyacc->yyparse();
   
        //cannot happen even if syntax error:
        assert(!m_pResource && !m_pCurrTaskList);
        assert(!m_pSFC && !m_pBody);

        if(getErrorsInFile()==0)
        {
            assert(this->m_pSymtabPrv);//must now exist!
            assert(!m_pSysCommentTMP &&  !m_pSFC && !m_pBody);
        }
        else
        {
            //only set to NULL, memory is freed in next for loop !
            m_pCurrTaskList  = NULL;
            m_pSysCommentTMP = NULL;
        
            //clean up lost parse tree elements:
            while(m_pFirstHeapElement)
                delete(m_pFirstHeapElement);
        }
    }


    if(getErrorsInFile()==0)
    {
        //header has 0 errors and XML of body could be 
        //loaded too, now check the graphics:
        assert(!m_pBody && !m_pbt);
        m_pBody = new ST_CBody();
        m_pbt   = new ST_CBodyTMP();

        assert(pSymtab->flags & CG_STAB_HDR_NOERR);
        ST_LDFBD_To_CBody(this, grElements, codeGenOpt);

        //should not happen since parse expr/trans/action
        //must clean up on their onw.
        assert(!m_pFirstHeapElement);

        
        //end of pou edipos for graphic languages:
        CG_Edipos edp;
        memset(&edp, 0, sizeof(edp));
        edp.pszFile = m_pszFile;
        edp.typ = CG_EDP_4GR_END;
        endOfPou(&edp, CG_POUTYP_UNDEF);
    }

    if(getErrorsInFile()!=0)
    {
        delete(m_pBody);
        m_pBody = NULL;    
    }

    pRet = m_pSymtabPrv;
    m_pSymtabPrv = NULL;

    *ppBody       = m_pBody;
    m_pBody       = NULL;
    m_ftLastWrite = 0;
    m_pszFile     = NULL;
    delete(m_pbt);
    m_pbt         = NULL;    

    return pRet;
}

ST_Expression_C* st_ParseContext::parse4GRBox( //use only after call parse4GRFile
  const CG_Edipos* pEdp,     //must not be NULL
  const TCHAR*     pszExpr,  //expression as string, should not have newlines.
  bool             bNoWarns  //if true no warnings, usefull for reparse same expr. 
)
{
    ST_Expression_C* pExpr = NULL;
    int errCountBegin = getErrorsInFile();

    assert(!m_pSingleExpression && !m_pSTAction && m_pSymtabPrv);
    assert(m_pszFile && m_ftLastWrite && m_pBody);

    //should be false anyway (we have one instace of the parser per POU)
    //but be safe:
    m_bDontCheckBackendSupportedTypes = false;

    m_currEdp   = *pEdp;
    m_lLineOffset = m_lColOffset = 0;
    m_startToken = EXPR_START;
    
    UTIL_STS_SetInputString(m_pScanner, pszExpr, _tcslen(pszExpr));

    if(bNoWarns)
        m_pdm->disableWarnings();
    //do the work:
    m_pyacc->yyreset();
    m_pyacc->yyparse();

    if(bNoWarns)
        m_pdm->enableWarnings();

    if(errCountBegin==getErrorsInFile())
    {
        assert(!m_pSysCommentTMP /*##AC*/);
        assert(m_pSingleExpression);//must now exist!
        
        //Detach now, the caller is responsible for pExpr:
        if(m_pSingleExpression)
        {
            m_pSingleExpression->Detach();
            pExpr = m_pSingleExpression;
            m_pSingleExpression = NULL;
        }
    }
    else
    {
        //only set to NULL, memory is freed in next for loop !
        //##AC m_pCurrFBICall   = NULL;
        delete(m_pSingleExpression);
        m_pSingleExpression = NULL;
        //clean up lost parse tree elements:
        while(m_pFirstHeapElement)
            delete(m_pFirstHeapElement);
    }

    //reset the start token:
    m_startToken = 0;
    return pExpr;
}



CG_STStmt* st_ParseContext::parseSTAction( //use only after call parse4GRFile
    const CG_Edipos* pEdp,     //must not be NULL
    const TCHAR*     pszAction,//ST action text as string
    bool             bNoWarns  //if true no warnings, usefull for reparse same expr. 
)
{
    CG_STStmt*  pSTAction;
    int         errCountBegin = getErrorsInFile();

    assert(!m_pSingleExpression && m_pSymtabPrv && !m_pSTAction);
    assert(m_pszFile && m_ftLastWrite && m_pBody);

    //should be false anyway (we have one instace of the parser per POU)
    //but be safe:
    m_bDontCheckBackendSupportedTypes = false;

    //edipos special handling:
    assert(pEdp->typ == CG_EDP_4GR_BOX && pEdp->gr.l==0 && pEdp->gr.c==0);
    m_currEdp = *pEdp;
    m_lLineOffset = m_lColOffset = 0;

    //patch the m_curredp to be a st-box, then st_ParseContext::setCurrEdp
    //will update the m_currEdp.gr.l and m_currEdp.gr.c members: 
    m_currEdp.typ = CG_EDP_4GR_STBOX;


    m_startToken = STACTION_START;
   
    UTIL_STS_SetInputString(m_pScanner, pszAction, _tcslen(pszAction));

    if(bNoWarns)
        m_pdm->disableWarnings();
    //do the work:
    m_pyacc->yyreset();
    m_pyacc->yyparse();

    if(bNoWarns)
        m_pdm->enableWarnings();

    assert(!m_pSingleExpression);
    if(errCountBegin==getErrorsInFile())
    {
        pSTAction = m_pSTAction;
        //can happen if empty action: assert(pSTAction);
    }
    else
    {
        pSTAction = NULL;
        //only set to NULL, memory is freed in next for loop !
        //##AC m_pCurrFBICall   = NULL;
        //clean up lost parse tree elements:
        while(m_pFirstHeapElement)
            delete(m_pFirstHeapElement);
    }

    //reset the start token:
    m_startToken = 0;
    m_pSTAction = NULL;
    
    return pSTAction;
}






ST_CConfig* st_ParseContext::parseConfiguration(
    const TCHAR*     pszFileName,//used for initial edipos, 
    const TCHAR*     pszText,    //a complete .res file
    unsigned         ulsize,     //size in TCHARs without the 
                                 //terminating 0
    __int64          ftLastWrite //file time of file to parse
)
{
    ST_CConfig* pCon;

    //remember the tot err count at begin of file (only for assertions..)
    m_errCountBeginFile = m_pFront->m_pdm->getTotalErrors();    

    //should be false anyway (we have one instace of the parser per POU)
    //but be safe:
    m_bDontCheckBackendSupportedTypes = false;

    //make pszFileName a global string:
    assert(!m_pszFile);
    m_ftLastWrite = ftLastWrite;
    m_pszFile = m_pFront->registerString(pszFileName);
    CG_InitSTEdipos(&m_currEdp, m_pszFile);
    m_lLineOffset = m_lColOffset = 0;

    m_srcType  = m_pFront->m_kad.getSourceTypeByExt(FC_StringGetFileExt(pszFileName));
    assert(m_srcType==CG_SRC_TYPE_CON); 
    
    UTIL_STS_SetInputString(m_pScanner, pszText, ulsize);
    m_pyacc->yyreset();
    m_pyacc->yyparse();

    //cannot happen even if syntax error:
    assert(!m_pSFC && !m_pBody /*##AC*/ && 
           !m_pCurrTaskList && !m_pSymtabPrv);

    
    if(getErrorsInFile()==0)
    {
        assert(!m_pSysCommentTMP);
        assert(m_pConfig);//must now exist!
    }
    else
    {
        //only set to NULL, memory is freed in next for loop !
        m_pSysCommentTMP = NULL;
        //clean up lost parse tree elements:
        while(m_pFirstHeapElement)
            delete(m_pFirstHeapElement);

        delete(m_pConfig);
        m_pConfig = NULL;
    }

    pCon = m_pConfig;
    m_pConfig = NULL;
    m_pszFile = NULL;
    m_ftLastWrite = 0;

    return pCon;
}



CG_Resource* st_ParseContext::parseResource(
    const TCHAR*     pszFileName,//used for initial edipos, 
    const TCHAR*     pszText,    //a complete .res file
    unsigned         ulsize,     //size in TCHARs without the 
                                 //terminating 0
    ST_CSymtabPrv**  ppSymPrvNew, //OUT: if 0 errors the glob var table
    __int64          ftLastWrite
)
{
    CG_Resource* pRet;

    //remember the tot err count at begin of file (only for assertions..)
    m_errCountBeginFile = m_pFront->m_pdm->getTotalErrors();    

    //should be false anyway (we have one instace of the parser per POU)
    //but be safe:
    m_bDontCheckBackendSupportedTypes = false;

    //make pszFileName a global string:
    assert(!m_pszFile);
    m_ftLastWrite = ftLastWrite;
    m_pszFile = m_pFront->registerString(pszFileName);
    CG_InitSTEdipos(&m_currEdp, m_pszFile);
    m_lLineOffset = m_lColOffset = 0;

    m_srcType  = m_pFront->m_kad.getSourceTypeByExt(FC_StringGetFileExt(pszFileName));

    assert(m_srcType==CG_SRC_TYPE_RES); 
    
    UTIL_STS_SetInputString(m_pScanner, pszText, ulsize);
    m_pyacc->yyreset();
    m_pyacc->yyparse();

    //cannot happen even if syntax error:
    assert(!m_pSFC && !m_pBody /*##AC*/);

    
    if(getErrorsInFile()==0)
    {
        assert(!m_pSysCommentTMP);
        assert(!m_pCurrTaskList); //must have been deleted
        assert(m_pSymtabPrv && m_pResource);//must now exist!
        assert(m_pResource->pGVL == pSymtab);

        // set the no error flag:
        assert(!m_pResource->bNoError);
        m_pResource->bNoError = true;
    }
    else
    {
        //only set to NULL, memory is freed in next for loop !
        m_pCurrTaskList  = NULL;
        m_pSysCommentTMP = NULL;
        //##AC m_pCurrFBICall   = NULL;

        //clean up lost parse tree elements:
        while(m_pFirstHeapElement)
            delete(m_pFirstHeapElement);
        
        //return the resource even if error but assert:
        assert(!m_pResource || !m_pResource->bNoError);
    }

    pRet = m_pResource;
    *ppSymPrvNew = m_pSymtabPrv;
    m_pResource = NULL;
    m_pSymtabPrv = NULL;
    m_pszFile = NULL;
    m_ftLastWrite = 0;

    return pRet;
}


ST_Expression_C* st_ParseContext::parseSingleExpression(
  const CG_Edipos* pEdp,     //must not be NULL
  bool             bIncCol,  //pEdp's line,column info is updated for every diag msg
  const TCHAR*     pszExpr,  //expression as string, should not have newlines.
  ST_CSymtabPrv*   pSymPrv,  //may be NULL, if only constant expr. should be evaluated.
  bool             bNoWarns  //if true no warnings, usefull for reparse same expr. 
)
{
    ST_Expression_C* pExpr = NULL;
    assert(pszExpr);

    //should be false anyway (we have one instace of the parser per POU)
    //but be safe:
    m_bDontCheckBackendSupportedTypes = false;
    
    assert(!m_pSingleExpression);
    assert(!m_pszFile && !m_ftLastWrite && !m_pSFC);
    if(pEdp->pszFile)
        m_pszFile = m_pFront->registerString(pEdp->pszFile);

    m_errCountBeginFile = m_pFront->m_pdm->getTotalErrors();
    m_currEdp   = *pEdp;
    if(bIncCol && m_currEdp.typ==CG_EDP_ST)
    {
        m_lLineOffset = m_currEdp.lc.l - 1; //-1 because UTIL_STS_NextToken return 1 based line,col 
        m_lColOffset  = m_currEdp.lc.c - 1;
    }
    else if(bIncCol && m_currEdp.typ==CG_EDP_4GR_STBOX)
    {
        m_lLineOffset = m_currEdp.gr.l - 1;
        m_lColOffset  = m_currEdp.gr.c - 1;
    }
    else
    {
        m_lLineOffset = m_lColOffset = 0;
    }
    m_startToken = EXPR_START;
    m_pSymtabPrv= pSymPrv;
    pSymtab     = pSymPrv ? pSymPrv->getCGSym() : NULL;
    
    UTIL_STS_SetInputString(m_pScanner, pszExpr, _tcslen(pszExpr));

    if(bNoWarns)
        m_pdm->disableWarnings();

    //do the work:
    m_pyacc->yyreset();
    m_pyacc->yyparse();

    if(bNoWarns)
        m_pdm->enableWarnings();

    if(getErrorsInFile()==0)
    {
        assert(!m_pSysCommentTMP /*##AC*/);
        assert(!m_pCurrTaskList); //must have been deleted
        assert(m_pSingleExpression);//must now exist!
        
        //Detach now, the caller is responsible for pExpr:
        if(m_pSingleExpression)
        {
            m_pSingleExpression->Detach();
            pExpr = m_pSingleExpression;
            m_pSingleExpression = NULL;
        }
    }
    else
    {
        //only set to NULL, memory is freed in next for loop !
        //##AC m_pCurrFBICall   = NULL;

        delete(m_pSingleExpression);
        m_pSingleExpression = NULL;

        //clean up lost parse tree elements:
        while(m_pFirstHeapElement)
            delete(m_pFirstHeapElement);
    }

    //reset at least the symtab variables:
    m_pSymtabPrv = NULL;
    pSymtab      = NULL;
    m_startToken = 0;
    m_pszFile  = NULL;

    return pExpr;
}

int il_ParseContext::getOperator(const TCHAR* pszToken)
{
    assert(pszToken && pszToken[0]);

    if(m_tokensafterCR != 1)
        return -1;

    switch(pszToken[0])
    {
        case _T('a'):
        case _T('A'):
            if(!strcmpi(pszToken, _T("ADD")))   return IL_OP_ADD;
            if(!strcmpi(pszToken, _T("AND")))   return IL_OP_AND;
            if(!strcmpi(pszToken, _T("ANDN")))  return IL_OP_ANDN;
            break;
        case _T('c'):
        case _T('C'):
            if(!strcmpi(pszToken, _T("CAL")))   return IL_OP_CAL;
            if(!strcmpi(pszToken, _T("CALC")))  return IL_OP_CALC;
            if(!strcmpi(pszToken, _T("CALCN"))) return IL_OP_CALCN;
            if(!strcmpi(pszToken, _T("CLK")))   return IL_OP_CLK;
            if(!strcmpi(pszToken, _T("CU")))    return IL_OP_CU;
            if(!strcmpi(pszToken, _T("CD")))    return IL_OP_CD;
            break;
        case _T('d'):
        case _T('D'):
            if(!strcmpi(pszToken, _T("DIV")))   return IL_OP_DIV;
            break;
        case _T('e'):
        case _T('E'):
            if(!strcmpi(pszToken, _T("EQ")))    return IL_OP_EQ;
            break;
        case _T('g'):
        case _T('G'):
            if(!strcmpi(pszToken, _T("GE")))    return IL_OP_GE;
            if(!strcmpi(pszToken, _T("GT")))    return IL_OP_GT;
            break;
        case _T('i'):
        case _T('I'):
            if(!strcmpi(pszToken, _T("IN")))    return IL_OP_IN;
            break;
        case _T('j'):
        case _T('J'):
            if(!strcmpi(pszToken, _T("JMP")))   return IL_OP_JMP;
            if(!strcmpi(pszToken, _T("JMPC")))  return IL_OP_JMPC;
            if(!strcmpi(pszToken, _T("JMPCN"))) return IL_OP_JMPCN;
            break;
        case _T('l'):
        case _T('L'):
            if(!strcmpi(pszToken, _T("LD")))    return IL_OP_LD;
            if(!strcmpi(pszToken, _T("LDN")))   return IL_OP_LDN;
            if(!strcmpi(pszToken, _T("LE")))    return IL_OP_LE;
            if(!strcmpi(pszToken, _T("LT")))    return IL_OP_LT;
            break;
        case _T('m'):
        case _T('M'):
            if(!strcmpi(pszToken, _T("MOD")))   return IL_OP_MOD;
            if(!strcmpi(pszToken, _T("MUL")))   return IL_OP_MUL;
            break;
        case _T('n'):
        case _T('N'):
            if(!strcmpi(pszToken, _T("NE")))    return IL_OP_NE;
            if(!strcmpi(pszToken, _T("NOT")))   return IL_OP_NOT;
            break;
        case _T('o'):
        case _T('O'):
            if(!strcmpi(pszToken, _T("OR")))    return IL_OP_OR;
            if(!strcmpi(pszToken, _T("ORN")))   return IL_OP_ORN;
            break;
        case _T('p'):
        case _T('P'):
            if(!strcmpi(pszToken, _T("PT")))    return IL_OP_PT;
            if(!strcmpi(pszToken, _T("PV")))    return IL_OP_PV;
            break;
        case _T('r'):
        case _T('R'):
            if(!strcmpi(pszToken, _T("R")))     return IL_OP_R;
            if(!strcmpi(pszToken, _T("R1")))    return IL_OP_R1;
            if(!strcmpi(pszToken, _T("RET")))   return IL_OP_RET;
            if(!strcmpi(pszToken, _T("RETC")))  return IL_OP_RETC;
            if(!strcmpi(pszToken, _T("RETCN"))) return IL_OP_RETCN;
            break;
        case _T('s'):
        case _T('S'):
            if(!strcmpi(pszToken, _T("S")))     return IL_OP_S;
            if(!strcmpi(pszToken, _T("S1")))    return IL_OP_S1;
            if(!strcmpi(pszToken, _T("ST")))    return IL_OP_ST;
            if(!strcmpi(pszToken, _T("STN")))   return IL_OP_STN;
            if(!strcmpi(pszToken, _T("SUB")))   return IL_OP_SUB;
            break;
        case _T('x'):
        case _T('X'):
            if(!strcmpi(pszToken, _T("XOR")))   return IL_OP_XOR;
            if(!strcmpi(pszToken, _T("XORN")))  return IL_OP_XORN;
            break;
        case _T(')'):
            if(!strcmpi(pszToken, _T(")")))     return IL_OP_RPAR;
            break;
        case _T('&'):
            if(!strcmpi(pszToken, _T("&")))     return IL_OP_AND;
            if(!strcmpi(pszToken, _T("&N")))    return IL_OP_ANDN;
            break;
    }
    return -1;
}



IL_OP il_ParseContext::getILOp(int op)
{
    switch(op)
    {
    case IL_OP_ADD:   return IL_ADD;   
    case IL_OP_AND:   return IL_AND;   
    case IL_OP_ANDN:  return IL_ANDN;  
    case IL_OP_CAL:   return IL_CAL;   
    case IL_OP_CALC:  return IL_CALC;  
    case IL_OP_CALCN: return IL_CALCN; 
    case IL_OP_CLK:   return IL_CLK;   
    case IL_OP_CU:    return IL_CU;    
    case IL_OP_CD:    return IL_CD;    
    case IL_OP_DIV:   return IL_DIV;   
    case IL_OP_EQ:    return IL_EQ;    
    case IL_OP_GE:    return IL_GE;    
    case IL_OP_GT:    return IL_GT;    
    case IL_OP_IN:    return IL_IN;    
    case IL_OP_JMP:   return IL_JMP;   
    case IL_OP_JMPC:  return IL_JMPC;  
    case IL_OP_JMPCN: return IL_JMPCN; 
    case IL_OP_LD:    return IL_LD;    
    case IL_OP_LDN:   return IL_LDN;   
    case IL_OP_LE:    return IL_LE;    
    case IL_OP_LT:    return IL_LT;    
    case IL_OP_MOD:   return IL_MOD;   
    case IL_OP_MUL:   return IL_MUL;   
    case IL_OP_NE:    return IL_NE;    
    case IL_OP_NOT:   return IL_NOT;   
    case IL_OP_OR:    return IL_OR;    
    case IL_OP_ORN:   return IL_ORN;   
    case IL_OP_PT:    return IL_PT;    
    case IL_OP_PV:    return IL_PV;    
    case IL_OP_R:     return IL_R;     
    case IL_OP_R1:    return IL_R1;    
    case IL_OP_RET:   return IL_RET;   
    case IL_OP_RETC:  return IL_RETC;  
    case IL_OP_RETCN: return IL_RETCN; 
    case IL_OP_S:     return IL_S;     
    case IL_OP_S1:    return IL_S1;    
    case IL_OP_ST:    return IL_ST;    
    case IL_OP_STN:   return IL_STN;   
    case IL_OP_SUB:   return IL_SUB;   
    case IL_OP_XOR:   return IL_XOR;   
    case IL_OP_XORN:  return IL_XORN;  
    case IL_OP_RPAR:  return IL_RPAR;
    }
    return IL_OP_UNDEF;
}

/*END yyreplace.pl: file st.cpp~ */
