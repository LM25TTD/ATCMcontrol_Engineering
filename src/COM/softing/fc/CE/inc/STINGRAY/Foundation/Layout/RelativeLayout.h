/////////////////////////////////////////////////////////////////////////////
// RelativeLayout.h : SFL Layout Manager
//
// Stingray Software Windows Template Library
// Copyright (C) 1999 RogueWave Software Inc,
// All rights reserved.
//
// Author:       Gilberto Araya
// Description:  SFL Layout Manager: Relative layout algorithm
//


#pragma once

#if !defined(_SFL)
#define _SFL
#endif

#ifndef _SFL_NO_PRAGMA_WARNINGS
	#if 1200 <= _MSC_VER
		#pragma warning(push,3)
	#endif
	#pragma warning(disable:4876)
	#pragma warning(disable:4284) // STL, not a UDT or reference to a UDT. Errors if infix notation used.
#endif

#include <map>
#include <list>
#include <foundation\Layout\LayoutNode.h>


namespace stingray {
namespace foundation {

// Disable the warning that complains about the symbols name length 
//#pragma warning(disable: 4786)

//@doc


//@enum ConstraintType |
// Types of constraints that can be applied to nodes
// in a Relative layout arrangement.
enum ConstraintType { 
	RelDefault	= 0,		//@emem Default constraint: no constraint.
	RelLeft,				//@emem Adjust node rectangle's left side
	RelRight,				//@emem Adjust node rectangle's right side
	RelTop,					//@emem Adjust node rectangle's top side
	RelBottom,				//@emem Adjust node rectangle's bottom side
	RelWidth,				//@emem Adjust node rectangle's width
	RelHeight,				//@emem Adjust node rectangle's height
	RelCenterHorizontal,	//@emem Center node rectangle with respect to width
	RelCenterVertical,		//@emem Center node rectangle with respect to height
	RelMoveLeft,			//@emem Move node rectangle, with respect to left
	RelMoveRight,			//@emem Move node rectangle, with respect to right
	RelMoveTop,				//@emem Move node rectangle, with respect to top
	RelMoveBottom			//@emem Move node rectangle, with respect to bottom
};


struct CRelativeConstraint
{
	// Node to which the constraint is applied
	ILayoutNode* pNodeFrom;

	// Type of constraint applied to m_pNodeFrom
	ConstraintType constraintFrom;

	// Position m_pNodeFrom relative to this node. Use NULL for absolute position.
	ILayoutNode* pNodeTo;

	// Target constraint for relatively positioned node.
	ConstraintType constraintTo;

	// Additive modifier applied to relative constraint
	int nAdditiveModifier;

	// Multiplicative modifier applied to relative constraint
	float fMultiplicativeModifier;

	CRelativeConstraint()
		: pNodeFrom(NULL), constraintFrom(RelDefault), pNodeTo(NULL), constraintTo(RelDefault),
		nAdditiveModifier(0), fMultiplicativeModifier(0)
	{}


	// Autogenerated copy constructor and assignment operator suffice for this particular structure
};



//@interface IRelativeLayout |
// Additional functionality required to implement a relative layout
// algorithm. Allows the programmer set constraints on the relative position
// of this node's children.
//@base public | ILayoutNode
interface __declspec(uuid("DBDB26B1-5195-11d3-9D94-00C04F91E286")) IRelativeLayout:
	public ILayoutNode
{
	//@meth,method bool | SetConstraint |
	// Defines a constraint on a child node of this node.
	//@@rdesc true if application of the constraint can be performed successfully, 
	// false otherwise.
	//@@parm ILayoutNode* | pNodeFrom | Node the constraint will be applied to.
	//@@parm ConstraintType | constraintFrom | Constraint to be applied against pNodeFrom. Takes a value from the <t ConstraintType> enumeration. 
	//@@parm ILayoutNode* | pNodeTo | Node relative to which the constraint will be applied.
	//@@parm ConstraintType | constraintTo | Constraint to be applied relative to pNodeTo. Takes a value from the <t ConstraintType> enumeration. Default is RelDefault.
	//@@parm int | nModifier | Additive modifier, usually used to indicate a positive or negative displacement. Default is 0.
	//@@parm float | fModifier | Multiplicative modifier, usually used to scale the effect of the constraint. Default is 1.0.
	/*@@ex 		
		This example says: "Set the left side of the node pSplitter to the right side of the pNameNode node plus 20 units." |
	    pRelative->SetConstraint(pSplitter, RelLeft, pNameNode, RelRight, 20);<nl>
	*/
	/*@@ex
		This example says: "Move (without resizing it) the node pOkNode, such that its bottom is 30 pixels up of the Root node bottom." |
		pRelative->SetConstraint(pOkNode, foundation::RelMoveBottom, pRootNode, foundation::RelBottom, -30);<nl>
	*/
	virtual bool SetConstraint(
			ILayoutNode* pNodeFrom, ConstraintType constraintFrom,
			ILayoutNode* pNodeTo, ConstraintType constraintTo = RelDefault,
			int nModifier = 0, float fModifier = 1.0) = 0;

	//@meth,method void | RemoveAllConstraints | 
	//  Remove all constraints that have been previously defined on this node.
	virtual void RemoveAllConstraints() = 0;
};



//@class CRelativeLayout |
/* 
   Implementation of the Relative layout algorithm.<nl>
   The Relative Layout allows a logical organization of layout nodes where the 
   arrangement of child windows is specified as a set of constraints which are 
   constructed using English-like semantics. For example:
	- "Set the left side of node 1 equal to the right side of node 2 plus 10 pixels," or 
	- "Set the bottom of node 1 to 25 percent of the height of node 2," or
	- "Move node 1 such that its bottom is equal to the top of node 2 - 10 pixels."
   Use the SetConstraint() method in the IRelativeLayout interface to specify the constraints 
   to be used by an object.
*/
//@base public | CLayoutNode<lt>IRelativeLayout<gt>
//@supint ILayoutNode | Basic layout node interface.
//@supint IRelativeLayout | Functionality specific to the Relative layout algorithm.
class __declspec(uuid("DBDB26B2-5195-11d3-9D94-00C04F91E286")) CRelativeLayout:
	public CLayoutNode<CRelativeLayout, IRelativeLayout>
{
public:
	// ILayoutNode interface
	virtual CRect OnRecalcLayout(const CRect& rcDesired,
								 bool bChildNegotiate, bool bStrictRecalc);

	// IRelativeLayout interface
	virtual bool SetConstraint(
			ILayoutNode* pNodeFrom, ConstraintType constraintFrom,
			ILayoutNode* pNodeTo, ConstraintType constraintTo = RelDefault,
			int nModifier = 0, float fModifier = 1.0);

	virtual void RemoveAllConstraints();


private:

	typedef std::map<ILayoutNode*, CRect> NodeRectMap;
	typedef std::list<CRelativeConstraint> ConstraintMap;
	ConstraintMap m_Constraints;


protected:
	// Relative layout implementation

	void ApplyAllConstraints(NodeRectMap& mapNodeRects);
	void ApplyConstraint(CRelativeConstraint& aConstr, CRect& rcFrom, CRect& rcTo);
	bool ApplyConstraintPosition(long& nRectPos, CRelativeConstraint& aConstr, CRect& rcTo); 
	bool ApplyConstraintSizing(long& nBoundStart, long& nBoundStop, CRelativeConstraint& aConstr, CRect& rcTo);
	bool ApplyConstraintCentering(long& nBoundStart, long& nBoundStop, long& nRectToBase,
									CRelativeConstraint& aConstr, CRect& rcTo);

	virtual CRelativeConstraint* FindConstraint(ILayoutNode* pNodeFrom, ConstraintType constraint);
	virtual void ResolveDefaultConstraints(ConstraintType& constraintFrom, ConstraintType& constraintTo);

	// Temp Node rectangle storage/utilization
	void GetNodeRects(NodeRectMap& mapNodeRects);
	CRect ApplyNodeRects(NodeRectMap& mapNodeRects, bool bChildNegotiate, bool bStrictRecalc);

};



};	// namespace stingray::foundation
};	// namespace stingray


#ifndef _SFL_NO_PRAGMA_WARNINGS
	#if 1200 <= _MSC_VER
		#pragma warning (pop)
	#endif
#endif