/*!!!!! this file has been generated using yyreplace.pl !!!!!*/
/* input files for yyreplace.pl: iecsyntax.l, iecsyntax.cpp~, iecsyntax.h~*/

/*START yyreplace.pl: include files and #yy_movetop lines from iecsyntax.l */
 #include <ctype.h>
 #include "assert.h"
 #ifndef UTIL_IMP
 #define UTIL_IMP    // declare as dllexports
 #endif
 #include "utilsts.h"
 #define FC_LIB_USE_CRT
 #include "fc_tools\fc_libmem.h"
 #pragma warning( disable : 4068 4102 4244)
 //foreward
 class UTIL_STS_scanner;
/*END yyreplace.pl: include files from iecsyntax.l */


/*START yyreplace.pl: file iecsyntax.h~ */
#ifndef yy_state_t
#define yy_state_t unsigned int
#endif
#define YYNEWLINE 10

// MKS LEX prototype scanner header
// Copyright 1991 by Mortice Kern Systems Inc.
// All rights reserved.

// You can define YY_PRESERVE to get System V UNIX lex compatibility,
//	if you need to change yytext[] in your user actions
// This is quite a bit slower, though, so the default is without

#include <stdio.h>		// uses printf(), et cetera
#include <stdarg.h>		// uses va_list
#include <stdlib.h>		// uses exit()
#include <string.h>		// uses memmove()

class iecsyntax_scan {
protected:
	yy_state_t * state;		// state buffer
	int	size;			// length of state buffer
	int	mustfree;		// set if space is allocated
	int	yy_end;			// end of pushback
	int	yy_start;		// start state
	int	yy_lastc;		// previous char
#ifdef YYEXIT
	int yyLexFatal;		// Lex Fatal Error Flag
#endif // YYEXIT
#ifndef YY_PRESERVE	// efficient default push-back scheme
	char save;		// saved yytext[yyleng]
#else			// slower push-back for yytext mungers
	char *save;		// saved yytext[]
	char *push;
#endif

public:
	char   *yytext;		// yytext text buffer
	FILE   *yyin;			// input stream
	FILE   *yyout;			// output stream
	int	yylineno;		// line number
	int	yyleng;			// yytext token length

	iecsyntax_scan(int = 100);	// constructor for this scanner
			// default token & pushback size is 100 bytes
	iecsyntax_scan(int, char*, char*, yy_state_t*);
				// constructor when tables are given

	~iecsyntax_scan();		// destructor

	int	yylex();		// begin a scan

	virtual int	yygetc() {	// scanner source of input characters
		return getc(yyin);
	}

	virtual int	yywrap() { return 1; }	// EOF processing

	virtual void	yyerror(char *,...);	// print error message

	virtual void	output(int c) { putc(c, yyout); }

#ifdef YYEXIT
	virtual void	YY_FATAL(char * msg) {	// print message and set error flag
		yyerror(msg); yyLexFatal = 1;
	}
#else // YYEXIT
	virtual void	YY_FATAL(char * msg) {	// print message and stop
		yyerror(msg); exit(1);
	}
#endif // YYEXIT
	virtual void	ECHO() {		// print matched input
		fputs((const char *) yytext, yyout);
	}
	int	input();		// user-callable get-input
	int	unput(int c);		// user-callable unput character
	void	yy_reset();		// reset scanner
	void	setinput(FILE * in) {		// switch input streams
		yyin = in;
	}
	void	setoutput(FILE * out) {	// switch output
		yyout = out;
	}
	void	NLSTATE() { yy_lastc = YYNEWLINE; }
	void	YY_INIT() {
		yy_start = 0;
		yyleng = yy_end = 0;
		yy_lastc = YYNEWLINE;
	}
	void	YY_USER() {		// set up yytext for user
#ifndef YY_PRESERVE
		save = yytext[yyleng];
#else
		size_t n = yy_end - yyleng;
		push = save+size - n;
		if (n > 0)
			memmove(push, yytext+yyleng, n);
#endif
		yytext[yyleng] = 0;
	}
	void YY_SCANNER() {		// set up yytext for scanner
#ifndef YY_PRESERVE
		yytext[yyleng] = save;
#else
		size_t n = save+size - push;
		if (n > 0)
			memmove(yytext+yyleng, push, n);
		yy_end = yyleng + n;
#endif
	}
	void	yyless(int n) {		// trim input to 'n' bytes
		if (n >= 0 && n <= yy_end) {
			YY_SCANNER();
			yyleng = n;
			YY_USER();
		}
	}
	void	yycomment(char *const mat); // skip comment input
	int	yymapch(int delim, int escape);	// map C escapes
} ;
/*END yyreplace.pl: file iecsyntax.h~ */
/*START yyreplace.pl: file iecsyntax.cpp~ */
/* lex -alTv -LC -P C:\ATCMControl_SDK\GenWork\GenDir.tmp\4Control_R\gentools\yylex.cpp -o iecsyntax.cpp~ -D iecsyntax.h~ iecsyntax.l */
#define INITIAL 0
const yy_endst = 419;
const yy_nxtmax = 3198;
#define YY_LA_SIZE 53

static unsigned int yy_la_act[] = {
 0, 45, 1, 45, 2, 45, 3, 45, 5, 45, 6, 45, 8, 45, 10, 45,
 12, 45, 15, 45, 16, 45, 18, 45, 19, 45, 20, 45, 21, 45, 22, 45,
 23, 45, 24, 45, 25, 45, 27, 45, 45, 42, 45, 42, 45, 42, 45, 42,
 45, 42, 45, 42, 45, 42, 45, 42, 45, 42, 45, 42, 45, 35, 45, 35,
 45, 35, 45, 35, 45, 42, 45, 41, 45, 42, 45, 42, 45, 43, 44, 45,
 45, 42, 42, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
 41, 41, 42, 42, 42, 36, 36, 36, 36, 35, 35, 35, 35, 35, 35, 35,
 35, 42, 42, 42, 35, 35, 35, 35, 35, 35, 42, 42, 42, 42, 42, 42,
 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
 42, 42, 42, 42, 42, 42, 42, 42, 38, 38, 38, 38, 37, 37, 42, 42,
 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
 42, 42, 42, 42, 42, 42, 34, 42, 42, 42, 42, 40, 40, 40, 40, 40,
 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
 40, 40, 40, 40, 40, 42, 39, 39, 39, 39, 42, 42, 42, 42, 42, 42,
 42, 42, 42, 42, 33, 42, 42, 42, 42, 42, 42, 42, 34, 33, 32, 31,
 30, 29, 28, 17, 26, 13, 11, 7, 9, 14, 4, 0
};

static unsigned char yy_look[] = {
 0
};

static int yy_final[] = {
 0, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28,
 30, 32, 34, 36, 38, 40, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59,
 61, 63, 65, 67, 69, 71, 73, 75, 77, 78, 80, 81, 82, 83, 84, 85,
 86, 86, 86, 86, 87, 88, 89, 89, 90, 91, 91, 91, 92, 93, 93, 94,
 94, 95, 96, 97, 98, 99, 100, 101, 101, 101, 101, 101, 101, 101, 102, 102,
 103, 103, 103, 104, 104, 105, 105, 106, 106, 107, 107, 108, 108, 109, 109, 110,
 111, 111, 112, 112, 113, 114, 115, 116, 116, 116, 117, 118, 119, 120, 120, 121,
 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 151, 152,
 152, 152, 152, 152, 152, 152, 152, 152, 152, 152, 152, 152, 152, 152, 152, 152,
 152, 152, 152, 152, 152, 153, 153, 154, 154, 155, 155, 156, 156, 156, 156, 156,
 156, 156, 156, 156, 157, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167,
 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 184,
 185, 186, 187, 187, 187, 187, 187, 187, 187, 188, 189, 190, 191, 192, 192, 192,
 192, 192, 192, 192, 192, 193, 194, 195, 196, 196, 196, 196, 196, 196, 197, 198,
 198, 198, 198, 199, 199, 199, 199, 199, 199, 199, 199, 200, 201, 202, 203, 203,
 203, 203, 203, 203, 203, 204, 205, 206, 206, 206, 206, 206, 206, 207, 207, 207,
 207, 207, 207, 208, 208, 208, 208, 208, 208, 208, 208, 209, 210, 211, 212, 212,
 212, 212, 212, 212, 212, 213, 213, 213, 213, 214, 214, 214, 214, 214, 214, 215,
 215, 215, 215, 215, 215, 216, 216, 216, 216, 216, 216, 217, 217, 217, 217, 217,
 217, 217, 217, 218, 219, 220, 221, 221, 221, 221, 221, 221, 221, 222, 222, 222,
 222, 223, 223, 223, 223, 224, 224, 224, 224, 225, 226, 227, 228, 229, 230, 230,
 230, 230, 230, 230, 230, 230, 230, 230, 231, 231, 232, 232, 233, 233, 234, 235,
 236, 237, 238, 239, 240, 241, 242, 243, 244, 246, 247, 248, 249, 250, 251, 252,
 252, 252, 252, 252, 252, 252, 253, 253, 253, 254, 254, 254, 254, 254, 254, 254,
 255, 255, 255, 255, 255, 256, 257, 257, 258, 258, 258, 259, 260, 261, 262, 263,
 264, 265, 266, 267
};
#ifndef yy_state_t
#define yy_state_t unsigned int
#endif

static yy_state_t yy_begin[] = {
 0, 0, 0
};

static yy_state_t yy_next[] = {
 42, 42, 42, 42, 42, 42, 42, 42, 42, 41, 40, 42, 42, 41, 42, 42,
 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
 41, 42, 20, 21, 42, 37, 5, 20, 15, 16, 3, 1, 12, 2, 11, 4,
 32, 33, 34, 32, 32, 32, 32, 32, 35, 32, 9, 10, 7, 6, 8, 42,
 42, 38, 22, 38, 27, 38, 24, 38, 38, 26, 38, 38, 29, 38, 38, 38,
 38, 38, 36, 25, 23, 30, 38, 31, 38, 38, 38, 13, 42, 14, 42, 39,
 42, 38, 22, 38, 28, 38, 24, 38, 38, 26, 38, 38, 29, 38, 38, 38,
 38, 38, 36, 25, 23, 30, 38, 31, 38, 38, 38, 17, 19, 18, 42, 42,
 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 50, 54, 68, 69, 70, 71,
 419, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 419, 68, 69, 70, 43,
 419, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 50, 48, 48, 49, 49,
 419, 419, 419, 419, 46, 419, 66, 50, 91, 67, 45, 45, 45, 45, 45, 45,
 45, 45, 45, 45, 54, 92, 92, 419, 96, 419, 419, 45, 45, 45, 45, 45,
 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
 45, 45, 45, 45, 45, 103, 419, 419, 91, 47, 96, 45, 45, 45, 45, 45,
 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
 45, 45, 45, 45, 45, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 419,
 103, 103, 100, 101, 102, 116, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
 94, 94, 100, 101, 102, 116, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 419, 103, 419, 117, 118, 93,
 119, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 419, 103, 117, 118, 53,
 119, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 50, 50, 419, 71, 419,
 88, 88, 88, 88, 88, 88, 88, 88, 54, 54, 52, 52, 52, 52, 52, 52,
 52, 52, 52, 52, 103, 120, 121, 419, 122, 103, 123, 52, 52, 52, 52, 52,
 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
 52, 52, 52, 52, 52, 120, 121, 143, 122, 53, 123, 52, 52, 52, 52, 52,
 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
 52, 52, 52, 52, 52, 57, 48, 58, 49, 419, 419, 419, 419, 419, 188, 143,
 103, 103, 419, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 95, 111, 124,
 125, 126, 103, 130, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55,
 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 419, 124,
 125, 126, 56, 130, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55,
 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 59, 59,
 59, 59, 59, 59, 59, 59, 59, 59, 103, 131, 132, 133, 134, 419, 135, 59,
 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
 59, 59, 59, 59, 59, 59, 59, 59, 59, 131, 132, 133, 134, 60, 135, 59,
 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
 59, 59, 59, 59, 59, 59, 59, 59, 59, 50, 50, 419, 419, 419, 419, 419,
 419, 419, 419, 419, 419, 419, 54, 54, 59, 59, 59, 59, 59, 59, 59, 59,
 59, 59, 419, 136, 137, 419, 350, 419, 182, 59, 59, 59, 59, 59, 59, 59,
 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
 59, 59, 59, 136, 137, 419, 419, 60, 182, 59, 59, 59, 59, 59, 59, 59,
 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
 59, 59, 59, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
 61, 61, 61, 61, 61, 62, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
 61, 61, 61, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
 63, 63, 63, 63, 63, 64, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
 63, 63, 63, 50, 419, 48, 371, 49, 350, 103, 383, 419, 419, 419, 405, 419,
 54, 419, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 406, 419, 407, 408,
 409, 410, 141, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 419, 419, 419,
 419, 47, 419, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 72, 184, 72,
 210, 411, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 76, 412, 75, 75,
 75, 75, 75, 75, 75, 75, 75, 75, 77, 77, 77, 77, 77, 77, 77, 77,
 77, 77, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 84, 84, 84, 84,
 84, 84, 84, 84, 84, 84, 419, 80, 183, 81, 413, 81, 368, 74, 82, 82,
 82, 82, 82, 82, 82, 82, 82, 82, 414, 416, 415, 417, 418, 419, 419, 87,
 419, 78, 419, 419, 419, 419, 419, 80, 183, 185, 76, 83, 86, 86, 86, 86,
 86, 86, 86, 86, 86, 86, 90, 90, 90, 90, 90, 90, 90, 90, 97, 97,
 97, 97, 97, 97, 97, 97, 97, 97, 419, 185, 186, 187, 189, 190, 191, 97,
 97, 97, 97, 97, 97, 419, 419, 419, 419, 419, 419, 85, 419, 419, 419, 192,
 193, 194, 195, 196, 197, 89, 419, 419, 419, 419, 186, 187, 189, 190, 191, 97,
 97, 97, 97, 97, 97, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 192,
 193, 194, 195, 196, 197, 198, 99, 99, 99, 99, 99, 99, 104, 419, 104, 419,
 419, 105, 106, 107, 105, 105, 105, 105, 105, 108, 105, 199, 419, 200, 201, 87,
 419, 202, 141, 203, 98, 198, 99, 99, 99, 99, 99, 99, 110, 110, 110, 110,
 110, 110, 110, 110, 110, 110, 419, 114, 204, 127, 205, 199, 113, 200, 201, 115,
 140, 202, 129, 203, 206, 228, 112, 128, 138, 144, 144, 144, 144, 144, 144, 144,
 144, 144, 144, 142, 419, 231, 139, 114, 204, 127, 205, 109, 113, 419, 419, 115,
 140, 419, 129, 250, 206, 229, 112, 128, 138, 148, 148, 148, 148, 148, 148, 148,
 148, 148, 148, 142, 147, 230, 139, 146, 146, 146, 146, 146, 146, 146, 146, 146,
 146, 151, 419, 251, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 152, 152,
 152, 152, 152, 152, 152, 152, 152, 152, 155, 419, 419, 154, 154, 154, 154, 154,
 154, 154, 154, 154, 154, 419, 145, 156, 156, 156, 156, 156, 156, 156, 156, 156,
 156, 419, 419, 149, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 159, 160,
 160, 160, 160, 160, 160, 160, 160, 160, 160, 419, 153, 162, 162, 162, 162, 162,
 162, 162, 162, 162, 162, 163, 164, 164, 164, 164, 164, 164, 164, 164, 164, 164,
 419, 419, 167, 157, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 168, 168,
 168, 168, 168, 168, 168, 168, 168, 168, 419, 419, 161, 170, 170, 170, 170, 170,
 170, 170, 170, 170, 170, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 419,
 419, 174, 419, 165, 173, 173, 173, 173, 173, 173, 173, 173, 173, 173, 175, 175,
 175, 175, 175, 175, 175, 175, 175, 175, 178, 210, 169, 177, 177, 177, 177, 177,
 177, 177, 177, 177, 177, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 419,
 141, 419, 253, 172, 181, 181, 181, 181, 181, 181, 181, 181, 181, 181, 261, 208,
 419, 419, 419, 419, 419, 209, 419, 282, 207, 285, 176, 419, 419, 322, 140, 419,
 419, 325, 252, 419, 419, 238, 138, 419, 419, 419, 419, 419, 419, 419, 262, 208,
 419, 142, 419, 180, 139, 209, 419, 283, 207, 284, 419, 419, 419, 323, 140, 419,
 419, 324, 419, 419, 211, 237, 138, 212, 212, 212, 212, 212, 212, 212, 212, 212,
 212, 142, 419, 215, 139, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 222,
 222, 222, 222, 222, 222, 222, 222, 222, 222, 216, 261, 349, 366, 217, 419, 367,
 369, 419, 218, 419, 419, 419, 419, 225, 220, 224, 224, 224, 224, 224, 224, 224,
 224, 224, 224, 419, 213, 419, 419, 419, 419, 216, 262, 349, 366, 217, 221, 367,
 369, 419, 219, 419, 419, 419, 227, 370, 220, 232, 232, 232, 232, 232, 232, 232,
 232, 232, 232, 419, 372, 419, 419, 419, 223, 234, 234, 234, 234, 234, 234, 234,
 234, 234, 234, 419, 419, 419, 226, 370, 236, 236, 236, 236, 236, 236, 236, 236,
 236, 236, 419, 419, 372, 241, 227, 240, 240, 240, 240, 240, 240, 240, 240, 240,
 240, 419, 419, 419, 419, 373, 419, 374, 233, 375, 376, 238, 244, 244, 244, 244,
 244, 244, 244, 244, 244, 244, 226, 235, 419, 247, 242, 246, 246, 246, 246, 246,
 246, 246, 246, 246, 246, 373, 239, 374, 379, 375, 376, 237, 254, 254, 254, 254,
 254, 254, 254, 254, 254, 254, 380, 419, 249, 419, 242, 243, 256, 256, 256, 256,
 256, 256, 256, 256, 256, 256, 381, 382, 379, 419, 245, 257, 257, 257, 257, 257,
 257, 257, 257, 257, 257, 419, 380, 419, 248, 249, 259, 259, 259, 259, 259, 259,
 259, 259, 259, 259, 419, 419, 381, 382, 386, 419, 419, 255, 259, 259, 259, 259,
 259, 259, 259, 259, 259, 259, 419, 387, 419, 248, 388, 389, 419, 260, 240, 240,
 240, 240, 240, 240, 240, 240, 240, 240, 386, 258, 264, 264, 264, 264, 264, 264,
 264, 264, 264, 264, 419, 419, 419, 387, 419, 419, 388, 389, 267, 260, 266, 266,
 266, 266, 266, 266, 266, 266, 266, 266, 270, 270, 270, 270, 270, 270, 270, 270,
 270, 270, 419, 390, 419, 419, 391, 419, 392, 263, 273, 268, 272, 272, 272, 272,
 272, 272, 272, 272, 272, 272, 419, 419, 419, 419, 419, 419, 419, 265, 419, 419,
 419, 419, 419, 390, 419, 419, 391, 269, 392, 395, 419, 268, 396, 397, 398, 274,
 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 279, 271, 278, 278, 278, 278,
 278, 278, 278, 278, 278, 278, 419, 419, 419, 395, 385, 419, 396, 397, 398, 274,
 419, 419, 419, 419, 419, 419, 399, 400, 384, 281, 419, 419, 419, 419, 419, 275,
 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 385, 277, 288, 288, 288, 288,
 288, 288, 288, 288, 288, 288, 399, 400, 384, 280, 289, 289, 289, 289, 289, 289,
 289, 289, 289, 289, 419, 419, 401, 402, 403, 281, 291, 291, 291, 291, 291, 291,
 291, 291, 291, 291, 419, 419, 419, 419, 404, 419, 419, 287, 291, 291, 291, 291,
 291, 291, 291, 291, 291, 291, 401, 402, 403, 280, 419, 419, 419, 292, 272, 272,
 272, 272, 272, 272, 272, 272, 272, 272, 404, 290, 293, 293, 293, 293, 293, 293,
 293, 293, 293, 293, 419, 419, 419, 419, 419, 419, 419, 419, 419, 292, 295, 295,
 295, 295, 295, 295, 295, 295, 295, 295, 298, 298, 298, 298, 298, 298, 298, 298,
 298, 298, 393, 419, 419, 419, 419, 419, 419, 394, 301, 296, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 377, 419, 419, 419, 419, 419, 419, 294, 419, 419,
 378, 419, 393, 419, 302, 419, 419, 297, 419, 394, 419, 296, 304, 304, 304, 304,
 304, 304, 304, 304, 304, 304, 377, 419, 419, 419, 419, 299, 419, 419, 419, 419,
 378, 419, 419, 307, 302, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 310,
 310, 310, 310, 310, 310, 310, 310, 310, 310, 419, 419, 303, 419, 419, 419, 419,
 419, 313, 308, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 419, 419, 419,
 419, 419, 419, 419, 305, 419, 419, 419, 419, 419, 419, 419, 419, 419, 309, 419,
 419, 419, 308, 419, 419, 419, 314, 316, 316, 316, 316, 316, 316, 316, 316, 316,
 316, 319, 311, 318, 318, 318, 318, 318, 318, 318, 318, 318, 318, 419, 419, 419,
 419, 419, 419, 419, 419, 419, 314, 419, 419, 419, 419, 419, 419, 419, 419, 419,
 321, 419, 419, 419, 419, 419, 315, 326, 326, 326, 326, 326, 326, 326, 326, 326,
 326, 419, 317, 328, 328, 328, 328, 328, 328, 328, 328, 328, 328, 419, 419, 419,
 320, 329, 329, 329, 329, 329, 329, 329, 329, 329, 329, 419, 419, 419, 419, 419,
 321, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 419, 419, 419, 419, 419,
 419, 419, 327, 331, 331, 331, 331, 331, 331, 331, 331, 331, 331, 419, 419, 419,
 320, 419, 419, 419, 332, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 419,
 330, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 419, 419, 419, 419, 419,
 419, 419, 419, 419, 332, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 337,
 337, 337, 337, 337, 337, 337, 337, 337, 337, 419, 419, 419, 419, 419, 419, 419,
 419, 419, 336, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 419, 419, 419,
 419, 419, 419, 419, 334, 419, 419, 419, 419, 419, 419, 340, 419, 419, 419, 419,
 419, 419, 336, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 419, 419, 419,
 419, 419, 338, 419, 419, 419, 419, 419, 419, 419, 419, 340, 343, 343, 343, 343,
 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343,
 344, 419, 419, 419, 345, 419, 419, 419, 419, 346, 419, 419, 419, 419, 419, 348,
 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 419, 342, 419, 419, 419, 419,
 344, 419, 419, 419, 345, 419, 419, 419, 419, 347, 419, 419, 419, 419, 419, 348,
 351, 351, 351, 351, 351, 351, 351, 351, 351, 351, 353, 353, 353, 353, 353, 353,
 353, 353, 353, 353, 354, 355, 355, 355, 355, 355, 355, 355, 355, 355, 355, 357,
 357, 357, 357, 357, 357, 357, 357, 357, 357, 358, 359, 359, 359, 359, 359, 359,
 359, 359, 359, 359, 419, 419, 419, 419, 362, 352, 361, 361, 361, 361, 361, 361,
 361, 361, 361, 361, 363, 363, 363, 363, 363, 363, 363, 363, 363, 363, 356, 365,
 365, 365, 365, 365, 365, 365, 365, 365, 365, 419, 419, 419, 419, 419, 419, 419,
 419, 419, 419, 419, 419, 419, 419, 419, 419, 360, 419, 419, 419, 419, 419, 419,
 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 364, 0

};

static yy_state_t yy_check[] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 51, 45, 36, 68, 69, 70,
 83, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 89, 36, 68, 69, 39,
 86, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 37, 37, 46, 37, 46,
 81, 72, 81, 72, 37, 74, 46, 62, 34, 46, 37, 37, 37, 37, 37, 37,
 37, 37, 37, 37, 62, 91, 91, 93, 95, 98, 32, 37, 37, 37, 37, 37,
 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
 37, 37, 37, 37, 37, 102, 74, 110, 107, 37, 111, 37, 37, 37, 37, 37,
 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
 37, 37, 37, 37, 37, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 105,
 118, 121, 31, 100, 101, 115, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
 92, 92, 31, 100, 101, 115, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 104, 123, 104, 116, 117, 92,
 114, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 109, 126, 116, 117, 49,
 114, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 53, 56, 56, 132, 56,
 87, 87, 87, 87, 87, 87, 87, 87, 53, 56, 53, 53, 53, 53, 53, 53,
 53, 53, 53, 53, 135, 119, 120, 109, 113, 137, 122, 53, 53, 53, 53, 53,
 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53,
 53, 53, 53, 53, 53, 119, 120, 142, 113, 53, 122, 53, 53, 53, 53, 53,
 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53,
 53, 53, 53, 53, 53, 54, 67, 54, 67, 169, 33, 106, 180, 165, 187, 192,
 195, 197, 67, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 33, 106, 112,
 124, 125, 199, 129, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 165, 112,
 124, 125, 54, 129, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 58, 58,
 58, 58, 58, 58, 58, 58, 58, 58, 202, 130, 131, 128, 133, 221, 134, 58,
 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
 58, 58, 58, 58, 58, 58, 58, 58, 58, 130, 131, 128, 133, 58, 134, 58,
 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
 58, 58, 58, 58, 58, 58, 58, 58, 58, 60, 55, 55, 243, 55, 275, 269,
 263, 315, 309, 153, 149, 303, 60, 55, 60, 60, 60, 60, 60, 60, 60, 60,
 60, 60, 297, 127, 136, 211, 349, 364, 140, 60, 60, 60, 60, 60, 60, 60,
 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
 60, 60, 60, 127, 136, 153, 149, 60, 140, 60, 60, 60, 60, 60, 60, 60,
 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
 60, 60, 60, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
 57, 57, 57, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
 48, 48, 48, 47, 85, 66, 370, 66, 374, 380, 382, 145, 176, 172, 15, 85,
 47, 66, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 405, 161, 406, 14,
 408, 409, 183, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 145, 176, 172,
 85, 47, 161, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 71, 183, 71,
 367, 11, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 73, 411, 73, 73,
 73, 73, 73, 73, 73, 73, 73, 73, 76, 76, 76, 76, 76, 76, 76, 76,
 76, 76, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 82, 82, 82, 82,
 82, 82, 82, 82, 82, 82, 78, 77, 182, 80, 9, 80, 367, 73, 80, 80,
 80, 80, 80, 80, 80, 80, 80, 80, 8, 7, 7, 6, 3, ~0U, ~0U, 35,
 78, 77, ~0U, 157, 360, ~0U, 78, 77, 182, 184, 35, 82, 35, 35, 35, 35,
 35, 35, 35, 35, 35, 35, 88, 88, 88, 88, 88, 88, 88, 88, 96, 96,
 96, 96, 96, 96, 96, 96, 96, 96, 157, 184, 185, 186, 188, 189, 190, 96,
 96, 96, 96, 96, 96, 360, ~0U, ~0U, ~0U, ~0U, ~0U, 35, ~0U, ~0U, ~0U, 191,
 139, 193, 194, 138, 196, 88, ~0U, ~0U, 356, ~0U, 185, 186, 188, 189, 190, 96,
 96, 96, 96, 96, 96, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 191,
 139, 193, 194, 138, 196, 26, 97, 97, 97, 97, 97, 97, 103, 356, 103, ~0U,
 ~0U, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 198, ~0U, 25, 200, 108,
 ~0U, 201, 28, 24, 97, 26, 97, 97, 97, 97, 97, 97, 108, 108, 108, 108,
 108, 108, 108, 108, 108, 108, ~0U, 30, 203, 29, 204, 198, 30, 25, 200, 30,
 28, 201, 29, 24, 205, 227, 30, 29, 28, 143, 143, 143, 143, 143, 143, 143,
 143, 143, 143, 28, ~0U, 226, 28, 30, 203, 29, 204, 108, 30, 352, ~0U, 30,
 28, ~0U, 29, 249, 205, 227, 30, 29, 28, 147, 147, 147, 147, 147, 147, 147,
 147, 147, 147, 28, 144, 226, 28, 144, 144, 144, 144, 144, 144, 144, 144, 144,
 144, 148, 352, 249, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 151, 151,
 151, 151, 151, 151, 151, 151, 151, 151, 152, ~0U, ~0U, 152, 152, 152, 152, 152,
 152, 152, 152, 152, 152, ~0U, 144, 155, 155, 155, 155, 155, 155, 155, 155, 155,
 155, ~0U, ~0U, 148, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 159,
 159, 159, 159, 159, 159, 159, 159, 159, 159, ~0U, 152, 160, 160, 160, 160, 160,
 160, 160, 160, 160, 160, 160, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163,
 ~0U, ~0U, 164, 156, 164, 164, 164, 164, 164, 164, 164, 164, 164, 164, 167, 167,
 167, 167, 167, 167, 167, 167, 167, 167, ~0U, ~0U, 160, 168, 168, 168, 168, 168,
 168, 168, 168, 168, 168, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, ~0U,
 ~0U, 171, ~0U, 164, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 174, 174,
 174, 174, 174, 174, 174, 174, 174, 174, 175, 23, 168, 175, 175, 175, 175, 175,
 175, 175, 175, 175, 175, 178, 178, 178, 178, 178, 178, 178, 178, 178, 178, 233,
 27, 223, 248, 171, 179, 179, 179, 179, 179, 179, 179, 179, 179, 179, 218, 23,
 235, 233, ~0U, ~0U, ~0U, 23, 255, 281, 23, 280, 175, 287, 235, 321, 27, 233,
 223, 320, 248, 338, ~0U, 347, 27, ~0U, 255, ~0U, ~0U, ~0U, ~0U, 287, 218, 23,
 235, 27, 223, 179, 27, 23, 255, 281, 23, 280, 338, 287, ~0U, 321, 27, ~0U,
 223, 320, ~0U, 338, 210, 347, 27, 210, 210, 210, 210, 210, 210, 210, 210, 210,
 210, 27, 245, 212, 27, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 220,
 220, 220, 220, 220, 220, 220, 220, 220, 220, 212, 346, 209, 208, 212, ~0U, 366,
 368, 245, 212, ~0U, 277, 294, ~0U, 222, 212, 222, 222, 222, 222, 222, 222, 222,
 222, 222, 222, 245, 212, ~0U, ~0U, 294, ~0U, 212, 346, 209, 208, 212, 220, 366,
 368, 245, 212, 277, 327, 294, 222, 369, 212, 225, 225, 225, 225, 225, 225, 225,
 225, 225, 225, 334, 371, 277, 327, ~0U, 222, 232, 232, 232, 232, 232, 232, 232,
 232, 232, 232, 277, 327, 334, 222, 369, 219, 219, 219, 219, 219, 219, 219, 219,
 219, 219, ~0U, 334, 371, 236, 232, 236, 236, 236, 236, 236, 236, 236, 236, 236,
 236, ~0U, ~0U, ~0U, ~0U, 372, ~0U, 373, 232, 207, 375, 219, 242, 242, 242, 242,
 242, 242, 242, 242, 242, 242, 232, 219, 265, 244, 236, 244, 244, 244, 244, 244,
 244, 244, 244, 244, 244, 372, 236, 373, 378, 207, 375, 219, 247, 247, 247, 247,
 247, 247, 247, 247, 247, 247, 379, 265, 244, ~0U, 236, 242, 254, 254, 254, 254,
 254, 254, 254, 254, 254, 254, 377, 381, 378, 265, 244, 241, 241, 241, 241, 241,
 241, 241, 241, 241, 241, ~0U, 379, 265, 244, 254, 257, 257, 257, 257, 257, 257,
 257, 257, 257, 257, ~0U, ~0U, 377, 381, 385, ~0U, ~0U, 254, 258, 258, 258, 258,
 258, 258, 258, 258, 258, 258, ~0U, 386, ~0U, 254, 387, 388, ~0U, 257, 239, 239,
 239, 239, 239, 239, 239, 239, 239, 239, 385, 257, 217, 217, 217, 217, 217, 217,
 217, 217, 217, 217, ~0U, 317, 305, 386, 299, ~0U, 387, 388, 264, 257, 264, 264,
 264, 264, 264, 264, 264, 264, 264, 264, 268, 268, 268, 268, 268, 268, 268, 268,
 268, 268, 299, 384, 317, 305, 390, ~0U, 391, 217, 270, 264, 270, 270, 270, 270,
 270, 270, 270, 270, 270, 270, 317, 305, ~0U, 299, ~0U, ~0U, ~0U, 264, ~0U, ~0U,
 ~0U, ~0U, 299, 384, 317, 305, 390, 268, 391, 394, ~0U, 264, 395, 396, 397, 270,
 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 276, 270, 276, 276, 276, 276,
 276, 276, 276, 276, 276, 276, ~0U, ~0U, ~0U, 394, 383, ~0U, 395, 396, 397, 270,
 ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, 398, 393, 383, 276, ~0U, ~0U, ~0U, ~0U, ~0U, 274,
 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 383, 276, 286, 286, 286, 286,
 286, 286, 286, 286, 286, 286, 398, 393, 383, 276, 273, 273, 273, 273, 273, 273,
 273, 273, 273, 273, ~0U, ~0U, 400, 401, 402, 286, 289, 289, 289, 289, 289, 289,
 289, 289, 289, 289, ~0U, ~0U, ~0U, ~0U, 403, ~0U, ~0U, 286, 290, 290, 290, 290,
 290, 290, 290, 290, 290, 290, 400, 401, 402, 286, ~0U, ~0U, ~0U, 289, 271, 271,
 271, 271, 271, 271, 271, 271, 271, 271, 403, 289, 267, 267, 267, 267, 267, 267,
 267, 267, 267, 267, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, 289, 293, 293,
 293, 293, 293, 293, 293, 293, 293, 293, 216, 216, 216, 216, 216, 216, 216, 216,
 216, 216, 21, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, 21, 298, 293, 298, 298, 298, 298,
 298, 298, 298, 298, 298, 298, 22, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, 293, ~0U, ~0U,
 22, ~0U, 21, ~0U, 298, ~0U, ~0U, 216, ~0U, 21, ~0U, 293, 302, 302, 302, 302,
 302, 302, 302, 302, 302, 302, 22, ~0U, ~0U, ~0U, ~0U, 298, ~0U, ~0U, ~0U, ~0U,
 22, ~0U, ~0U, 304, 298, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 308,
 308, 308, 308, 308, 308, 308, 308, 308, 308, ~0U, ~0U, 302, ~0U, ~0U, ~0U, ~0U,
 ~0U, 310, 304, 310, 310, 310, 310, 310, 310, 310, 310, 310, 310, ~0U, ~0U, ~0U,
 ~0U, ~0U, ~0U, ~0U, 304, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, 308, ~0U,
 ~0U, ~0U, 304, ~0U, ~0U, ~0U, 310, 314, 314, 314, 314, 314, 314, 314, 314, 314,
 314, 316, 310, 316, 316, 316, 316, 316, 316, 316, 316, 316, 316, ~0U, ~0U, ~0U,
 ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, 310, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U,
 316, ~0U, ~0U, ~0U, ~0U, ~0U, 314, 319, 319, 319, 319, 319, 319, 319, 319, 319,
 319, ~0U, 316, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, ~0U, ~0U, ~0U,
 316, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, ~0U, ~0U, ~0U, ~0U, ~0U,
 326, 329, 329, 329, 329, 329, 329, 329, 329, 329, 329, ~0U, ~0U, ~0U, ~0U, ~0U,
 ~0U, ~0U, 326, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, ~0U, ~0U, ~0U,
 326, ~0U, ~0U, ~0U, 329, 311, 311, 311, 311, 311, 311, 311, 311, 311, 311, ~0U,
 329, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, ~0U, ~0U, ~0U, ~0U, ~0U,
 ~0U, ~0U, ~0U, ~0U, 329, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 301,
 301, 301, 301, 301, 301, 301, 301, 301, 301, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U,
 ~0U, ~0U, 333, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, ~0U, ~0U, ~0U,
 ~0U, ~0U, ~0U, ~0U, 333, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, 337, ~0U, ~0U, ~0U, ~0U,
 ~0U, ~0U, 333, 215, 215, 215, 215, 215, 215, 215, 215, 215, 215, ~0U, ~0U, ~0U,
 ~0U, ~0U, 337, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, 337, 341, 341, 341, 341,
 341, 341, 341, 341, 341, 341, 342, 342, 342, 342, 342, 342, 342, 342, 342, 342,
 341, ~0U, ~0U, ~0U, 341, ~0U, ~0U, ~0U, ~0U, 341, ~0U, ~0U, ~0U, ~0U, ~0U, 341,
 213, 213, 213, 213, 213, 213, 213, 213, 213, 213, ~0U, 341, ~0U, ~0U, ~0U, ~0U,
 341, ~0U, ~0U, ~0U, 341, ~0U, ~0U, ~0U, ~0U, 341, ~0U, ~0U, ~0U, ~0U, ~0U, 341,
 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 351, 351, 351, 351, 351, 351,
 351, 351, 351, 351, 351, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 355,
 355, 355, 355, 355, 355, 355, 355, 355, 355, 355, 358, 358, 358, 358, 358, 358,
 358, 358, 358, 358, ~0U, ~0U, ~0U, ~0U, 359, 351, 359, 359, 359, 359, 359, 359,
 359, 359, 359, 359, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 355, 363,
 363, 363, 363, 363, 363, 363, 363, 363, 363, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U,
 ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, 359, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U,
 ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, ~0U, 363, 0

};

static yy_state_t yy_default[] = {
 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419,
 419, 419, 419, 419, 419, 419, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
 35, 35, 35, 419, 39, 419, 39, 419, 419, 419, 419, 39, 39, 37, 47, 419,
 419, 419, 419, 50, 53, 419, 419, 54, 54, 419, 419, 60, 419, 57, 419, 48,
 62, 47, 47, 47, 39, 39, 39, 419, 71, 419, 73, 73, 419, 419, 77, 77,
 419, 80, 419, 82, 82, 35, 35, 419, 419, 88, 88, 419, 419, 92, 92, 35,
 419, 419, 97, 97, 39, 39, 39, 419, 103, 108, 108, 108, 419, 108, 108, 108,
 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 419, 39, 419,
 419, 144, 144, 419, 419, 148, 148, 419, 419, 152, 152, 419, 419, 156, 156, 419,
 419, 160, 160, 419, 419, 164, 164, 419, 419, 168, 168, 419, 171, 171, 419, 419,
 175, 175, 419, 419, 179, 179, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
 39, 39, 419, 210, 419, 419, 212, 419, 419, 419, 219, 419, 419, 220, 419, 222,
 222, 419, 419, 419, 419, 419, 419, 419, 419, 232, 232, 219, 419, 419, 419, 419,
 236, 419, 419, 242, 419, 244, 244, 419, 419, 419, 419, 419, 419, 419, 419, 254,
 254, 419, 419, 257, 419, 419, 419, 217, 419, 264, 264, 419, 419, 268, 419, 419,
 270, 419, 419, 274, 419, 276, 276, 419, 419, 419, 419, 419, 419, 419, 419, 286,
 286, 419, 419, 289, 419, 419, 293, 293, 419, 216, 419, 298, 298, 419, 419, 302,
 419, 304, 304, 419, 419, 308, 419, 419, 310, 419, 419, 314, 419, 316, 316, 419,
 419, 419, 419, 419, 419, 419, 419, 326, 326, 419, 419, 329, 419, 419, 333, 333,
 419, 419, 337, 337, 419, 419, 419, 341, 419, 419, 419, 419, 419, 39, 419, 419,
 351, 351, 419, 419, 355, 355, 419, 419, 359, 359, 419, 419, 363, 363, 39, 39,
 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 103,
 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419,
 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419,
 419, 419, 419, 0
};

static int yy_base[] = {
 0, 3199, 3199, 1554, 3199, 3199, 1533, 1532, 1531, 1517, 3199, 1475, 3199, 3199, 1362, 1396,
 3199, 3199, 3199, 3199, 3199, 2553, 2567, 1958, 1666, 1652, 1623, 1981, 1695, 1680, 1683, 355,
 327, 631, 309, 1564, 199, 298, 3199, 208, 3199, 3199, 3199, 3199, 3199, 221, 299, 1394,
 1171, 448, 373, 233, 3199, 538, 627, 793, 539, 915, 702, 3199, 792, 3199, 310, 3199,
 3199, 3199, 1395, 628, 204, 194, 236, 1474, 294, 1486, 295, 3199, 1496, 1506, 1505, 3199,
 1534, 293, 1516, 177, 3199, 1393, 269, 528, 1574, 204, 3199, 309, 416, 264, 3199, 325,
 1582, 1637, 266, 3199, 353, 368, 354, 1665, 463, 396, 632, 357, 1692, 504, 356, 359,
 614, 522, 439, 364, 431, 426, 397, 519, 514, 398, 518, 472, 610, 605, 505, 773,
 684, 622, 696, 686, 539, 682, 698, 561, 768, 566, 1589, 1585, 772, 1909, 596, 1721,
 1767, 1390, 3199, 1753, 1780, 791, 3199, 1790, 1803, 790, 3199, 1815, 1828, 1545, 3199, 1839,
 1851, 1395, 3199, 1862, 1876, 623, 3199, 1886, 1899, 570, 3199, 1924, 1392, 3199, 1934, 1947,
 1391, 3199, 1957, 1972, 573, 3199, 1507, 1423, 1544, 1564, 1575, 575, 1560, 1572, 1569, 1594,
 636, 1583, 1598, 637, 1584, 638, 1639, 655, 1648, 1645, 725, 1676, 1671, 1695, 3199, 2148,
 2047, 2055, 2039, 808, 2053, 2992, 3199, 2931, 2568, 2314, 1947, 2152, 2063, 670, 2089, 1971,
 3199, 2121, 1698, 1682, 3199, 3199, 3199, 3199, 2137, 1938, 3199, 1949, 2167, 3199, 3199, 2302,
 3199, 2251, 2188, 733, 2203, 2052, 3199, 2220, 1935, 1712, 3199, 3199, 3199, 3199, 2236, 1961,
 3199, 2266, 2284, 3199, 3199, 3199, 3199, 737, 2334, 2202, 3199, 2538, 2344, 736, 2364, 2526,
 3199, 2474, 2400, 735, 2412, 2086, 3199, 2448, 1958, 1956, 3199, 3199, 3199, 3199, 2460, 1966,
 3199, 2490, 2508, 3199, 3199, 2558, 2056, 3199, 3199, 755, 2588, 2330, 3199, 2879, 2620, 742,
 2645, 2328, 3199, 2849, 2655, 739, 2675, 2837, 3199, 2785, 2711, 738, 2723, 2327, 3199, 2759,
 1966, 1962, 3199, 3199, 3199, 3199, 2771, 2087, 3199, 2801, 2819, 3199, 3199, 2869, 2102, 3199,
 3199, 2899, 1979, 3199, 3199, 2956, 2966, 3199, 3199, 3199, 2039, 1970, 3199, 819, 3024, 3034,
 1731, 3199, 3045, 3055, 1614, 3199, 3066, 3082, 1558, 3199, 3092, 3103, 760, 3199, 2058, 1485,
 2049, 2097, 1335, 2112, 2164, 2142, 1397, 2165, 3199, 2215, 2180, 2209, 1398, 2219, 1399, 2404,
 2321, 2263, 2267, 2263, 2278, 3199, 2321, 2339, 3199, 2410, 2359, 2379, 2374, 2369, 2421, 3199,
 2454, 2456, 2454, 2468, 3199, 1361, 1363, 3199, 1414, 1416, 3199, 1487, 3199, 3199, 3199, 3199,
 3199, 3199, 3199, 3199
};



// MKS LEX prototype scanner code
// Copyright 1991 by Mortice Kern Systems Inc.
// All rights reserved.

// You can redefine YY_INTERACTIVE to be 0 to get a very slightly
// faster scanner:
#ifndef YY_INTERACTIVE
#define	YY_INTERACTIVE	1
#endif

// You can compile with -DYY_DEBUG to get a print trace of the scanner
#ifdef YY_DEBUG
#undef YY_DEBUG
#define YY_DEBUG(fmt,a1,a2)	fprintf(stderr,fmt,a1,a2)
#else
#define YY_DEBUG(fmt,a1,a2)
#endif

const MIN_NUM_STATES = 20;

// Do *NOT* redefine the following:
#define	BEGIN		yy_start =
#define	REJECT		goto yy_reject
#define	yymore()	goto yy_more


/* #yy_movetop will be processed by yyreplace.pl, all these lines are
 * moved to top of the lex generated cpp file.
 */
/*yyreplace.pl: moved on top: #yy_movetop #include <ctype.h> */
/*yyreplace.pl: moved on top: #yy_movetop #include "assert.h" */
/*yyreplace.pl: moved on top: #yy_movetop #ifndef UTIL_IMP */
/*yyreplace.pl: moved on top: #yy_movetop #define UTIL_IMP    // declare as dllexports */
/*yyreplace.pl: moved on top: #yy_movetop #endif */
/*yyreplace.pl: moved on top: #yy_movetop #include "utilsts.h" */
/*yyreplace.pl: moved on top: #yy_movetop #define FC_LIB_USE_CRT */
/*yyreplace.pl: moved on top: #yy_movetop #include "fc_tools\fc_libmem.h" */

/*yyreplace.pl: moved on top: #yy_movetop #pragma warning( disable : 4068 4102 4244) */
/*yyreplace.pl: moved on top: #yy_movetop //foreward */
/*yyreplace.pl: moved on top: #yy_movetop class UTIL_STS_scanner; */


// Constructor for iecsyntax_scan. Set up tables
#pragma argsused
iecsyntax_scan::iecsyntax_scan(int sz, char* buf, char* sv, yy_state_t* states)
{
	mustfree = 0;
	if ((size = sz) < MIN_NUM_STATES
	  || (yytext = buf) == 0
	  || (state = states) == 0) {
		yyerror("Bad space for scanner!");
		exit(1);
	}
#ifdef YY_PRESERVE
	save = sv;
#endif
}
// Constructor for iecsyntax_scan. Set up tables
iecsyntax_scan::iecsyntax_scan(int sz)
{
	size = sz;
	yytext = new char[sz+1];	// text buffer
	state = new yy_state_t[sz+1];	// state buffer
#ifdef YY_PRESERVE
	save = new char[sz];	// saved yytext[]
	push = save + sz;
#endif
	if (yytext == NULL
#ifdef YY_PRESERVE
	  || save == NULL
#endif
	  || state == NULL) {
		yyerror("No space for scanner!");
		exit(1);
	}
	mustfree = 1;
	yy_end = 0;
	yy_start = 0;
	yy_lastc = YYNEWLINE;
	yyin = stdin;
	yyout = stdout;
	yylineno = 1;
	yyleng = 0;
}

// Descructor for iecsyntax_scan
iecsyntax_scan::~iecsyntax_scan()
{
	if (mustfree) {
		mustfree = 0;
		delete(yytext);
		delete(state);
#ifdef YY_PRESERVE
		delete(save);
#endif
	}
}

// Print error message, showing current line number
void
iecsyntax_scan::yyerror(char *fmt, ...)
{
	va_list va;

	va_start(va, fmt);
	if (yylineno)
		fprintf(stderr, "%d: ", yylineno);
	(void) vfprintf(stderr, fmt, va);
	fputc('\n', stderr);
	va_end(va);
}



// The actual lex scanner
// yy_sbuf[0:yyleng-1] contains the states corresponding to yytext.
// yytext[0:yyleng-1] contains the current token.
// yytext[yyleng:yy_end-1] contains pushed-back characters.
// When the user action routine is active,
// save contains yytext[yyleng], which is set to '\0'.
// Things are different when YY_PRESERVE is defined. 
int
iecsyntax_scan::yylex()
{
	int c, i, yybase;
	unsigned  yyst;		/* state */
	int yyfmin, yyfmax;	/* yy_la_act indices of final states */
	int yyoldi, yyoleng;	/* base i, yyleng before look-ahead */
	int yyeof;		/* 1 if eof has already been read */



#ifdef YYEXIT
	yyLexFatal = 0;
#endif
	yyeof = 0;
	i = yyleng;
	YY_SCANNER();

  yy_again:
	if ((yyleng = i) > 0) {
		yy_lastc = yytext[i-1];	// determine previous char
		while (i > 0)	//	// scan previously token
			if (yytext[--i] == YYNEWLINE)	// fix yylineno
				yylineno++;
	}
	yy_end -= yyleng;		// adjust pushback
	if (yy_end > 0)
		memmove(yytext, yytext+yyleng, (size_t) yy_end);
	i = 0;

  yy_contin:
	yyoldi = i;

	/* run the state machine until it jams */
	yyst = yy_begin[yy_start + ((yy_lastc == YYNEWLINE) ? 1 : 0)];
	state[i] = (yy_state_t) yyst;
	do {
		YY_DEBUG("<state %d, i = %d>\n", yyst, i);
		if (i >= size) {
			YY_FATAL("Token buffer overflow");
#ifdef YYEXIT
			if (yyLexFatal)
				return -2;
#endif
		}	/* endif */

		/* get input char */
		if (i < yy_end)
			c = yytext[i];		/* get pushback char */
		else if (!yyeof && (c = yygetc()) != EOF) {
			yy_end = i+1;
			yytext[i] = c;
		} else /* c == EOF */ {
			c = EOF;		/* just to make sure... */
			if (i == yyoldi) {	/* no token */
				yyeof = 0;
				if (yywrap())
					return 0;
				else
					goto yy_again;
			} else {
				yyeof = 1;	/* don't re-read EOF */
				break;
			}
		}
		YY_DEBUG("<input %d = 0x%02x>\n", c, c);

		/* look up next state */
		while ((yybase = yy_base[yyst]+(unsigned char)c) > yy_nxtmax
		    || yy_check[yybase] != (yy_state_t) yyst) {
			if (yyst == yy_endst)
				goto yy_jammed;
			yyst = yy_default[yyst];
		}
		yyst = yy_next[yybase];
	  yy_jammed: ;
	     state[++i] = (yy_state_t) yyst;
	} while (!(yyst == yy_endst || YY_INTERACTIVE &&
		yy_base[yyst] > yy_nxtmax && yy_default[yyst] == yy_endst));

	YY_DEBUG("<stopped %d, i = %d>\n", yyst, i);
	if (yyst != yy_endst)
		++i;

  yy_search:
	/* search backward for a final state */
	while (--i > yyoldi) {
		yyst = state[i];
		if ((yyfmin = yy_final[yyst]) < (yyfmax = yy_final[yyst+1]))
			goto yy_found;	/* found final state(s) */
	}
	/* no match, default action */
	i = yyoldi + 1;
	output(yytext[yyoldi]);
	goto yy_again;

  yy_found:
	YY_DEBUG("<final state %d, i = %d>\n", yyst, i);
	yyoleng = i;		/* save length for REJECT */
	
	// pushback look-ahead RHS, handling trailing context
	if ((c = (int)(yy_la_act[yyfmin]>>9) - 1) >= 0) {
		unsigned char *bv = yy_look + c*YY_LA_SIZE;
		static unsigned char bits [8] = {
			1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7
		};
		while (1) {
			if (--i < yyoldi) {	/* no / */
				i = yyoleng;
				break;
			}
			yyst = state[i];
			if (bv[(unsigned)yyst/8] & bits[(unsigned)yyst%8])
				break;
		}
	}

	/* perform action */
	yyleng = i;
	YY_USER();
	switch (yy_la_act[yyfmin] & 0777) {
	case 0:
	return '+';
	break;
	case 1:
	return '-';
	break;
	case 2:
	return '*';
	break;
	case 3:
	return '/';
	break;
	case 4:
	return UTIL_STS_POW;
	break;
	case 5:
	return UTIL_STS_AND;
	break;
	case 6:
	return UTIL_STS_EQ;
	break;
	case 7:
	return UTIL_STS_NE;
	break;
	case 8:
	return UTIL_STS_LT;
	break;
	case 9:
	return UTIL_STS_LE;
	break;
	case 10:
	return UTIL_STS_GT;
	break;
	case 11:
	return UTIL_STS_GE;
	break;
	case 12:
	return ':';
	break;
	case 13:
	return UTIL_STS_BECOMES;
	break;
	case 14:
	return UTIL_STS_RIGHT_ARROW;
	break;
	case 15:
	return ';';
	break;
	case 16:
	return '.';
	break;
	case 17:
	return UTIL_STS_DOTDOT;
	break;
	case 18:
	return ',';
	break;
	case 19:
	return '[';
	break;
	case 20:
	return ']';
	break;
	case 21:
	return '(';
	break;
	case 22:
	return ')';
	break;
	case 23:
	return '{';
	break;
	case 24:
	return '}';
	break;
	case 25:
	return '|';
	break;
	case 26:
	return UTIL_STS_PERIOD;
	break;
	case 27:
	return UTIL_STS_STRING_LITERAL_BEGIN;
	break;
	case 28:
	return UTIL_STS_SYS_COMMENT_END;
	break;
	case 29:
	return UTIL_STS_SYS_COMMENT_BEGIN;
	break;
	case 30:
	return UTIL_STS_ST_COMMENT_BEGIN;
	break;
	case 31:
	return UTIL_STS_IMPORT_DIRECTIVE;
	break;
	case 32:
	return UTIL_STS_PRAGMA_DIRECTIVE;
	break;
	case 33:
	return UTIL_STS_TRUE_LITERAL;
	break;
	case 34:
	return UTIL_STS_FALSE_LITERAL;
	break;
	case 35:
	return UTIL_STS_INT_LITERAL;
	break;
	case 36:
	return UTIL_STS_FLOAT_LITERAL;
	break;
	case 37:
	return UTIL_STS_DATE_LITERAL;
	break;
	case 38:
	return UTIL_STS_DT_LITERAL;
	break;
	case 39:
	return UTIL_STS_TOD_LITERAL;
	break;
	case 40:
	return UTIL_STS_TIME_LITERAL;
	break;
	case 41:
	return UTIL_STS_DIRECT_VARIABLE; 
	break;
	case 42:
	return UTIL_STS_IDENTIFIER_EX; 
	break;
	case 43:
	return '\n';
	break;
	case 44:
	return -10;
	break;
	case 45:
	return UTIL_STS_SYNTAX_ERROR;
	break;


	}
	YY_SCANNER();
	i = yyleng;
	goto yy_again;			/* action fell though */

  yy_reject:
	YY_SCANNER();
	i = yyoleng;			/* restore original yytext */
	if (++yyfmin < yyfmax)
		goto yy_found;		/* another final state, same length */
	else
		goto yy_search;		/* try shorter yytext */

  yy_more:
	YY_SCANNER();
	i = yyleng;
	if (i > 0)
		yy_lastc = yytext[i-1];
	goto yy_contin;
}

/*
 * user callable input/unput functions.
 */
void
iecsyntax_scan::yy_reset()
{
	YY_INIT();
	yylineno = 1;
}
/* get input char with pushback */
int
iecsyntax_scan::input()
{
	int c;
#ifndef YY_PRESERVE
	if (yy_end > yyleng) {
		yy_end--;
		memmove(yytext+yyleng, yytext+yyleng+1,
			(size_t) (yy_end-yyleng));
		c = save;
		YY_USER();
#else
	if (push < save+size) {
		c = *push++;
#endif
	} else
		c = yygetc();
	yy_lastc = c;
	if (c == YYNEWLINE)
		yylineno++;
	return c;
}

/* pushback char */
int
iecsyntax_scan::unput(int c)
{
#ifndef YY_PRESERVE
	if (yy_end >= size) {
		YY_FATAL("Push-back buffer overflow");
	} else {
		if (yy_end > yyleng) {
			yytext[yyleng] = save;
			memmove(yytext+yyleng+1, yytext+yyleng,
				(size_t) (yy_end-yyleng));
			yytext[yyleng] = 0;
		}
		yy_end++;
		save = c;
#else
	if (push <= save) {
		YY_FATAL("Push-back buffer overflow");
	} else {
		*--push = c;
#endif
		if (c == YYNEWLINE)
			yylineno--;
	}	/* endif */
	return c;
}



//returns 0 if EOF in comment
//        1 all ok
//        2 if comment is nested
static int STcomment2(
    const TCHAR   szText[/*nChars*/],
    long          nChars, 
    const TCHAR*  mat,        //see TODO in function...
    int           nNest,      //must be 1 on starting call
    long*         pnCharsRead //output: receives the number of chars 
                              //read until the end of comment
                              // szText[*pnCharsRead] id the char
                              //right after the closing *)
);
//returns 0 if EOF in comment
//        1 all ok
//        2 if comment is nested
static int STcomment(
    UTIL_STS_scanner* ps,   
    const TCHAR*      mat,  //see TODO in function...
    int               nNest //must be 1 on starting call
);





class UTIL_STS_scanner: public iecsyntax_scan
{
public:    
    const TCHAR* m_pszInput;  //string buffer as input
    unsigned long m_ulLen;    //length buffer in bytes
    unsigned long m_ulRead;   //current read position in buffer
    long          m_lOffset;  //absolute file offset of last token
    long          m_yylengOld;//size in byte of last token
	int			  m_nColumn;  //current column

    UTIL_STS_scanner() : iecsyntax_scan(UTIL_STS_MAX_TOKEN_LENGTH)
    {
        m_pszInput=NULL; 
        m_ulLen=0; 
        m_ulRead =0;
        m_lOffset = 0;
        m_yylengOld = 0;
		m_nColumn = 1;
    }
    void setStartState(int i){this->yy_start = i;}
    virtual int	yygetc()
    {                                           //##d-1618 cast unsigned!
        return m_pszInput ? (m_ulRead<m_ulLen ? (unsigned char)m_pszInput[m_ulRead++] : EOF) : getc(yyin);
    }

    virtual void yyerror(char *fmt, ...)
    {
        //the following call are made to yyerror:
        //yyerror("Bad space for scanner!");
        //yyerror("No space for scanner!");
        //yyerror("Token buffer overflow");
        //yyerror("Push-back buffer overflow");
        //do not printf error msg now, yylex will return -2
        //as for this fatal error, the caller (in jacc file must catch 
        //this retun code and print a good err msg, usually 
        //'token to long' (the other err msgs are very unlikely
    }

};


const int TEXT_RESIZE_CHAR_COUNT = 2048;
struct UTIL_STS_ScannerStruct
{
    TCHAR* pszTextBlock;
    int    iTextBlockLen;
    int    iTextBlockSize;
	UTIL_STS_scanner ps;
};

static void ClearTextBlock(UTIL_STS_ScannerStruct* ps)
{
    ps->iTextBlockLen = 0;

    if(ps->iTextBlockSize>0)
    {
        assert(ps->pszTextBlock);
        ps->pszTextBlock[0] = 0;
    }
}
static void AppendCharToTextBlock(UTIL_STS_ScannerStruct* ps, TCHAR c)
{
    if(ps->iTextBlockLen >= ps->iTextBlockSize)
    {
        ps->iTextBlockSize += TEXT_RESIZE_CHAR_COUNT * sizeof(TCHAR);
        size_t sizeNew = ps->iTextBlockSize;


        int bRet;    
        if(ps->pszTextBlock != NULL)
            bRet = FC_LibResizeMemory((void**) &(ps->pszTextBlock), sizeNew);
        else
            bRet = FC_LibNewMemory((void**) &(ps->pszTextBlock), sizeNew);
        
        assert(bRet);
    }
    if(ps->pszTextBlock)
    {
        
        //convert \r\n to \n, all internal strings are \n only:
        if(c==_T('\n') && ps->iTextBlockLen>0 && ps->pszTextBlock[ps->iTextBlockLen-1]==_T('\r'))
            ps->iTextBlockLen--;
        
        ps->pszTextBlock[ps->iTextBlockLen] = c;
        ps->iTextBlockLen++;
    }
}



UTILIF UTIL_STS_ScannerStruct* UTIL_STS_CreateScanner()
{
	UTIL_STS_ScannerStruct* ps = new UTIL_STS_ScannerStruct;
    assert(ps);

    //init struct members:
    ps->pszTextBlock = NULL;
    ps->iTextBlockLen = 0;
    ps->iTextBlockSize = 0;
    
    return ps;
}
UTILIF void UTIL_STS_DeleteScanner(UTIL_STS_ScannerStruct* ps)
{
	if(ps->pszTextBlock)
        FC_LibFreeMemory(ps->pszTextBlock);

    delete(ps);
}
UTILIF void UTIL_STS_SetInputString(UTIL_STS_ScannerStruct* ps, 
                                    const TCHAR*            pszInput, 
                                    unsigned long           ulLen)
{
    assert(pszInput !=NULL);

    ps->ps.yy_reset();
	ps->ps.setinput(NULL);


    ps->ps.m_pszInput = pszInput;
    ps->ps.m_ulLen = ulLen;
    
    //reset other variables for next scan:
    ps->ps.m_ulRead =0;
    ps->ps.m_lOffset = 0;
    ps->ps.m_yylengOld = 0;
	ps->ps.m_nColumn = 1;

    ps->ps.YY_INIT();
}

UTILIF void UTIL_STS_SetInputStringEx(
    UTIL_STS_ScannerStruct* ps, 
    const TCHAR*            pszInput, 
    unsigned long           ulLen,
	unsigned long           ulBytePos
)
{
    unsigned long ul;
    char          c;

    UTIL_STS_SetInputString(ps, pszInput, ulLen);

    for(ul=0; ul<ulBytePos;ul++) 
    {
        c = ps->ps.input();ps->ps.m_nColumn++;
        if(c == EOF) 
            return;
        else if(c == _T('\n'))
            ps->ps.m_nColumn = 1;
    }	
}




UTILIF int UTIL_STS_NextToken(UTIL_STS_ScannerStruct* ps, 
                              const TCHAR**           pszToken, 
                              int*                    pnLine,
                              int*                    pnColumn)
{
	int ntok;

    do
    {
		*pnColumn = ps->ps.m_nColumn;
        ntok = ps->ps.yylex();
        ps->ps.m_lOffset += ps->ps.m_yylengOld;
        ps->ps.m_yylengOld = ntok==0 ? 0: ps->ps.yyleng; //HACK 
        ps->ps.m_nColumn +=ps->ps.yyleng;
    }
    while(-10==ntok);

    if(ntok == '\n')
        ps->ps.m_nColumn = 1;

    *pszToken = ps->ps.yytext;
	*pnLine   = ps->ps.yylineno;
	return ntok;
}

UTILIF long UTIL_STS_GetFPosOfNextChar(
    const UTIL_STS_ScannerStruct* ps
)
{
	return ps->ps.m_lOffset + ps->ps.m_yylengOld;
}


UTILIF int UTIL_STS_GetLineColNextChar(
    const  UTIL_STS_ScannerStruct* ps,
    int*                          pCol           
)
{
    *pCol = ps->ps.m_nColumn;
	return ps->ps.yylineno;
}

UTILIF long UTIL_STS_GetOffsetOfLastToken(const UTIL_STS_ScannerStruct* ps)
{
	return ps->ps.m_lOffset;
}
UTILIF long UTIL_STS_GetLengthOfLastToken(const UTIL_STS_ScannerStruct* ps)
{
	return ps->ps.m_yylengOld;
}

UTILIF unsigned long UTIL_STS_GetLengthOfText(
    const UTIL_STS_ScannerStruct* ps
)
{
    return ps->ps.m_ulLen;
}

UTILIF int UTIL_STS_GetFPOSFromLineCol(
    const TCHAR*   pszFile,
    int            line,
    int            col,
    unsigned long* pulFpos
)
{
    const TCHAR* psz;
    
    assert(line>0 && col>0);
    if(!(line>0 && col>0))
        return 0;

    psz = pszFile; 
    
    while(line>1 && *psz)
    {
        if(*psz=='\n')
            line--;
        psz++;
    }        
    if(line!=1)
        return 0;

    while(--col>0 && *psz!=0)
        psz++;

    if(col!=0)
        return 0;

    *pulFpos = psz - pszFile;

    return 1;
}


UTILIF const TCHAR* UTIL_STS_GetText(
    const UTIL_STS_ScannerStruct* ps
)
{
    return ps->ps.m_pszInput;
}






//returns 0 if EOF in comment 
//        1 all ok
UTILIF int UTIL_STS_BufferSkipComment(
    const TCHAR**                 ppsz,
    long*                         pnChars
)
{
    const TCHAR* psz;
    long         nCharsLeft;
    long         nCharsRead;

    psz = *ppsz;
    nCharsLeft = *pnChars;

    assert(nCharsLeft>=0);


NextComment:
    while(nCharsLeft>0 && isspace(*psz))
    {
        psz++;
        nCharsLeft--;
    }
    if(nCharsLeft>=2 && psz[0]=='(' && psz[1]=='*')
    {
        nCharsLeft -= 2;
        psz += 2;
        if(STcomment2(psz, nCharsLeft, "*)", 1, &nCharsRead)==0)
        {
            *ppsz = NULL;
            *pnChars = 0;
            return 0;
        }

        nCharsLeft -= nCharsRead;
        assert(nCharsLeft>=0);
        psz += nCharsRead;
        goto NextComment;
    }

Ende:
    if(nCharsLeft>0)
    {
        *ppsz = psz;
        *pnChars = nCharsLeft;
    }
    else
    {
        assert(nCharsLeft==0);
        *ppsz = NULL;
        *pnChars = 0;
    }
    return 1;       
}




UTILIF const TCHAR* UTIL_STS_GetTextAfterLastToken(
    const UTIL_STS_ScannerStruct* ps,
    long*                         pnChars
)
{
    const TCHAR* psz;

    *pnChars = ps->ps.m_ulLen - ps->ps.m_lOffset - ps->ps.m_yylengOld;
    assert(*pnChars>=0);
    if(!ps->ps.m_pszInput || *pnChars<=0)
    {
        *pnChars = 0;
        return NULL;
    }
    
    psz =  ps->ps.m_pszInput + ps->ps.m_lOffset + ps->ps.m_yylengOld;
    assert(psz <= ps->ps.m_pszInput + ps->ps.m_ulRead);
    
    return psz;
}

UTILIF void UTIL_STS_SkipLine(UTIL_STS_ScannerStruct* ps)
{
	int c;

    ps->ps.m_lOffset += ps->ps.m_yylengOld;
    ps->ps.m_yylengOld =0;

    do
    {
        c=ps->ps.input();ps->ps.m_yylengOld++;ps->ps.m_nColumn++;
    }
	while(c!='\n' && c!=EOF);

    if(c=='\n')
    {
        ps->ps.unput(c);ps->ps.m_yylengOld--;ps->ps.m_nColumn--;
    }
}




//returns 0 if EOF in comment
//        1 all ok
//        2 if comment is nested
static int STcomment2(
    const TCHAR   szText[/*nChars*/],
    long          nChars, 
    const TCHAR*  mat, 
    int           nNest,
    long*         pnCharsRead //output: receives the number of chars 
                              //read until the end of comment
                              // szText[*pnCharsRead] id the char
                              //right after the closing *)
)
{
	int	          c;
	const TCHAR*  cp;
    char          l1=0,l2=0;
    int           ret = 1;
    long          nRead;
    
    assert(!strcmp(mat,"*)"));//sorry not really implemented a general mat
                              //see TODO below

    *pnCharsRead = 0;

    for (cp = mat; *cp != 0; ) 
    {
        if(*pnCharsRead>=nChars) 
        {
			ret = 0;
			break;
		}
        
        c = szText[*pnCharsRead];
        (*pnCharsRead)++;

        l1 = l2;
        l2 = c;
        
        if(l1=='(' && l2=='*') //TODO is not a mat as on input
        {
			if(nNest==1)
                ret = 2;

            if(0 == STcomment2(szText + *pnCharsRead, nChars - *pnCharsRead, 
                    mat, ++nNest, &nRead)
            )
            {
                *pnCharsRead += nRead;
                ret = 0;
                break;
            }
            *pnCharsRead += nRead;

            //reset:
            l1 = l2 = 0;
			cp = mat;
            continue;
        }
		if (c != *cp++) 
        {
			cp = mat;
			if (c == *cp)
				cp++;
		}
	}

    return ret;
}

//return: see STcomment2
static int STcomment(
    UTIL_STS_scanner* ps, 
    const TCHAR*      mat,  //see TODO in function...
    int               nNest //must be 1 on starting call
)
{
	int	c;
	const TCHAR* cp;
    char l1=0,l2=0;
    int ret = 1;
    
    ps->m_lOffset += ps->m_yylengOld;
    ps->m_yylengOld =0;

    assert(!strcmp(mat,"*)"));//sorry not really implemented a general mat
                              //see TODO below

    for (cp = mat; *cp != 0; ) 
    {
        c = ps->input();ps->m_yylengOld++;ps->m_nColumn++;
        
        l1 = l2;
        l2 = c;
        if (c == EOF) 
        {
			ret = 0;
			break;
		}
        else if(c == _T('\n'))
        {
            ps->m_nColumn = 1;
        }

        if(l1=='(' && l2=='*') //TODO generall mat?
        {
			if(nNest==1)
                ret = 2;

            if(0 == STcomment(ps, mat, ++nNest))
            {
                ret = 0;
                break;
            }

            //reset:
            l1 = l2 = 0;
			cp = mat;
            continue;
        }
		if (c != *cp++) 
        {
			cp = mat;
			if (c == *cp)
				cp++;
		}
	}

    return ret;
}




UTILIF int UTIL_STS_SkipComment(UTIL_STS_ScannerStruct* ps, const TCHAR* pszEnd)
{
	return STcomment(&ps->ps, pszEnd, 1);
}

UTILIF void UTIL_STS_GetTokenUpToEOL(UTIL_STS_ScannerStruct* ps)
{
    TCHAR c;

    ClearTextBlock(ps);

    ps->ps.m_lOffset += ps->ps.m_yylengOld;
    ps->ps.m_yylengOld =0;

    do
    {
        c = ps->ps.input();ps->ps.m_yylengOld++;ps->ps.m_nColumn++;

        if(c=='\n')
        {
            ps->ps.unput(c);ps->ps.m_yylengOld--;ps->ps.m_nColumn--;
            return;
        }
    }
    while(isspace(c) && c!=EOF);

    int i=0;
    while(c!='\r' &&  c!='\n' && c!=EOF)
    {
        AppendCharToTextBlock(ps, c);
        c = ps->ps.input();ps->ps.m_yylengOld++;ps->ps.m_nColumn++;
    }

    if(c=='\r' || c=='\n')
    {
        ps->ps.unput(c);ps->ps.m_yylengOld--;ps->ps.m_nColumn--;
    }

    for(i=ps->iTextBlockLen-1; i>=0 && isspace(ps->pszTextBlock[i]); )
    {
        ps->pszTextBlock[i]=0;
        ps->iTextBlockLen--;
    }
}


UTILIF int  UTIL_STS_SkipIECStringLiteral(UTIL_STS_ScannerStruct* ps, 
                                          TCHAR                   delim, 
                                          bool                    bClearBuffer)
{
    int c;

    assert(delim==_T('"') || delim==_T('\''));
   
    if(bClearBuffer)
        ClearTextBlock(ps);

    AppendCharToTextBlock(ps, delim);

    for(;;)
    {
        c = ps->ps.input();ps->ps.m_yylengOld++;ps->ps.m_nColumn++;
        
        if(c==EOF)
        {
            return 0;
        }
        else if(c==_T('$'))
        {
            AppendCharToTextBlock(ps, (TCHAR)c);
            c = ps->ps.input();ps->ps.m_yylengOld++;ps->ps.m_nColumn++;
            if(c==EOF)
                return 0;
        }
        else if(c==delim)
        {
            break;
        }
        else if(c=='\n')
        {
            ps->ps.m_nColumn = 1;        
        }
        AppendCharToTextBlock(ps, (TCHAR)c);
    }

    AppendCharToTextBlock(ps, delim);
    return 1;
}

UTILIF int UTIL_STS_SkipBlock(UTIL_STS_ScannerStruct* ps, 
                              bool                    bStore, 
                              const TCHAR*            pszEnd, 
                              bool                    bIgnoreCase)
{
    int          c;
    const TCHAR* cp;
    TCHAR        pszInput[2];
    int          ret = 1;
    
    pszInput[1] = 0;

    if(bStore)
        ClearTextBlock(ps);
        
    ps->ps.m_lOffset += ps->ps.m_yylengOld;
    ps->ps.m_yylengOld =0;

    for (cp = pszEnd; *cp != 0; ) 
    {
        c = ps->ps.input();ps->ps.m_yylengOld++;ps->ps.m_nColumn++;

        if (c == EOF) 
        {
            ret = 0;
            break;
        }
        else if(c == _T('\n'))
        {
            ps->ps.m_nColumn = 1;
        }

        if(bStore)
            AppendCharToTextBlock(ps, (TCHAR)c);

		if(bIgnoreCase)
        {
            pszInput[0] = c;
            if(!strnicmp(pszInput, cp, 1))
            {
                cp++;
            }
            else
            {
                cp = pszEnd;
                if (!strnicmp(pszInput, cp, 1))
                    cp++;
            }
        }
        else
        {
            if (c != *cp++) 
            {
                 cp = pszEnd;
                 if (c == *cp)
                 cp++;
	    }
        }
    }

    if(bStore && ret==1)
    {
        //cut the block end marker e.g. "END_NATIVE":
        int ioff = ps->iTextBlockLen - _tcslen(pszEnd);
        assert(ioff>=0);
        if(ioff>=0)
            ps->pszTextBlock[ps->iTextBlockLen - _tcslen(pszEnd)] = 0;
    }

    return  ret;
}



UTILIF int UTIL_STS_SkipMatchingBrace(
    UTIL_STS_ScannerStruct* ps, 
    bool                    bStore, 
    TCHAR                   cBrace
)
{
	int	   c;
    TCHAR  endChar;
    int    iOpenBlock = 1;
    

    if(cBrace==_T('('))
        endChar = _T('(');
    else if(cBrace==_T('{'))     
        endChar = _T('}');
    else if(cBrace==_T('['))     
        endChar = _T(']');
    else if(cBrace==_T('<'))     
        endChar = _T('>');
    else 
    {
        assert(!"bad brace");
        return -1;
    }

    if(bStore)
        ClearTextBlock(ps);
        
    ps->ps.m_lOffset += ps->ps.m_yylengOld;
    ps->ps.m_yylengOld =0;

    for (;;) 
    {
        c = ps->ps.input();ps->ps.m_yylengOld++;ps->ps.m_nColumn++;

        if (c == EOF) 
        {
			return 0;
		}
        else if(c == _T('\n'))
        {
            ps->ps.m_nColumn = 1;
        }
        else if(c==cBrace)
        {
            iOpenBlock++;
        }
        else if(c==endChar)
        {
            iOpenBlock--;
            if(iOpenBlock==0)
                return 1;
        }

        if(bStore)
            AppendCharToTextBlock(ps, (TCHAR)c);

    }

    return 0;
}




UTILIF const TCHAR* UTIL_STS_GetSkippedTextBlock(UTIL_STS_ScannerStruct* ps)
{
    //null terminate anyway:
    AppendCharToTextBlock(ps, 0);
    assert(ps->pszTextBlock);
    return ps->pszTextBlock;
}

/* end of lex file */
/*END yyreplace.pl: file iecsyntax.cpp~ */
